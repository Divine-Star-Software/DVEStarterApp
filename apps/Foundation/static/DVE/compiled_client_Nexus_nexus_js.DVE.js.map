{"version":3,"file":"compiled_client_Nexus_nexus_js.DVE.js","mappings":";;;;;;;;;;;;;;AAAiD;AACjD,WAAW,iBAAiB;AACiC;AAC7D,MAAM,iEAAU;AAChB,qBAAqB,2EAAiB,CAAC,2DAAI;AAC3C;AACA,4EAAqB;AACrB;AACA,CAAC;AACD;AACA,4EAAqB;AACrB;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,IAAI,+EAAwB;AAC5B,CAAC;AACD;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBD;AACwC;AACiB;AACgB;AACZ;AACiB;AACvB;AACqB;AAClB;AACT;AACqB;AACQ;AACL;AACZ;AACtD;AACP;AACA,iBAAiB,6DAAqB,CAAC,mGAA6B;AACpE,YAAY,+FAAkC;AAC9C,SAAS;AACT,iBAAiB,6DAAqB,CAAC,mGAA6B;AACpE,YAAY,+FAAkC;AAC9C,SAAS;AACT,KAAK;AACL;AACA,eAAe,6DAAqB,CAAC,8FAAwB;AAC7D,YAAY,sFAAkC;AAC9C,SAAS;AACT,mBAAmB,6DAAqB,CAAC,kGAA4B;AACrE,YAAY,8FAAiC;AAC7C,SAAS;AACT,KAAK;AACL;AACA,mBAAmB,6DAAqB,CAAC,2FAAqB;AAC9D,YAAY,yGAAoC;AAChD,SAAS;AACT,eAAe,6DAAqB,CAAC,uFAAiB;AACtD,YAAY,4EAAuB;AACnC,SAAS;AACT,YAAY,+EAA0B;AACtC,SAAS;AACT,gBAAgB,6DAAqB,CAAC,wFAAkB;AACxD,YAAY,6EAAwB;AACpC,SAAS;AACT,YAAY,gFAA2B;AACvC,SAAS;AACT,gBAAgB,6DAAqB,CAAC,wFAAkB;AACxD,YAAY,6EAAwB;AACpC,SAAS;AACT,YAAY,gFAA2B;AACvC,SAAS;AACT,sBAAsB,6DAAqB,CAAC,8FAAwB;AACpE,YAAY,4FAAwB;AACpC,SAAS;AACT,YAAY,+FAA2B;AACvC,SAAS;AACT,KAAK;AACL;AACA,eAAe,6DAAqB,CAAC,2FAAqB;AAC1D,YAAY,gEAAe;AAC3B,YAAY,+DAAc;AAC1B,SAAS;AACT,mBAAmB,6DAAqB,CAAC,+FAAyB;AAClE,YAAY,6EAAmB;AAC/B,SAAS;AACT,eAAe,6DAAqB,CAAC,2FAAqB;AAC1D,YAAY,sEAAe;AAC3B,SAAS;AACT,gBAAgB,6DAAqB,CAAC,4FAAsB;AAC5D,YAAY,yEAAgB;AAC5B,SAAS;AACT,gBAAgB,6DAAqB,CAAC,4FAAsB;AAC5D,YAAY,yEAAgB;AAC5B,YAAY,+EAAsB;AAClC,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;AC3EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACiE;AACjE;AACgD;AACoB;AACpE;AAC4D;AACL;AACF;AACQ;AACrB;AACqB;AACR;AAC9C;AACP;AACA,QAAQ,kDAAU;AAClB,UAAU,wDAAI;AACd,cAAc,4EAAc;AAC5B,kBAAkB,+DAAY;AAC9B,UAAU,6DAAW;AACrB,eAAe,qEAAY;AAC3B,eAAe,8DAAS;AACxB,gBAAgB,+DAAU;AAC1B;AACA,cAAc,yEAAe;AAC7B,KAAK;AACL;AACA,mBAAmB,qEAAY;AAC/B,KAAK;AACL;AACA,mBAAmB,6DAAQ;AAC3B;AACA;AACA,mBAAmB,sEAAkB;;;;;;;;;;;;;;;;;ACjC6B;AAC1B;AACjC;AACP;AACA;AACA;AACA;AACA,UAAU,wDAAgB;AAC1B,yCAAyC;AACzC,mBAAmB,kFAAwB;AAC3C,SAAS,oBAAoB;AAC7B;;;;;;;;;;;;;;;;;;;;;ACXuE;AAC/B;AACiB;AACL;AAC7C,mBAAmB,yDAAiB;AACpC,sBAAsB,6DAAqB;AAC3C,kBAAkB,6DAAqB;AAC9C,gEAAwB;AACxB,IAAI,yFAA2B;AAC/B,IAAI,kFAAgC;AACpC,IAAI,4EAA4B;AAChC,CAAC;;;;;;;;;;;;;;;;ACX4C;AACtC;AACP;AACA;AACA,eAAe,8DAAiB;AAChC,KAAK;AACL;;;;;;;;;;;;;;;;ACN4C;;;;;;;;;;;;;;;;ACA0B;AAC/D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd,mBAAmB,gFAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC,6BAA6B,SAAS;AACtC,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjGsE;AACvB;AACI;AAC5C;AACP;AACA,yBAAyB,wDAAW;AACpC,6BAA6B,gFAAO;AACpC;AACA;AACA;AACA;AACA,4BAA4B,4DAAa;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChBsE;AACf;AAChD;AACP;AACA;AACA,kBAAkB,gEAAe;AACjC,mBAAmB,gFAAO;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACXO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1CsE;AAC/D;AACP,gBAAgB,gFAAO;AACvB,cAAc,gFAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACTsE;AAC/D;AACP,qBAAqB,gFAAO;AAC5B,iBAAiB,gFAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3BO;AACP,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACfA;AAC6D;AACM;AACU;AACtE;AACP,oCAAoC,qEAAW,QAAQ,2EAAa,QAAQ,qFAAmB;AAC/F;;;;;;;;;;;;;;;;ACNwD;AACjD,0BAA0B,0DAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,qEAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACbwD;AACD;AAChD,kCAAkC,0DAAQ;AACjD;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B;AACA;AACA;AACA,6BAA6B,qEAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChBwD;AACjD,4BAA4B,0DAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,qCAAqC,qEAAmB;AACxD,kCAAkC,qEAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACfsE;AACF;AACJ;AACtB;AACE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA,mBAAmB,gFAAO;AAC1B,mBAAmB,gFAAO;AAC1B,qBAAqB,wEAAe;AACpC,kBAAkB,kDAAI;AACtB,mBAAmB,oDAAK;AACxB,wBAAwB,gFAAO;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qFAAY;AAC1C;AACA,0DAA0D,qFAAY;AACtE;AACA;AACA;AACA;AACA;AACA,YAAY,sFAAc;AAC1B,YAAY,sFAAc;AAC1B;AACA;AACA;AACA,gEAAgE,qFAAY;AAC5E;AACA;AACA;AACA;AACA;AACA,YAAY,sFAAc;AAC1B,YAAY,sFAAc;AAC1B;AACA;AACA;AACA;AACA,0DAA0D,uFAAc;AACxE;AACA;AACA;AACA;AACA,YAAY,sFAAc;AAC1B,YAAY,sFAAc;AAC1B;AACA;AACA;AACA;AACA,iEAAiE,oFAAW;AAC5E;AACA;AACA;AACA;AACA,YAAY,sFAAc;AAC1B,YAAY,sFAAc;AAC1B;AACA;AACA;AACA;AACA,0DAA0D,sFAAa;AACvE;AACA;AACA;AACA;AACA,YAAY,sFAAc;AAC1B,YAAY,sFAAc;AAC1B;AACA;AACA;AACA;AACA,gEAAgE,sFAAa;AAC7E;AACA;AACA;AACA;AACA,YAAY,sFAAc;AAC1B,YAAY,sFAAc;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C,mCAAmC,WAAW;AAC9C,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;AC1OO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;ACFA;AAC8D;AACQ;AACL;AACjE;AAC6F;AAC3B;AAClB;AACzC;AACP,UAAU,wEAAS;AACnB,gBAAgB,+EAAiB;AACjC,eAAe,0EAAe;AAC9B;AACA,eAAe,yDAAQ;AACvB,KAAK;AACL;AACA,mBAAmB,2EAAe;AAClC,KAAK;AACL;AACA,0GAAwB;;;;;;;;;;;;;;;;;ACnB+B;AACgB;AAChE;AACP;AACA,eAAe,+DAAW;AAC1B;AACA;AACA;AACA;AACA,QAAQ,gGAAkC;AAC1C;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;;;;;;;ACnLyC;AACH;AACX;AACK;AAC7D;AACA;AACA;AACA;AACO;AACP,6BAA6B,gFAAO;AACpC,kBAAkB,gFAAO;AACzB,uBAAuB,gFAAO;AAC9B,mBAAmB,gFAAO;AAC1B,mBAAmB,gFAAO;AAC1B,oBAAoB,gFAAO;AAC3B,gBAAgB,gFAAO;AACvB,sBAAsB,gEAAW;AACjC,gBAAgB,qEAAY;AAC5B,mBAAmB,2EAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzDkD;AACoB;AAC/D,8BAA8B,gFAAQ;AAC7C;AACA;AACA;AACA;AACA,eAAe,6EAAyB;AACxC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZsE;AAC/D;AACP;AACA,uBAAuB,gFAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;AC/CwC;AACC;;;;;;;;;;;;;;;;;;;;ACDgB;AACQ;AACJ;AACO;AACrB;AAC/C;AACA,YAAY,iDAAiD,EAAE,gFAAmB;AAClF;AACA;AACA;AACA,IAAI,yEAAqB,OAAO,yEAAiB;AACjD;AACA;AACA;AACA,IAAI,uEAAmB,OAAO,qEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uBAAuB,wDAAW,CAAC,yEAAqB,EAAE,uEAAmB;AAC7E;AACA;;;;;;;;;;;;;;;;;;;;AClCwE;AACZ;AACc;AACG;AACnC;AAC1C,YAAY,uFAAiB;AACtB,0BAA0B,kFAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAO;AAC/B,2BAA2B,sEAAO;AAClC;AACA;AACA;AACA,kBAAkB,uFAAiB;AACnC;AACA;AACA;AACA,sBAAsB,kGAA4B;AAClD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,kBAAkB,uFAAiB;AACnC;AACA;AACA;AACA,sBAAsB,kGAA4B;AAClD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,kBAAkB,uFAAiB;AACnC;AACA;AACA;AACA,sBAAsB,mGAA6B;AACnD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,kBAAkB,uFAAiB;AACnC;AACA;AACA;AACA,sBAAsB,mGAA6B;AACnD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wBAAwB,sEAAO;AAC/B;AACA;AACA;AACA,4CAA4C,iGAAyC;AACrF;AACA;AACA,4CAA4C,uFAA+B;AAC3E;AACA;AACA;AACA,YAAY,8FAAsC;AAClD;AACA;AACA;AACA,YAAY,gGAAwC;AACpD;AACA;AACA;AACA;AACA;AACA,4CAA4C,uFAA+B;AAC3E;AACA,gBAAgB,gGAAwC;AACxD;AACA;AACA;AACA;AACA;AACA,4CAA4C,uFAA+B;AAC3E;AACA,gBAAgB,gGAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,8EAA6B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7NqC;AACJ;;;;;;;UCDjC;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;WClCA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,aAAa;WACb;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;;;;;WCpCA;WACA;WACA;WACA;;;;;UEHA;UACA","sources":["webpack://dve-testing/./compiled/client/Nexus/nexus.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataSyncNode.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Classes/Scalar.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Nexus/DivineVoxelEngineNexus.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Nexus/Init/InitNexusWorker.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Nexus/Threads/NexusTheads.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Nexus/Threads/NexusThreadState.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Nexus/index.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Classes/BoundingBox.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Classes/Collider.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Classes/CollisionNode.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Classes/CollisionResult.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Classes/Line.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Classes/Plane.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Colliders/ColliderManager.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Colliders/Functions/RegisterDefaultColliders.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Colliders/default/Box/Box.collider.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Colliders/default/Box/ClimableBox.collider.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Colliders/default/Stair/Stair.collider.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Collisions/CollisionsHandler.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Constants/Flags.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/DivineVoxelPhysics.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Entities/EntityBase.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Math/EaseAndTween.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Nodes/PhysicsNodes.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Tools/Data/PhysicsDataTool.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/Tools/Data/PhysicsProbe.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Physics/dist/index.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Player/dist/Nexus/InitNexusPlayer.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Player/dist/Nexus/NexusPlayer.js","webpack://dve-testing/../../DSLIBS/dvePlugIns/Player/dist/Nexus/index.js","webpack://dve-testing/webpack/bootstrap","webpack://dve-testing/webpack/runtime/async module","webpack://dve-testing/webpack/runtime/chunk loaded","webpack://dve-testing/webpack/runtime/define property getters","webpack://dve-testing/webpack/runtime/ensure chunk","webpack://dve-testing/webpack/runtime/get javascript chunk filename","webpack://dve-testing/webpack/runtime/global","webpack://dve-testing/webpack/runtime/hasOwnProperty shorthand","webpack://dve-testing/webpack/runtime/make namespace object","webpack://dve-testing/webpack/runtime/publicPath","webpack://dve-testing/webpack/runtime/importScripts chunk loading","webpack://dve-testing/webpack/runtime/startup chunk dependencies","webpack://dve-testing/webpack/before-startup","webpack://dve-testing/webpack/startup","webpack://dve-testing/webpack/after-startup"],"sourcesContent":["import { DVEN } from \"divine-voxel-engine/Nexus\";\r\n//import { GetNexusPlayer } from \"./Player/InitNexusPlayer.js\";\r\nimport { INIT_NEXUS_PLAYER } from \"dve-plugins-player/Nexus\";\r\nawait DVEN.$INIT();\r\nconst player = await INIT_NEXUS_PLAYER(DVEN);\r\nplayer.node.setPosition(0, 200, 0);\r\nDVEN.TC.registerTasks(\"set-player-position\", (data) => {\r\n    player.node.setPosition(...data);\r\n});\r\nlet updating = false;\r\nDVEN.TC.registerTasks(\"start-world\", (data) => {\r\n    console.log(\"Sstart world\", data);\r\n    updating = true;\r\n    player.node.setPosition(...data);\r\n});\r\nlet lastMaterial = \"stone\";\r\nsetInterval(() => {\r\n    if (!updating)\r\n        return;\r\n    player.update();\r\n    DVEN.parentComm.runTasks(\"set-material\", player.materialStandingOn);\r\n}, 17);\r\nsetInterval(() => {\r\n    console.log(player.position.x, player.position.y, player.position.z);\r\n}, 2_000);\r\n","//objects\nimport { ThreadComm } from \"threadcomm\";\nimport { WorldRegister } from \"./World/WorldRegister.js\";\nimport { DataSyncIds } from \"../Common/Threads/Contracts/DataSyncIds.js\";\nimport { VoxelPaletteReader } from \"./Voxel/VoxelPalette.js\";\nimport { DimensionsRegister } from \"./World/Dimensions/DimensionsRegister.js\";\nimport { ChunkTags } from \"./World/Chunk/ChunkTags.js\";\nimport { RegionHeaderTags, RegionTags } from \"./World/Region/RegionTags.js\";\nimport { ColumnTags } from \"./World/Column/ColumnTags.js\";\nimport { VoxelTags } from \"./Voxel/VoxelTags.js\";\nimport { MappedDataRegister } from \"./Register/MappedDataRegister.js\";\nimport { RegionHeaderRegister } from \"./World/Region/RegionHeaderRegister.js\";\nimport { SubstancePaletteReader } from \"./Substance/SubstancePalette.js\";\nimport { SubstanceTags } from \"./Substance/SubstanceTags.js\";\nexport const DataSyncNode = {\n    maps: {\n        strings: ThreadComm.onDataSync(DataSyncIds.registerStringMap, (data) => {\n            MappedDataRegister.stringMaps.sync(data);\n        }),\n        objects: ThreadComm.onDataSync(DataSyncIds.registerObjectMap, (data) => {\n            MappedDataRegister.objectMaps.sync(data);\n        }),\n    },\n    palettes: {\n        voxel: ThreadComm.onDataSync(DataSyncIds.voxelPalette, ([palette, map]) => {\n            VoxelPaletteReader.setVoxelPalette(palette, map);\n        }),\n        substance: ThreadComm.onDataSync(DataSyncIds.substancePalette, ([palette, map]) => {\n            SubstancePaletteReader.setPalette(palette, map);\n        }),\n    },\n    worldData: {\n        dimension: ThreadComm.onDataSync(DataSyncIds.dimesnion, (data) => {\n            DimensionsRegister.registerDimension(data.id, data.options);\n        }),\n        chunk: ThreadComm.onDataSync(DataSyncIds.chunk, (data) => {\n            WorldRegister.chunk.add(data[0], data[1]);\n        }, (data) => {\n            WorldRegister.chunk.remove(data);\n        }),\n        column: ThreadComm.onDataSync(DataSyncIds.column, (data) => {\n            WorldRegister.column.add(data[0], data[1]);\n        }, (data) => {\n            WorldRegister.column.remove(data);\n        }),\n        region: ThreadComm.onDataSync(DataSyncIds.region, (data) => {\n            WorldRegister.region.add(data[0], data[1]);\n        }, (data) => {\n            WorldRegister.region.remove(data);\n        }),\n        regionHeader: ThreadComm.onDataSync(DataSyncIds.regionHeader, (data) => {\n            RegionHeaderRegister.add(data[0], data[1]);\n        }, (data) => {\n            RegionHeaderRegister.remove(data);\n        }),\n    },\n    tags: {\n        voxel: ThreadComm.onDataSync(DataSyncIds.voxelTags, (data) => {\n            VoxelTags.$INIT(data[0]);\n            VoxelTags.sync(new Uint16Array(data[1]));\n        }),\n        substance: ThreadComm.onDataSync(DataSyncIds.substanceTags, (data) => {\n            SubstanceTags.$INIT(data);\n        }),\n        chunk: ThreadComm.onDataSync(DataSyncIds.chunkTags, (data) => {\n            ChunkTags.$INIT(data);\n        }),\n        column: ThreadComm.onDataSync(DataSyncIds.columnTags, (data) => {\n            ColumnTags.$INIT(data);\n        }),\n        region: ThreadComm.onDataSync(DataSyncIds.regionTags, (data) => {\n            RegionTags.$INIT(data[0]);\n            RegionHeaderTags.$INIT(data[1]);\n        }),\n    },\n};\n","export class Scalar {\n    value;\n    static Between(value, min, max) {\n        return value >= min && value <= max;\n    }\n    constructor(value = 0) {\n        this.value = value;\n    }\n}\n","//comms\nimport { WorldComm, ParentComm } from \"./Threads/NexusTheads.js\";\n//objects\nimport { Util } from \"../Global/Util.helper.js\";\nimport { EngineSettings } from \"../Data/Settings/EngineSettings.js\";\n//functions\nimport { InitNexusWorker } from \"./Init/InitNexusWorker.js\";\nimport { DataSyncNode } from \"../Data/DataSyncNode.js\";\nimport { DataManager } from \"../Data/DataManager.js\";\nimport { WorldPainter } from \"../Data/World/WorldPainter.js\";\nimport { ThreadComm } from \"threadcomm\";\nimport { RichDataTool } from \"../Tools/Data/RichDataTool.js\";\nimport { DataTool } from \"../Tools/Data/DataTool.js\";\nexport const DVEN = {\n    environment: \"browser\",\n    TC: ThreadComm,\n    UTIL: Util,\n    settings: EngineSettings,\n    dataSyncNode: DataSyncNode,\n    data: DataManager,\n    worldData: WorldPainter,\n    worldComm: WorldComm,\n    parentComm: ParentComm,\n    async $INIT() {\n        await InitNexusWorker(this);\n    },\n    getRichDataTool() {\n        return new RichDataTool();\n    },\n    getDataTool() {\n        return new DataTool();\n    }\n};\nDVEN.environment = Util.getEnviorment();\n","import { NexusThreadState } from \"../Threads/NexusThreadState.js\";\nimport { ThreadComm } from \"threadcomm\";\nexport async function InitNexusWorker(DVEN) {\n    let parent = \"render\";\n    if (DVEN.environment == \"node\") {\n        parent = \"server\";\n    }\n    await ThreadComm.$INIT(\"nexus\", parent);\n    await DVEN.UTIL.createPromiseCheck({ check: () => {\n            return NexusThreadState.isReady();\n        }, checkInterval: 1 });\n}\n","import { EngineSettings } from \"../../Data/Settings/EngineSettings.js\";\nimport { ThreadComm } from \"threadcomm\";\nimport { NexusThreadState } from \"./NexusThreadState.js\";\nimport { DataHooks } from \"../../Data/DataHooks.js\";\nexport const ParentComm = ThreadComm.parent;\nexport const RichWorldComm = ThreadComm.createComm(\"rich-world\");\nexport const WorldComm = ThreadComm.createComm(\"world\");\nThreadComm.registerTasks(\"sync-settings\", (settings) => {\n    EngineSettings.syncSettings(settings);\n    NexusThreadState._settingsSynced = true;\n    DataHooks.settingsSynced.run(settings);\n});\n","import { WorldComm } from \"./NexusTheads.js\";\nexport const NexusThreadState = {\n    _settingsSynced: false,\n    isReady() {\n        return WorldComm.isReady() && this._settingsSynced;\n    },\n};\n","export * from \"./DivineVoxelEngineNexus.js\";\n","import { Vector3 } from \"divine-voxel-engine/Math/Classes/Vector3.js\";\nexport class BoundingBox {\n    bounds = {\n        minX: Infinity,\n        maxX: -Infinity,\n        minZ: Infinity,\n        maxZ: -Infinity,\n        minY: Infinity,\n        maxY: -Infinity,\n    };\n    _full = { w: 0.8, h: 1.8, d: 0.8 };\n    _half = { w: 0.8 / 2, h: 1.8 / 2, d: 0.8 / 2 };\n    position = new Vector3(0, 0, 0);\n    constructor(width = 1, height = width, depth = width) {\n        this._full.w = width;\n        this._full.h = height;\n        this._full.d = depth;\n        this._half.w = width / 2;\n        this._half.h = height / 2;\n        this._half.d = depth / 2;\n    }\n    update(width, height, depth) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n    }\n    setPosition(position) {\n        this.position.updateFromVec3(position);\n        const o = this.position;\n        this.bounds.minX = o.x;\n        this.bounds.maxX = o.x + this.width;\n        this.bounds.minZ = o.z;\n        this.bounds.maxZ = o.z + this.depth;\n        this.bounds.minY = o.y;\n        this.bounds.maxY = o.y + this.height;\n    }\n    get width() {\n        return this._full.w;\n    }\n    get height() {\n        return this._full.h;\n    }\n    get depth() {\n        return this._full.d;\n    }\n    set width(width) {\n        this._full.w = width;\n        this._half.w = width / 2;\n    }\n    set height(height) {\n        this._full.h = height;\n        this._half.h = height / 2;\n    }\n    set depth(depth) {\n        this._full.d = depth;\n        this._half.d = depth / 2;\n    }\n    get halfWidth() {\n        return this._half.w;\n    }\n    get halfHeight() {\n        return this._half.h;\n    }\n    get halfDepth() {\n        return this._half.d;\n    }\n    pointIsInside(point) {\n        return (point.x >= this.bounds.minX &&\n            point.x <= this.bounds.maxX &&\n            point.y >= this.bounds.minY &&\n            point.y <= this.bounds.maxY &&\n            point.z >= this.bounds.minZ &&\n            point.z <= this.bounds.maxZ);\n    }\n    doesIntersect(boundingBox) {\n        return (this.bounds.minX <= boundingBox.bounds.maxX &&\n            this.bounds.maxX >= boundingBox.bounds.minX &&\n            this.bounds.minY <= boundingBox.bounds.maxY &&\n            this.bounds.maxY >= boundingBox.bounds.minY &&\n            this.bounds.minZ <= boundingBox.bounds.maxZ &&\n            this.bounds.maxZ >= boundingBox.bounds.minZ);\n    }\n    *query() {\n        const sx = Math.floor(this.bounds.minX);\n        const sy = Math.floor(this.bounds.minY);\n        const sz = Math.floor(this.bounds.minZ);\n        const mx = Math.ceil(this.bounds.maxX);\n        const my = Math.ceil(this.bounds.maxY);\n        const mz = Math.ceil(this.bounds.maxZ);\n        for (let y = sy; y <= my; y++) {\n            for (let x = sx; x <= mx; x++) {\n                for (let z = sz; z <= mz; z++) {\n                    yield [x, y, z];\n                }\n            }\n        }\n    }\n}\n","import { Vector3 } from \"divine-voxel-engine/Math/Classes/Vector3.js\";\nimport { BoundingBox } from \"./BoundingBox.js\";\nimport { CollisionNode } from \"./CollisionNode.js\";\nexport class Collider {\n    static createBBox(width = 1, height = width, depth = width) {\n        const bbox = new BoundingBox(width, height, depth);\n        bbox.setPosition(new Vector3(0, 0, 0));\n        return bbox;\n    }\n    nodes = [];\n    addNode(name, boundingBox) {\n        this.nodes.push(new CollisionNode(name, boundingBox));\n    }\n    hasFlag(id) {\n        return this.flags[id] !== undefined;\n    }\n}\n","import { Vector3 } from \"divine-voxel-engine/Math/Classes/Vector3.js\";\nimport { CollisionResult } from \"./CollisionResult.js\";\nexport class CollisionNode {\n    name;\n    boundingBox;\n    results = new CollisionResult();\n    position = new Vector3(0, 0, 0);\n    constructor(name, boundingBox) {\n        this.name = name;\n        this.boundingBox = boundingBox;\n    }\n}\n","export class CollisionResult {\n    raw = {\n        hitDepth: 1,\n        nx: 0,\n        ny: 0,\n        nz: 0,\n    };\n    update(h, nx, ny, nz) {\n        this.raw.hitDepth = h;\n        this.raw.nx = nx;\n        this.raw.ny = ny;\n        this.raw.nz = nz;\n        return this;\n    }\n    loadIn(results) {\n        this.raw.hitDepth = results.raw.hitDepth;\n        this.raw.nx = results.raw.nx;\n        this.raw.ny = results.raw.ny;\n        this.raw.nz = results.raw.nz;\n    }\n    reset() {\n        this.raw.hitDepth = 1;\n        this.raw.nx = 0;\n        this.raw.ny = 0;\n        this.raw.nz = 0;\n    }\n    collided() {\n        return this.raw.hitDepth < 1;\n    }\n    faceHit = {\n        top: () => this.raw.ny == 1 && this.collided(),\n        bottom: () => this.raw.ny == -1 && this.collided(),\n        east: () => this.raw.nx == 1 && this.collided(),\n        west: () => this.raw.nx == -1 && this.collided(),\n        north: () => this.raw.nz == 1 && this.collided(),\n        south: () => this.raw.nz == -1 && this.collided(),\n    };\n    normalHit = {\n        x: () => this.raw.nx,\n        y: () => this.raw.ny,\n        z: () => this.raw.nz,\n    };\n}\n","import { Vector3 } from \"divine-voxel-engine/Math/Classes/Vector3.js\";\nexport class Line {\n    start = new Vector3(0, 0, 0);\n    end = new Vector3(1, 1, 1);\n    update(start, end) {\n        this.start.updateFromVec3(start);\n        this.end.updateFromVec3(end);\n        return this;\n    }\n}\n","import { Vector3 } from \"divine-voxel-engine/Math/Classes/Vector3.js\";\nexport class Plane {\n    dimensions = new Vector3(0, 0, 0);\n    normal = new Vector3(0, 0, 0);\n    update(dimensions, normal) {\n        this.dimensions.updateFromVec3(dimensions);\n        this.normal.updateFromVec3(normal);\n        return this;\n    }\n    /**# Line To Plane\n     * @returns  a value between 0 and 1.\n     *\n     * 1 meaning there was no collision\n     * and 0.5 meaning there was collision at the halfway mark of the bouding box.\n     *\n     */\n    lineToPlane(line) {\n        const NdotU = this.normal.x * line.end.x +\n            this.normal.y * line.end.y +\n            this.normal.z * line.end.z;\n        return NdotU == 0\n            ? Infinity\n            : (this.normal.x * (this.dimensions.x - line.start.x) +\n                this.normal.y * (this.dimensions.y - line.start.y) +\n                this.normal.z * (this.dimensions.z - line.start.z)) /\n                NdotU;\n    }\n}\n","export const ColliderManager = {\n    colliders: {},\n    registerCollider(collider) {\n        if (Array.isArray(collider)) {\n            return collider.forEach((_) => (this.colliders[_.id] = _));\n        }\n        this.colliders[collider.id] = collider;\n    },\n    getCollider(id) {\n        const collider = this.colliders[id];\n        if (!collider) {\n            throw new Error(`Collider with ${id} does not exists.`);\n        }\n        return collider;\n    },\n};\n","//default colliders\nimport { BoxCollider } from \"../default/Box/Box.collider.js\";\nimport { StairCollider } from \"../default/Stair/Stair.collider.js\";\nimport { ClimableBoxCollider } from \"../default/Box/ClimableBox.collider.js\";\nexport function RegisterDefaultColliders(colliders) {\n    colliders.registerCollider([new BoxCollider(), new StairCollider(), new ClimableBoxCollider()]);\n}\n","import { Collider } from \"../../../Classes/Collider.js\";\nexport class BoxCollider extends Collider {\n    id = \"#dve_box\";\n    isSolid = true;\n    flags = {};\n    constructor() {\n        super();\n        this.addNode(\"main\", Collider.createBBox());\n    }\n    getNodes(dataTool) {\n        this.nodes[0].position.set(dataTool.x, dataTool.y, dataTool.z);\n        return this.nodes;\n    }\n}\n","import { Collider } from \"../../../Classes/Collider.js\";\nimport { DVPFlags } from \"../../../Constants/Flags.js\";\nexport class ClimableBoxCollider extends Collider {\n    id = \"#dve_climable_box\";\n    isSolid = false;\n    flags = {\n        [DVPFlags.climbable]: 1\n    };\n    constructor() {\n        super();\n        this.addNode(\"main\", Collider.createBBox());\n    }\n    getNodes(dataTool) {\n        this.nodes[0].position.set(dataTool.x, dataTool.y, dataTool.z);\n        return this.nodes;\n    }\n}\n","import { Collider } from \"../../../Classes/Collider.js\";\nexport class StairCollider extends Collider {\n    id = \"#dve_stair\";\n    isSolid = true;\n    flags = {};\n    constructor() {\n        super();\n        this.addNode(\"stair-bottom\", Collider.createBBox(1, 0.5, 1));\n        this.addNode(\"stair-top\", Collider.createBBox(1, 0.5, 0.5));\n    }\n    getNodes(dataTool) {\n        this.nodes[0].position.set(dataTool.x, dataTool.y, dataTool.z);\n        this.nodes[1].position.set(dataTool.x, dataTool.y + 0.5, dataTool.z);\n        return this.nodes;\n    }\n}\n","import { Vector3 } from \"divine-voxel-engine/Math/Classes/Vector3.js\";\nimport { Scalar } from \"divine-voxel-engine/Math/Classes/Scalar.js\";\nimport { CollisionResult } from \"../Classes/CollisionResult.js\";\nimport { Line } from \"../Classes/Line.js\";\nimport { Plane } from \"../Classes/Plane.js\";\n/** # CollisionsHanlder\n * Handles collision handling for physics nodes.\n * ***\n *\n * The swept AABB code was adapted from this article:\n * https://luisreis.net/blog/aabb_collision_handling/\n */\nexport const CollisionsHanlder = {\n    get COLLISION_CHECK_POSITION_OFFSET() {\n        return 0.001;\n    },\n    aabb: {\n        start: new Vector3(0, 0, 0),\n        delta: new Vector3(0, 0, 0),\n        results: new CollisionResult(),\n        line: new Line(),\n        plane: new Plane(),\n        dimensions: new Vector3(0, 0, 0),\n    },\n    /** # sweepAABBN\n     * Calculates the collision for physics node against a bounding box.\n     * @param physicsNodePosition\n     * @param boundingBox\n     * @param collisionNode\n     * @param velocity Delata aka velocity of the physics object\n     * @returns\n     */\n    sweepAABBN(physicsNodePosition, boundingBox, collisionNode, velocity) {\n        let mx, my, mz, mhx, mhy, mhz;\n        mx = collisionNode.position.x - (physicsNodePosition.x + boundingBox.width);\n        my =\n            collisionNode.position.y - (physicsNodePosition.y + boundingBox.height);\n        mz = collisionNode.position.z - (physicsNodePosition.z + boundingBox.depth);\n        mhx = boundingBox.width + collisionNode.boundingBox.width;\n        mhy = boundingBox.height + collisionNode.boundingBox.height;\n        mhz = boundingBox.depth + collisionNode.boundingBox.depth;\n        collisionNode.results.reset();\n        let hitDepth;\n        const data = collisionNode.results.raw;\n        this.aabb.line.update(Vector3.Zero, velocity);\n        hitDepth = this.aabb.plane\n            .update(this.aabb.dimensions.set(mx, my, mz), Vector3.West)\n            .lineToPlane(this.aabb.line);\n        // X min\n        if (hitDepth >= 0 &&\n            velocity.x > 0 &&\n            hitDepth < data.hitDepth &&\n            Scalar.Between(hitDepth * velocity.y, my, my + mhy) &&\n            Scalar.Between(hitDepth * velocity.z, mz, mz + mhz)) {\n            collisionNode.results.update(hitDepth, -1, 0, 0);\n        }\n        hitDepth = this.aabb.plane\n            .update(this.aabb.dimensions.set(mx + mhx, my, mz), Vector3.East)\n            .lineToPlane(this.aabb.line);\n        // X max\n        if (hitDepth >= 0 &&\n            velocity.x < 0 &&\n            hitDepth < data.hitDepth &&\n            Scalar.Between(hitDepth * velocity.y, my, my + mhy) &&\n            Scalar.Between(hitDepth * velocity.z, mz, mz + mhz)) {\n            collisionNode.results.update(hitDepth, 1, 0, 0);\n        }\n        // Y min\n        hitDepth = this.aabb.plane\n            .update(this.aabb.dimensions.set(mx, my, mz), Vector3.Bottom)\n            .lineToPlane(this.aabb.line);\n        if (hitDepth >= 0 &&\n            velocity.y > 0 &&\n            hitDepth < data.hitDepth &&\n            Scalar.Between(hitDepth * velocity.x, mx, mx + mhx) &&\n            Scalar.Between(hitDepth * velocity.z, mz, mz + mhz)) {\n            collisionNode.results.update(hitDepth, 0, -1, 0);\n        }\n        // Y max\n        hitDepth = this.aabb.plane\n            .update(this.aabb.dimensions.set(mx, my + +mhy, mz), Vector3.Top)\n            .lineToPlane(this.aabb.line);\n        if (hitDepth >= 0 &&\n            velocity.y < 0 &&\n            hitDepth < data.hitDepth &&\n            Scalar.Between(hitDepth * velocity.x, mx, mx + mhx) &&\n            Scalar.Between(hitDepth * velocity.z, mz, mz + mhz)) {\n            collisionNode.results.update(hitDepth, 0, 1, 0);\n        }\n        // Z min\n        hitDepth = this.aabb.plane\n            .update(this.aabb.dimensions.set(mx, my, mz), Vector3.South)\n            .lineToPlane(this.aabb.line);\n        if (hitDepth >= 0 &&\n            velocity.z > 0 &&\n            hitDepth < data.hitDepth &&\n            Scalar.Between(hitDepth * velocity.x, mx, mx + mhx) &&\n            Scalar.Between(hitDepth * velocity.y, my, my + mhy)) {\n            collisionNode.results.update(hitDepth, 0, 0, -1);\n        }\n        // Z max\n        hitDepth = this.aabb.plane\n            .update(this.aabb.dimensions.set(mx, my, mz + mhz), Vector3.South)\n            .lineToPlane(this.aabb.line);\n        if (hitDepth >= 0 &&\n            velocity.z < 0 &&\n            hitDepth < data.hitDepth &&\n            Scalar.Between(hitDepth * velocity.x, mx, mx + mhx) &&\n            Scalar.Between(hitDepth * velocity.y, my, my + mhy)) {\n            collisionNode.results.update(hitDepth, 0, 0, 1);\n        }\n        //  node.results.update(h, nx, ny, nz);\n        return collisionNode.results.raw;\n    },\n    between(x, a, b) {\n        return x >= a && x <= b;\n    },\n    processSwpetAABB(node) {\n        if (Number.isNaN(node.position.x)) {\n            node.position.x = 0;\n        }\n        if (Number.isNaN(node.position.y)) {\n            node.position.y = 0;\n        }\n        if (Number.isNaN(node.position.z)) {\n            node.position.z = 0;\n        }\n        node.__previousPosiiton.updateFromVec3(node.position);\n        node.applyForces();\n        //Notice there is a cycle. We may have to run the algorithm several times until the collision is resolved\n        while (true) {\n            // First we calculate the movement vector for this frame\n            // This is the entity's current position minus its last position.\n            // The last position is set at the beggining of each frame.\n            this.aabb.delta.x = node.position.x - node.__previousPosiiton.x;\n            this.aabb.delta.y = node.position.y - node.__previousPosiiton.y;\n            this.aabb.delta.z = node.position.z - node.__previousPosiiton.z;\n            node.__delta.updateFromVec3(node.position);\n            // These are the bounds of the AABB that may collide with the entity.\n            const minX = Math.floor(Math.min(node.position.x, node.__previousPosiiton.x) -\n                node.boundingBox.halfWidth);\n            const maxX = Math.floor(Math.max(node.position.x, node.__previousPosiiton.x) +\n                node.boundingBox.halfWidth);\n            const minY = Math.floor(Math.min(node.position.y, node.__previousPosiiton.y) -\n                node.boundingBox.halfHeight);\n            const maxY = Math.floor(Math.max(node.position.y, node.__previousPosiiton.y) +\n                node.boundingBox.halfHeight);\n            const minZ = Math.floor(Math.min(node.position.z, node.__previousPosiiton.z) -\n                node.boundingBox.halfDepth);\n            const maxZ = Math.floor(Math.max(node.position.z, node.__previousPosiiton.z) +\n                node.boundingBox.halfDepth);\n            this.aabb.results.reset();\n            let collisionResults = this.aabb.results.raw;\n            // For each voxel that may collide with the entity, find the first that colides with it\n            for (let y = minY; y <= maxY; y++) {\n                for (let z = minZ; z <= maxZ; z++) {\n                    for (let x = minX; x <= maxX; x++) {\n                        if (!node.dataTool.loadInAt(x, y, z))\n                            continue;\n                        const collider = node.dataTool.getColliderObj();\n                        if (!collider)\n                            continue;\n                        const nodes = collider.getNodes(node.dataTool);\n                        const collidersLength = nodes.length;\n                        for (let i = 0; i < collidersLength; i++) {\n                            const colliderNode = nodes[i];\n                            // Check swept collision\n                            this.aabb.start.x =\n                                node.__previousPosiiton.x - node.boundingBox.halfWidth;\n                            this.aabb.start.y =\n                                node.__previousPosiiton.y - node.boundingBox.halfHeight;\n                            this.aabb.start.z =\n                                node.__previousPosiiton.z - node.boundingBox.halfDepth;\n                            const collisionCheck = this.sweepAABBN(this.aabb.start, node.boundingBox, colliderNode, this.aabb.delta);\n                            if (collisionCheck.hitDepth < 1) {\n                                node.doCollision(collider, colliderNode, node.dataTool);\n                            }\n                            //If the voxel will not stop the entity continue\n                            if (!node.dataTool.isSolid() || !collider.isSolid)\n                                continue;\n                            //Check if this collision is closer than the closest so far.\n                            if (collisionCheck.hitDepth < collisionResults.hitDepth) {\n                                this.aabb.results.loadIn(colliderNode.results);\n                            }\n                        }\n                    }\n                }\n            }\n            // Update the entity's position\n            // We move the entity slightly away from the block in order to miss seams.\n            node.position.x =\n                node.__previousPosiiton.x +\n                    collisionResults.hitDepth * this.aabb.delta.x +\n                    this.COLLISION_CHECK_POSITION_OFFSET * collisionResults.nx;\n            node.position.y =\n                node.__previousPosiiton.y +\n                    collisionResults.hitDepth * this.aabb.delta.y +\n                    this.COLLISION_CHECK_POSITION_OFFSET * collisionResults.ny;\n            node.position.z =\n                node.__previousPosiiton.z +\n                    collisionResults.hitDepth * this.aabb.delta.z +\n                    this.COLLISION_CHECK_POSITION_OFFSET * collisionResults.nz;\n            // If there was no collision, end the algorithm.\n            if (collisionResults.hitDepth == 1)\n                break;\n            // Wall Sliding\n            // c = a - (a.b)/(b.b) b\n            // c - slide vector (rejection of a over b)\n            // b - normal to the block\n            // a - remaining speed (= (1-h)*speed)\n            const BdotB = collisionResults.nx * collisionResults.nx +\n                collisionResults.ny * collisionResults.ny +\n                collisionResults.nz * collisionResults.nz;\n            if (BdotB != 0) {\n                // Store the current position for the next iteration\n                node.__previousPosiiton.updateFromVec3(node.position);\n                // Apply Slide\n                const AdotB = (1 - collisionResults.hitDepth) *\n                    (this.aabb.delta.x * collisionResults.nx +\n                        this.aabb.delta.y * collisionResults.ny +\n                        this.aabb.delta.z * collisionResults.nz);\n                node.position.x +=\n                    (1 - collisionResults.hitDepth) * this.aabb.delta.x -\n                        (AdotB / BdotB) * collisionResults.nx;\n                node.position.y +=\n                    (1 - collisionResults.hitDepth) * this.aabb.delta.y -\n                        (AdotB / BdotB) * collisionResults.ny;\n                node.position.z +=\n                    (1 - collisionResults.hitDepth) * this.aabb.delta.z -\n                        (AdotB / BdotB) * collisionResults.nz;\n            }\n            node.delta.set(node.position.x - node.__delta.x, node.position.y - node.__delta.y, node.position.z - node.__delta.z);\n        }\n    },\n};\n","export const DVPFlags = {\n    climbable: \"#dve_climbable\"\n};\n","//objects\nimport { VoxelMath } from \"divine-voxel-engine/Math/index.js\";\nimport { CollisionsHanlder } from \"./Collisions/CollisionsHandler.js\";\nimport { ColliderManager } from \"./Colliders/ColliderManager.js\";\n//functions\nimport { RegisterDefaultColliders } from \"./Colliders/Functions/RegisterDefaultColliders.js\";\nimport { PhysicsDataTool } from \"./Tools/Data/PhysicsDataTool.js\";\nimport { DVPFlags } from \"./Constants/Flags.js\";\nexport const DVP = {\n    math: VoxelMath,\n    collisions: CollisionsHanlder,\n    colliders: ColliderManager,\n    constants: {\n        flags: DVPFlags,\n    },\n    getDataTool() {\n        return new PhysicsDataTool();\n    },\n};\nRegisterDefaultColliders(DVP.colliders);\n","import { PhysicsNode } from \"../Nodes/PhysicsNodes.js\";\nimport { CollisionsHanlder } from \"../Collisions/CollisionsHandler.js\";\nexport class EntityBase {\n    active = true;\n    node = new PhysicsNode();\n    update() {\n        if (!this.active)\n            return;\n        this.beforeUpdate();\n        CollisionsHanlder.processSwpetAABB(this.node);\n        this.afterUpdate();\n    }\n}\n","class ValueEaseAndTween {\n    data;\n    //https://spicyyoghurt.com/tools/easing-functions\n    static EaseInQuad = (time, start, change, duration) => change * (time /= duration) * time + start;\n    static EaseLinear = (time, start, change, duration) => (change * time) / duration + start;\n    static EaseOutQuad = (time, start, change, duration) => -change * (time /= duration) * (time - 2) + start;\n    static EaseInOutQuad = (time, start, change, duration) => (time /= duration / 2) < 1\n        ? (change / 2) * time * time + start\n        : (-change / 2) * (--time * (time - 2) - 1) + start;\n    static EaseInSine = (time, start, change, duration) => -change * Math.cos((time / duration) * (Math.PI / 2)) + change + start;\n    static EaseOutSine = (time, start, change, duration) => change * Math.sin((time / duration) * (Math.PI / 2)) + start;\n    static EaseInOutSine = (time, start, change, duration) => (-change / 2) * (Math.cos((Math.PI * time) / duration) - 1) + start;\n    static EaseInExpo = (time, start, change, duration) => time == 0\n        ? start\n        : change * Math.pow(2, 10 * (time / duration - 1)) + start;\n    static EaseOutExpo = (time, start, change, duration) => time == duration\n        ? start + change\n        : change * (-Math.pow(2, (-10 * time) / duration) + 1) + start;\n    static EaseInOutExpo = (time, start, change, duration) => {\n        if (time == 0)\n            return start;\n        if (time == duration)\n            return start + change;\n        if ((time /= duration / 2) < 1)\n            return (change / 2) * Math.pow(2, 10 * (time - 1)) + start;\n        return (change / 2) * (-Math.pow(2, -10 * --time) + 2) + start;\n    };\n    static EaseInCirc = (time, start, change, duration) => -change * (Math.sqrt(1 - (time /= duration) * time) - 1) + start;\n    static EaseOutCirc = (time, start, change, duration) => change * Math.sqrt(1 - (time = time / duration - 1) * time) + start;\n    static EaseInOutCirc = (time, start, change, duration) => (time /= duration / 2) < 1\n        ? (-change / 2) * (Math.sqrt(1 - time * time) - 1) + start\n        : (change / 2) * (Math.sqrt(1 - (time -= 2) * time) + 1) + start;\n    static EaseInCubic = (time, start, change, duration) => change * (time /= duration) * time * time + start;\n    static EaseOutCubic = (time, start, change, duration) => change * ((time = time / duration - 1) * time * time + 1) + start;\n    static EaseInOutCubic = (time, start, change, duration) => (time /= duration / 2) < 1\n        ? (change / 2) * time * time * time + start\n        : (change / 2) * ((time -= 2) * time * time + 2) + start;\n    static EaseInQuart = (time, start, change, duration) => change * (time /= duration) * time * time * time + start;\n    static EaseOutQuart = (time, start, change, duration) => -change * ((time = time / duration - 1) * time * time * time - 1) + start;\n    static EaseInOutQuart = (time, start, change, duration) => (time /= duration / 2) < 1\n        ? (change / 2) * time * time * time * time + start\n        : (-change / 2) * ((time -= 2) * time * time * time - 2) + start;\n    static EaseInQuint = (time, start, change, duration) => change * (time /= duration) * time * time * time * time + start;\n    static EaseOutQuint = (time, start, change, duration) => change * ((time = time / duration - 1) * time * time * time * time + 1) +\n        start;\n    static EaseInOutQuint = (time, start, change, duration) => (time /= duration / 2) < 1\n        ? (change / 2) * time * time * time * time * time + start\n        : (change / 2) * ((time -= 2) * time * time * time * time + 2) + start;\n    static EaseInElastic = (time, start, change, duration) => {\n        let s = 1.70158;\n        let p = 0;\n        let a = change;\n        if (time == 0)\n            return start;\n        if ((time /= duration) == 1)\n            return start + change;\n        if (!p)\n            p = duration * 0.3;\n        if (a < Math.abs(change)) {\n            a = change;\n            s = p / 4;\n        }\n        else\n            s = (p / (2 * Math.PI)) * Math.asin(change / a);\n        return (-(a *\n            Math.pow(2, 10 * (time -= 1)) *\n            Math.sin(((time * duration - s) * (2 * Math.PI)) / p)) + start);\n    };\n    static EaseOutElastic = (time, start, change, duration) => {\n        let s = 1.70158;\n        let p = 0;\n        let a = change;\n        if (time == 0)\n            return start;\n        if ((time /= duration) == 1)\n            return start + change;\n        if (!p)\n            p = duration * 0.3;\n        if (a < Math.abs(change)) {\n            a = change;\n            s = p / 4;\n        }\n        else\n            s = (p / (2 * Math.PI)) * Math.asin(change / a);\n        return (a *\n            Math.pow(2, -10 * time) *\n            Math.sin(((time * duration - s) * (2 * Math.PI)) / p) +\n            change +\n            start);\n    };\n    static EaseInOutElastic = (time, start, change, duration) => {\n        let s = 1.70158;\n        let p = 0;\n        let a = change;\n        if (time == 0)\n            return start;\n        if ((time /= duration / 2) == 2)\n            return start + change;\n        if (!p)\n            p = duration * (0.3 * 1.5);\n        if (a < Math.abs(change)) {\n            a = change;\n            s = p / 4;\n        }\n        else\n            s = (p / (2 * Math.PI)) * Math.asin(change / a);\n        if (time < 1)\n            return (-0.5 *\n                (a *\n                    Math.pow(2, 10 * (time -= 1)) *\n                    Math.sin(((time * duration - s) * (2 * Math.PI)) / p)) +\n                start);\n        return (a *\n            Math.pow(2, -10 * (time -= 1)) *\n            Math.sin(((time * duration - s) * (2 * Math.PI)) / p) *\n            0.5 +\n            change +\n            start);\n    };\n    static s = 1.70158;\n    static EaseInBack = (time, start, change, duration) => change *\n        (time /= duration) *\n        time *\n        ((ValueEaseAndTween.s + 1) * time - ValueEaseAndTween.s) +\n        start;\n    static EaseOutBack = (time, start, change, duration) => change *\n        ((time = time / duration - 1) *\n            time *\n            ((ValueEaseAndTween.s + 1) * time + ValueEaseAndTween.s) +\n            1) +\n        start;\n    static EaseInOutBack = (time, start, change, duration) => (time /= duration / 2) < 1\n        ? (change / 2) *\n            (time *\n                time *\n                (((ValueEaseAndTween.s *= 1.525) + 1) * time -\n                    ValueEaseAndTween.s)) +\n            start\n        : (change / 2) *\n            ((time -= 2) *\n                time *\n                (((ValueEaseAndTween.s *= 1.525) + 1) * time +\n                    ValueEaseAndTween.s) +\n                2) +\n            start;\n    _count = 0;\n    _alive = true;\n    _start = 0;\n    _change = 0;\n    _func;\n    constructor(data) {\n        this.data = data;\n        this._start = data.start;\n        this._change = data.end - data.start;\n        this._func = this.data.function;\n        console.log(this._func);\n    }\n    update() {\n        if (!this._alive)\n            return;\n        if (this._count >= this.data.max) {\n            this._count = 0;\n            this.data.onDone();\n            return;\n        }\n        this._count++;\n        this.data.onUpdate(this._func(this._count, this._start, this._change, this.data.max));\n    }\n    setAlive(value) {\n        this._alive = value;\n        this._count = 0;\n    }\n    isAlive() {\n        return this._alive;\n    }\n    getInterval(n) {\n        return n / this.data.max;\n    }\n}\nexport { ValueEaseAndTween };\n","import { Vector3 } from \"divine-voxel-engine/Math/Classes/Vector3.js\";\nimport { PhysicsDataTool } from \"../Tools/Data/PhysicsDataTool.js\";\nimport { BoundingBox } from \"../Classes/BoundingBox.js\";\nimport { PhysicsProbe } from \"../Tools/Data/PhysicsProbe.js\";\n/**# Physics Node\n * Holds the most basic information for a physics based object.\n *\n */\nexport class PhysicsNode {\n    __previousPosiiton = new Vector3(0, 0, 0);\n    __delta = new Vector3(0, 0, 0);\n    acceleration = new Vector3(1, 1, 1);\n    velocity = new Vector3(0, 0, 0);\n    position = new Vector3(0, 0, 0);\n    direction = new Vector3(0, 0, 0);\n    delta = new Vector3(0, 0, 0);\n    boundingBox = new BoundingBox();\n    probe = new PhysicsProbe();\n    dataTool = new PhysicsDataTool();\n    doCollision;\n    setCollisionHanlder(handler) {\n        this.doCollision = handler;\n    }\n    setLocation(location) {\n        this.dataTool.setLocation(location);\n        this.position.x = location[1];\n        this.position.y = location[2];\n        this.position.z = location[3];\n    }\n    setPosition(x, y, z) {\n        this.position.set(x, y, z);\n    }\n    syncPosition(position) {\n        position.x = this.position.x;\n        position.y = this.position.y;\n        position.z = this.position.z;\n    }\n    applyForces() {\n        this.position.x = this.position.x + this.acceleration.x * this.velocity.x;\n        this.position.y = this.position.y + this.acceleration.y * this.velocity.y;\n        this.position.z = this.position.z + this.acceleration.z * this.velocity.z;\n    }\n    calculateFinalDirection(forwardDirection, sideDirection) {\n        //reset direction\n        this.direction.scaleXYZ(0);\n        //get forward direction from where the player is looking\n        forwardDirection.normalize();\n        //get side direction from where the player is looking\n        sideDirection.normalize();\n        //apply any changes on the direction vector based on player's state\n        //finally add, nomalize, then scale\n        this.direction.addFromVec3(forwardDirection);\n        this.direction.addFromVec3(sideDirection);\n        if (!this.direction.isZero()) {\n            this.direction.normalize();\n        }\n    }\n}\n","import { DVP } from \"../../DivineVoxelPhysics.js\";\nimport { DataTool } from \"divine-voxel-engine/Tools/Data/DataTool.js\";\nexport class PhysicsDataTool extends DataTool {\n    getColliderObj() {\n        if (!this.checkCollisions())\n            return false;\n        let collider = this.getCollider();\n        return DVP.colliders.getCollider(collider != \"none\" ? collider : \"Box\");\n    }\n    isSolid() {\n        return !this.isAir() && this.getSubstance() != \"#dve_liquid\";\n    }\n}\n","import { Vector3 } from \"divine-voxel-engine/Math/Classes/Vector3.js\";\nexport class PhysicsProbe {\n    voxels = {\n        _position: new Vector3(0, 0, 0),\n        *queryWithNode(node) {\n            this._position.updateFromVec3(node.position);\n            node.boundingBox.setPosition(node.position);\n            for (const [x, y, z] of node.boundingBox.query()) {\n                if (!node.dataTool.loadInAt(x, y, z))\n                    continue;\n                if (node.dataTool.isAir())\n                    continue;\n                const collider = node.dataTool.getColliderObj();\n                if (!collider)\n                    continue;\n                const nodes = collider.getNodes(node.dataTool);\n                for (const colliderNode of nodes) {\n                    colliderNode.boundingBox.setPosition(this._position.set(x, y, z));\n                    if (node.boundingBox.doesIntersect(colliderNode.boundingBox)) {\n                        yield [x, y, z];\n                        break;\n                    }\n                }\n            }\n        },\n        *queryWithNodeAtPosition(position, node) {\n            this._position.updateFromVec3(position);\n            node.boundingBox.setPosition(position);\n            for (const [x, y, z] of node.boundingBox.query()) {\n                if (!node.dataTool.loadInAt(x, y, z))\n                    continue;\n                if (node.dataTool.isAir())\n                    continue;\n                const collider = node.dataTool.getColliderObj();\n                if (!collider)\n                    continue;\n                const nodes = collider.getNodes(node.dataTool);\n                for (const colliderNode of nodes) {\n                    colliderNode.boundingBox.setPosition(this._position.set(x, y, z));\n                    if (node.boundingBox.doesIntersect(colliderNode.boundingBox)) {\n                        yield [x, y, z];\n                        break;\n                    }\n                }\n            }\n        },\n    };\n}\n","export * from \"./DivineVoxelPhysics.js\";\nexport * from \"./Entities/EntityBase.js\";\n","import { PlayerManager } from \"../Data/PlayerManager.js\";\nimport { PlayerPhysicsData } from \"../Data/PlayerPhysicsData.js\";\nimport { PlayerStatsData } from \"../Data/PlayerStatsData.js\";\nimport { $RegisterPlayerData } from \"../Data/RegisterPlayerData.js\";\nimport { NexusPlayer } from \"./NexusPlayer.js\";\nasync function SetUpPlayerData(DVEN) {\n    const { playerPhysicsTagManager, playerStatesTagManger } = $RegisterPlayerData();\n    const physicsRemoteData = playerPhysicsTagManager.initData;\n    const playePhysicsrDataSAB = new SharedArrayBuffer(physicsRemoteData.bufferSize);\n    playerPhysicsTagManager.setBuffer(playePhysicsrDataSAB);\n    PlayerManager.physics = new PlayerPhysicsData(playePhysicsrDataSAB, physicsRemoteData);\n    const statsRemoteData = playerStatesTagManger.initData;\n    const playeStatsDataSAB = new SharedArrayBuffer(physicsRemoteData.bufferSize);\n    playerPhysicsTagManager.setBuffer(playePhysicsrDataSAB);\n    PlayerManager.stats = new PlayerStatsData(playeStatsDataSAB, statsRemoteData);\n    await DVEN.parentComm.waitTillTasksExist(\"connect-player-tags\");\n    DVEN.parentComm.runTasks(\"connect-player-tags\", [\n        playePhysicsrDataSAB,\n        physicsRemoteData,\n        playeStatsDataSAB,\n        statsRemoteData,\n    ]);\n    await DVEN.worldComm.waitTillTasksExist(\"connect-player-tags\");\n    DVEN.worldComm.runTasks(\"connect-player-tags\", [\n        playePhysicsrDataSAB,\n        physicsRemoteData,\n        playeStatsDataSAB,\n        statsRemoteData,\n    ]);\n}\nexport const INIT_NEXUS_PLAYER = async (DVEN) => {\n    await SetUpPlayerData(DVEN);\n    const player = new NexusPlayer(PlayerManager.physics, PlayerManager.stats);\n    return player;\n};\n","import { EntityBase } from \"dve-plugins-physics/Entities/EntityBase.js\";\nimport { Vector3 } from \"divine-voxel-engine/Math/index.js\";\nimport { PlayerPhysicsStatesValues, } from \"../Data/PlayerPhysicsData.js\";\nimport { ValueEaseAndTween } from \"dve-plugins-physics/Math/EaseAndTween.js\";\nimport { DVP } from \"dve-plugins-physics\";\nconsole.log(ValueEaseAndTween);\nexport class NexusPlayer extends EntityBase {\n    physics;\n    stats;\n    states = {\n        cilmbingStair: false,\n        inWater: false,\n        onLadder: false,\n        gravity: -0.1,\n        jumping: false,\n        canJump: true,\n        jumpVelocity: 0.15,\n        onGround: false,\n        climbing: false,\n    };\n    get position() {\n        return this.node.position;\n    }\n    materialStandingOn = \"none\";\n    sideDirection = new Vector3(0, 0, 0);\n    forwardDirection = new Vector3(0, 0, 0);\n    speed = 0.04;\n    runSpeed = 0.03;\n    tweens = {\n        jump: new ValueEaseAndTween({\n            start: 0,\n            end: 1,\n            max: 20,\n            function: ValueEaseAndTween.EaseInQuad,\n            onUpdate: (percent) => {\n                this.node.acceleration.y = 1 - percent;\n            },\n            onDone: () => {\n                this.node.acceleration.y = 0;\n                this.states.jumping = false;\n            },\n        }),\n        fall: new ValueEaseAndTween({\n            start: 0,\n            end: 1.5,\n            max: 20,\n            function: ValueEaseAndTween.EaseInQuad,\n            onUpdate: (percent) => {\n                this.node.acceleration.y = percent;\n            },\n            onDone: () => {\n                this.node.acceleration.y = 1.5;\n                this.tweens.fall.setAlive(false);\n            },\n        }),\n        walk: new ValueEaseAndTween({\n            start: 0,\n            end: 1,\n            max: 20,\n            function: ValueEaseAndTween.EaseOutQuad,\n            onUpdate: (percent) => {\n                this.node.acceleration.x = percent;\n                this.node.acceleration.z = percent;\n            },\n            onDone: () => {\n                this.node.acceleration.x = 1;\n                this.node.acceleration.z = 1;\n                this.tweens.walk.setAlive(false);\n            },\n        }),\n        stop: new ValueEaseAndTween({\n            start: 0,\n            end: 1,\n            max: 20,\n            function: ValueEaseAndTween.EaseOutQuad,\n            onUpdate: (percent) => {\n                this.node.acceleration.x = 1 - percent;\n                this.node.acceleration.z = 1 - percent;\n            },\n            onDone: () => {\n                this.node.acceleration.x = 0;\n                this.node.acceleration.z = 0;\n                this.tweens.stop.setAlive(false);\n            },\n        }),\n    };\n    constructor(physics, stats) {\n        super();\n        this.physics = physics;\n        this.stats = stats;\n        this.node.boundingBox.update(0.8, 1, 0.8);\n        this.node.setCollisionHanlder((collider, collisionNode, dataTool) => {\n            if (collisionNode.results.faceHit.top() && collider.isSolid) {\n                this.states.onGround = true;\n                this.materialStandingOn = dataTool.getMaterial();\n            }\n            if ((collider.id == \"stair-bottom\" || collider.id == \"stair-top\") &&\n                collisionNode.results.collided()) {\n                if (collisionNode.faceHit.north()) {\n                    this.states.cilmbingStair = true;\n                    return;\n                }\n                if (collisionNode.faceHit.top()) {\n                    this.states.cilmbingStair = false;\n                    return;\n                }\n            }\n            this.states.cilmbingStair = false;\n        });\n    }\n    _lastVelocity = new Vector3(0, 0, 0);\n    controlsUpdate() {\n        this.forwardDirection.set(this.physics.direction.x, 0, this.physics.direction.z);\n        this.sideDirection.set(this.physics.sideDirection.x, 0, this.physics.sideDirection.z);\n        if (this.physics.states.movement == PlayerPhysicsStatesValues.walkingBackward) {\n            this.forwardDirection.scaleXYZ(-1);\n        }\n        if (this.physics.states.movement == PlayerPhysicsStatesValues.still) {\n            this.forwardDirection.scaleXYZ(0);\n        }\n        if (this.physics.states.secondaryMovement ==\n            PlayerPhysicsStatesValues.walkingRight) {\n            this.sideDirection.scaleXYZ(-1);\n        }\n        if (this.physics.states.secondaryMovement ==\n            PlayerPhysicsStatesValues.secondaryStill) {\n            this.sideDirection.scaleXYZ(0);\n        }\n        this.node.calculateFinalDirection(this.forwardDirection, this.sideDirection);\n        this.node.velocity.set(this.node.direction.x * this.getSpeed(), this.node.velocity.y, this.node.direction.z * this.getSpeed());\n        //set the player's velcoity based on their state\n        if (this.physics.states.movement != PlayerPhysicsStatesValues.still ||\n            this.physics.states.secondaryMovement !=\n                PlayerPhysicsStatesValues.secondaryStill) {\n            this._lastVelocity.updateFromVec3(this.node.velocity);\n            this.tweens.stop.data.max = this.physics.states.running ? 50 : 20;\n            this.tweens.stop.setAlive(true);\n            this.tweens.walk.update();\n        }\n        if (this.physics.states.movement == PlayerPhysicsStatesValues.still &&\n            this.physics.states.secondaryMovement ==\n                PlayerPhysicsStatesValues.secondaryStill) {\n            this.tweens.walk.setAlive(true);\n            this.tweens.stop.update();\n            if (!this.tweens.stop.isAlive()) {\n                this.node.velocity.x = 0;\n                this.node.velocity.z = 0;\n            }\n            else {\n                this.node.velocity.set(this._lastVelocity.x, this.node.velocity.y, this._lastVelocity.z);\n            }\n        }\n        if (this.states.onGround) {\n            this.tweens.fall.setAlive(true);\n        }\n        //player jump\n        if (this.physics.states.jumping &&\n            !this.states.jumping &&\n            (this.states.onGround || this.states.inWater || this.states.climbing)) {\n            this.states.jumping = true;\n            this.node.velocity.y =\n                this.states.jumpVelocity + this.stats.jumpPower / 1000;\n            this.node.acceleration.y = 0;\n            this.physics.states.jumping = 0;\n        }\n        if (this.states.jumping) {\n            this.tweens.jump.update();\n        }\n        if ((this.states.inWater || this.states.climbing) && !this.states.jumping) {\n            this.node.acceleration.y = 1;\n            if (this.node.acceleration.y > 2)\n                this.node.acceleration.y = 2;\n            this.node.velocity.y = this.states.gravity;\n            this.node.velocity.y -= 0.0025;\n            if (this.node.velocity.y < -0.01) {\n                this.node.velocity.y = -0.01;\n            }\n        }\n        if (!this.states.onGround && !this.states.jumping && !this.states.inWater) {\n            this.tweens.fall.update();\n            this.node.velocity.y = this.states.gravity;\n            if (!this.tweens.fall.isAlive())\n                this.node.acceleration.y += 0.1;\n            if (this.node.acceleration.y > 3)\n                this.node.acceleration.y = 3;\n        }\n    }\n    getSpeed() {\n        return (this.physics.states.running * this.runSpeed +\n            //for every level of speed add a tenth of the player's base speed\n            (this.speed + this.stats.speed * this.speed * 0.1));\n    }\n    beforeUpdate() {\n        this.states.inWater = false;\n        this.states.climbing = false;\n        for (const [x, y, z] of this.node.probe.voxels.queryWithNode(this.node)) {\n            if (this.node.dataTool.loadInAt(x >> 0, y >> 0, z >> 0)) {\n                if (this.node.dataTool.getSubstance() == \"#dve_liquid\") {\n                    this.states.inWater = true;\n                }\n                const collider = this.node.dataTool.getColliderObj();\n                if (collider && collider.hasFlag(DVP.constants.flags.climbable)) {\n                    console.log(\"climb\");\n                    this.states.climbing = true;\n                }\n            }\n        }\n        this.controlsUpdate();\n        if (this.states.cilmbingStair) {\n            this.node.velocity.set(0, 1, -1.5);\n            this.node.velocity.scaleXYZ(this.getSpeed());\n        }\n        this.states.cilmbingStair = false;\n        this.states.onGround = false;\n    }\n    afterUpdate() {\n        this.node.syncPosition(this.physics.position);\n        this.physics.states.onGround =\n            this.node.velocity.y == this.states.gravity && !this.states.inWater;\n        this.physics.states.inWater = this.states.inWater;\n    }\n}\n","export * from \"./InitNexusPlayer.js\";\nexport * from \"./NexusPlayer.js\";\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"DSLIBS_divineBinaryObject_dist_index_js-DSLIBS_divineVoxelEngine_dist_Common_Threads_Contract-5324f4\",\"DSLIBS_divineVoxelEngine_dist_Math_index_js-DSLIBS_divineVoxelEngine_dist_Tools_Data_RichData-f07748\",\"DSLIBS_dvePlugIns_Player_dist_Data_PlayerManager_js-DSLIBS_dvePlugIns_Player_dist_Data_Regist-d31b5c\"], () => (__webpack_require__(\"./compiled/client/Nexus/nexus.js\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && !queue.d) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = 1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && (queue.d = 0);\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".DVE.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"compiled_client_Nexus_nexus_js\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdve_testing\"] = self[\"webpackChunkdve_testing\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\"DSLIBS_divineBinaryObject_dist_index_js-DSLIBS_divineVoxelEngine_dist_Common_Threads_Contract-5324f4\",\"DSLIBS_divineVoxelEngine_dist_Math_index_js-DSLIBS_divineVoxelEngine_dist_Tools_Data_RichData-f07748\",\"DSLIBS_dvePlugIns_Player_dist_Data_PlayerManager_js-DSLIBS_dvePlugIns_Player_dist_Data_Regist-d31b5c\"].map(__webpack_require__.e, __webpack_require__)).then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":[],"sourceRoot":""}