{"version":3,"file":"DSLIBS_divineVoxelEngine_dist_Math_index_js-DSLIBS_divineVoxelEngine_dist_Tools_Data_RichData-f07748.DVE.js","mappings":";;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpDuC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD,iCAAiC,2BAA2B;AAC5D,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD,6BAA6B,gCAAgC;AAC7D,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC,6BAA6B,gCAAgC;AAC7D,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,GAAG,EAAE,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmB;;;;;;;;;;;;;;;AC5OZ;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJO;AACP;AACA;;;;;;;;;;;;;;;;;ACF6C;AACtC;AACP;AACA;AACA,0BAA0B,0DAAU;AACpC,0BAA0B,0DAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,0BAA0B,0DAAU;AACpC,0BAA0B,0DAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;;;;;;;;;;;ACpEU;;;;;;;;;;;;;;;;;;;;ACA6C;AACZ;AACwB;AACpB;AACI;AACnD;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,4DAAQ;AACtB;AACA,mBAAmB,wDAAO;AAC1B,KAAK;AACL;AACA,mBAAmB,oDAAK;AACxB;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,mBAAmB,4EAAiB;AACpC,KAAK;AACL;AACA,mBAAmB,gEAAW;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9C+B;AACU;AACN;AACY;AACV;AACA;AACK;AACA;AACE;AACJ;AACF;;;;;;;;;;;;;;;;;;ACVc;AACZ;AAC4B;AAC7D,2BAA2B,4EAAiB;AACnD;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB,6EAAkB;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,wCAAwC;AACxC,uBAAuB,6EAAkB;AACzC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA","sources":["webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Classes/BoundingBox.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Classes/Plane.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Classes/SimpleBoundingBox.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Classes/Vector3.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Functions/Distance2d.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Functions/Distance3d.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Functions/DistnaceSort.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Functions/VisitAll.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Types/Math.types.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/VoxelMath.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/RichDataTool.js"],"sourcesContent":["export class BoundingBox {\n    topPlane;\n    bottomPlane;\n    northPlane;\n    southPlane;\n    eastPlane;\n    westPlane;\n    bounds = {\n        minX: Infinity,\n        maxX: -Infinity,\n        minZ: Infinity,\n        maxZ: -Infinity,\n        minY: Infinity,\n        maxY: -Infinity,\n    };\n    constructor(data) {\n        this.topPlane = data.topPlane;\n        this._doMinMaxCheck(this.topPlane);\n        this.bottomPlane = data.bottomPlane;\n        this._doMinMaxCheck(this.bottomPlane);\n        this.northPlane = data.northPlane;\n        this._doMinMaxCheck(this.northPlane);\n        this.southPlane = data.southPlane;\n        this._doMinMaxCheck(this.southPlane);\n        this.eastPlane = data.eastPlane;\n        this._doMinMaxCheck(this.eastPlane);\n        this.westPlane = data.westPlane;\n        this._doMinMaxCheck(this.westPlane);\n    }\n    _doMinMaxCheck(plane) {\n        if (plane.minX <= this.bounds.minX)\n            this.bounds.minX = plane.minX;\n        if (plane.maxX >= this.bounds.maxX)\n            this.bounds.maxX = plane.maxX;\n        if (plane.minY <= this.bounds.minY)\n            this.bounds.minY = plane.minY;\n        if (plane.maxY >= this.bounds.maxY)\n            this.bounds.maxY = plane.maxY;\n        if (plane.minZ <= this.bounds.minZ)\n            this.bounds.minZ = plane.minZ;\n        if (plane.maxZ >= this.bounds.maxZ)\n            this.bounds.maxZ = plane.maxZ;\n    }\n}\n","export class Plane {\n    v1;\n    v2;\n    v3;\n    v4;\n    minX = Infinity;\n    maxX = -Infinity;\n    minZ = Infinity;\n    maxZ = -Infinity;\n    minY = Infinity;\n    maxY = -Infinity;\n    constructor(data) {\n        this.v1 = data.v1;\n        this.v2 = data.v2;\n        this.v3 = data.v3;\n        this.v4 = data.v4;\n        this._minMaxCompare(this.v1, this.v2);\n        this._minMaxCompare(this.v1, this.v3);\n        this._minMaxCompare(this.v1, this.v4);\n        this._minMaxCompare(this.v2, this.v3);\n        this._minMaxCompare(this.v2, this.v4);\n        this._minMaxCompare(this.v3, this.v4);\n    }\n    _compareVales(v1, v2, axis, minProperty, maxProperty) {\n        const c1 = v1;\n        const c2 = v2;\n        if (c1[axis] < this[minProperty]) {\n            if (c1[axis] <= c2[axis]) {\n                this[minProperty] = c1[axis];\n            }\n        }\n        if (c2[axis] < this[minProperty]) {\n            if (c2[axis] <= c1[axis]) {\n                this[minProperty] = c2[axis];\n            }\n        }\n        if (c1[axis] > this[maxProperty]) {\n            if (c1[axis] >= c2[axis]) {\n                this[maxProperty] = c1[axis];\n            }\n        }\n        if (c2[axis] > this[maxProperty]) {\n            if (c2[axis] >= c1[axis]) {\n                this[maxProperty] = c2[axis];\n            }\n        }\n    }\n    _minMaxCompare(v1, v2) {\n        this._compareVales(v1, v2, \"x\", \"minX\", \"maxX\");\n        this._compareVales(v1, v2, \"y\", \"minY\", \"maxY\");\n        this._compareVales(v1, v2, \"z\", \"minZ\", \"maxZ\");\n    }\n}\n","import { Vector3 } from \"./Vector3.js\";\nexport class SimpleBoundingBox {\n    origin;\n    dimensions;\n    bounds = {\n        minX: Infinity,\n        maxX: -Infinity,\n        minZ: Infinity,\n        maxZ: -Infinity,\n        minY: Infinity,\n        maxY: -Infinity,\n    };\n    checkBounds = {\n        minX: Infinity,\n        maxX: -Infinity,\n        minZ: Infinity,\n        maxZ: -Infinity,\n        minY: Infinity,\n        maxY: -Infinity,\n    };\n    checkOrigin = new Vector3(0, 0, 0);\n    _voxelCheckMap = {};\n    _voxelCheckPoints = [];\n    _voxelBottomCheckPoints = [];\n    _voxelOriginPoints = [];\n    constructor(origin, dimensions) {\n        this.origin = origin;\n        this.dimensions = dimensions;\n        const ov = origin;\n        this.checkOrigin.set(ov.x, ov.y, ov.z);\n        this._updateBounds();\n        this._updateCheckBounds();\n    }\n    _updateBounds() {\n        const ov = this.origin;\n        this.bounds.minX = ov.x - this.dimensions.w / 2;\n        this.bounds.maxX = ov.x + this.dimensions.w / 2;\n        this.bounds.minZ = ov.z - this.dimensions.d / 2;\n        this.bounds.maxZ = ov.z + this.dimensions.d / 2;\n        this.bounds.minY = ov.y - this.dimensions.h / 2;\n        this.bounds.maxY = ov.y + this.dimensions.h / 2;\n    }\n    _updateCheckBounds() {\n        const cv = this.checkOrigin;\n        this.checkBounds.minX = cv.x - this.dimensions.w / 2;\n        this.checkBounds.maxX = cv.x + this.dimensions.w / 2;\n        this.checkBounds.minZ = cv.z - this.dimensions.d / 2;\n        this.checkBounds.maxZ = cv.z + this.dimensions.d / 2;\n        this.checkBounds.minY = cv.y - this.dimensions.h / 2;\n        this.checkBounds.maxY = cv.y + this.dimensions.h / 2;\n    }\n    updateOrigin(x, y, z) {\n        this.origin.set(x, y, z);\n        this.origin.roundVector(2);\n        this._updateBounds();\n    }\n    setOriginToCheckOrigin() {\n        const cv = this.checkOrigin;\n        this.origin.set(cv.x, cv.y, cv.z);\n        this.bounds.minX = this.checkBounds.minX;\n        this.bounds.maxX = this.checkBounds.maxX;\n        this.bounds.minZ = this.checkBounds.minZ;\n        this.bounds.maxZ = this.checkBounds.maxZ;\n        this.bounds.minY = this.checkBounds.minY;\n        this.bounds.maxY = this.checkBounds.maxY;\n    }\n    setCheckOrigin(x, y, z) {\n        this.checkOrigin.set(x, y, z);\n        this._updateCheckBounds();\n    }\n    getCurrentOriginPoints() {\n        this._voxelOriginPoints = [];\n        const mx = this.bounds.minX;\n        const my = this.bounds.minY;\n        const mz = this.bounds.minZ;\n        for (let y = my; y <= this.bounds.maxY; y++) {\n            for (let x = mx - 1; x <= this.bounds.maxX + 1; x++) {\n                for (let z = mz - 1; z <= this.bounds.maxZ + 1; z++) {\n                    const key = this._getPositionKey(x, y, z);\n                    if (!this._voxelCheckMap[key]) {\n                        this._voxelOriginPoints.push([x, y, z]);\n                        this._voxelCheckMap[key] = true;\n                    }\n                }\n            }\n        }\n        this._voxelCheckMap = {};\n        return this._voxelOriginPoints;\n    }\n    getVoxelCheckPoints() {\n        this._voxelCheckPoints = [];\n        const mx = this.checkBounds.minX;\n        const my = this.checkBounds.minY;\n        const mz = this.checkBounds.minZ;\n        for (let y = my; y <= this.checkBounds.maxY; y++) {\n            for (let x = mx; x <= this.checkBounds.maxX + 1; x++) {\n                for (let z = mz; z <= this.checkBounds.maxZ + 1; z++) {\n                    const key = this._getPositionKey(x, y, z);\n                    if (!this._voxelCheckMap[key]) {\n                        this._voxelCheckPoints.push([\n                            Math.floor(x),\n                            Math.floor(y),\n                            Math.floor(z),\n                        ]);\n                        this._voxelCheckMap[key] = true;\n                    }\n                }\n            }\n        }\n        this._voxelCheckMap = {};\n        return this._voxelCheckPoints;\n    }\n    getVoxelBottomCheckPoints() {\n        this._voxelBottomCheckPoints = [];\n        const mx = this.checkBounds.minX;\n        const my = this.checkBounds.minY;\n        const mz = this.checkBounds.minZ;\n        for (let y = my - 1; y <= my; y++) {\n            for (let x = mx; x <= this.checkBounds.maxX + 1; x++) {\n                for (let z = mz; z <= this.checkBounds.maxZ + 1; z++) {\n                    const key = this._getPositionKey(x, y, z);\n                    if (!this._voxelCheckMap[key]) {\n                        this._voxelBottomCheckPoints.push([\n                            Math.floor(x),\n                            Math.floor(y),\n                            Math.floor(z),\n                        ]);\n                        this._voxelCheckMap[key] = true;\n                    }\n                }\n            }\n        }\n        this._voxelCheckMap = {};\n        return this._voxelBottomCheckPoints;\n    }\n    _getPositionKey(x, y, z) {\n        return `${x}-${y}-${z}`;\n    }\n    isPointInsideBox(point) {\n        const box = this.bounds;\n        return (point.x >= box.minX &&\n            point.x <= box.maxX &&\n            point.y >= box.minY &&\n            point.y <= box.maxY &&\n            point.z >= box.minZ &&\n            point.z <= box.maxZ);\n    }\n    doesBoxIntersect(testBox) {\n        const box = this.bounds;\n        return (box.minX <= testBox.maxX &&\n            box.maxX >= testBox.minX &&\n            box.minY <= testBox.maxY &&\n            box.maxY >= testBox.minY &&\n            box.minZ <= testBox.maxZ &&\n            box.maxZ >= testBox.minZ);\n    }\n}\n","class V3 {\n    _data = [0, 0, 0];\n    get x() {\n        return this._data[0];\n    }\n    set x(x) {\n        this._data[0] = x;\n    }\n    get y() {\n        return this._data[1];\n    }\n    set y(y) {\n        this._data[1] = y;\n    }\n    get z() {\n        return this._data[2];\n    }\n    set z(z) {\n        this._data[2] = z;\n    }\n}\nclass Vector3 extends V3 {\n    static Zero = new Vector3(0, 0, 0);\n    static Top = new Vector3(0, 1, 0);\n    static Bottom = new Vector3(0, -1, 0);\n    static East = new Vector3(1, 0, 0);\n    static West = new Vector3(-1, 0, 0);\n    static North = new Vector3(0, 0, 1);\n    static South = new Vector3(0, 0, -1);\n    _tv3 = new V3();\n    static NaNRestore(vec3) {\n        if (Number.isNaN(vec3.x))\n            vec3.x = 0;\n        if (Number.isNaN(vec3.y))\n            vec3.y = 0;\n        if (Number.isNaN(vec3.z))\n            vec3.z = 0;\n    }\n    constructor(x = 0, y = 0, z = 0) {\n        super();\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    updateFromArray(array, startIndex = 0) {\n        this.x = array[startIndex];\n        this.y = array[startIndex + 1];\n        this.z = array[startIndex + 2];\n        return this;\n    }\n    set(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n    }\n    setAll(value) {\n        this.x = value;\n        this.y = value;\n        this.z = value;\n        return this;\n    }\n    updateFromVec3(vector) {\n        this.x = vector.x;\n        this.y = vector.y;\n        this.z = vector.z;\n        return this;\n    }\n    roundVector(deciamlPoints = 2) {\n        this.x = Number(this.x.toFixed(deciamlPoints));\n        this.y = Number(this.y.toFixed(deciamlPoints));\n        this.z = Number(this.z.toFixed(deciamlPoints));\n        return this;\n    }\n    translate(x, y, z) {\n        this.x = this.x + x;\n        this.y = this.y + y;\n        this.z = this.z + z;\n        return this;\n    }\n    getTranslated(x, y, z) {\n        this._tv3.x = this.x + x;\n        this._tv3.y = this.y + y;\n        this._tv3.z = this.z + z;\n        return this._tv3;\n    }\n    scaleXYZ(scaler) {\n        this.x = this.x * scaler;\n        this.y = this.y * scaler;\n        this.z = this.z * scaler;\n        return this;\n    }\n    scale(xScale, yScale, zScale) {\n        this.x = this.x * xScale;\n        this.y = this.y * yScale;\n        this.z = this.z * zScale;\n        return this;\n    }\n    getScaledXYZ(scaler) {\n        this._tv3.x = this.x * scaler;\n        this._tv3.y = this.y * scaler;\n        this._tv3.z = this.z * scaler;\n        return this._tv3;\n    }\n    getScaled(xScale, yScale, zScale) {\n        this._tv3.x = this.x * xScale;\n        this._tv3.y = this.y * yScale;\n        this._tv3.z = this.z * zScale;\n        return this._tv3;\n    }\n    add(x, y, z) {\n        this.x += x;\n        this.y += y;\n        this.z += z;\n        return this;\n    }\n    addXYZ(add) {\n        this.x = this.x + add;\n        this.y = this.y + add;\n        this.z = this.z + add;\n        return this;\n    }\n    addFromVec3(vector) {\n        this.x += vector.x;\n        this.y += vector.y;\n        this.z += vector.z;\n        return this;\n    }\n    isZero() {\n        return !this.x && !this.y && !this.z;\n    }\n    subtractXYZ(subtract) {\n        this.x = this.x - subtract;\n        this.y = this.y - subtract;\n        this.z = this.z - subtract;\n        return this;\n    }\n    subtractFromObj(vector) {\n        this.x = this.x - vector.x;\n        this.y = this.y - vector.y;\n        this.z = this.z - vector.z;\n        return this;\n    }\n    getAddXYZ(add) {\n        this._tv3.x = this.x + add;\n        this._tv3.y = this.y + add;\n        this._tv3.z = this.z + add;\n        return this._tv3;\n    }\n    getSubtractXYZ(subtract) {\n        this._tv3.x = this.x - subtract;\n        this._tv3.y = this.y - subtract;\n        this._tv3.z = this.z - subtract;\n        return this._tv3;\n    }\n    addVector(vector3) {\n        this.x = vector3.x + this.x;\n        this.y = vector3.y + this.y;\n        this.z = vector3.z + this.z;\n        return this;\n    }\n    getAddedVector(vector3) {\n        this._tv3.x = vector3.x + this.x;\n        this._tv3.y = vector3.y + this.y;\n        this._tv3.z = vector3.z + this.z;\n        return this._tv3;\n    }\n    subtractVector(vector3) {\n        this.x = this.x - vector3.x;\n        this.y = this.y - vector3.y;\n        this.z = this.z - vector3.z;\n        return this;\n    }\n    getSubtractedVector(vector3) {\n        this._tv3.x = this.x - vector3.x;\n        this._tv3.y = this.y - vector3.y;\n        this._tv3.z = this.z - vector3.z;\n        return this._tv3;\n    }\n    scaleVector(vector3) {\n        this.x = this.x * vector3.x;\n        this.y = this.y * vector3.y;\n        this.z = this.z * vector3.z;\n        return this;\n    }\n    getScaledVector(vector3) {\n        this._tv3.x = this.x * vector3.x;\n        this._tv3.y = this.y * vector3.y;\n        this._tv3.z = this.z * vector3.z;\n        return this._tv3;\n    }\n    getLength() {\n        return Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2);\n    }\n    divide(scalar) {\n        this.x = this.x / scalar;\n        this.y = this.y / scalar;\n        this.z = this.z / scalar;\n        Vector3.NaNRestore(this);\n        return this;\n    }\n    getDivided(scalar) {\n        this._tv3.x = this.x / scalar;\n        this._tv3.y = this.y / scalar;\n        this._tv3.z = this.z / scalar;\n        Vector3.NaNRestore(this._tv3);\n        return this._tv3;\n    }\n    normalize() {\n        return this.divide(this.getLength());\n    }\n    isEqual(vector3) {\n        if (this.x != vector3.x) {\n            return false;\n        }\n        if (this.y != vector3.y) {\n            return false;\n        }\n        if (this.z != vector3.z) {\n            return false;\n        }\n        return true;\n    }\n    isNotEqual(vector3) {\n        if (this.x != vector3.x) {\n            return true;\n        }\n        if (this.y != vector3.y) {\n            return true;\n        }\n        if (this.z != vector3.z) {\n            return true;\n        }\n        return false;\n    }\n}\nexport { Vector3 };\n","export function Distance2D(x1, x2, y1, y2) {\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n","export function Distance3D(x1, y1, z1, x2, y2, z2) {\n    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2);\n}\n","import { Distance3D } from \"./Distance3d.js\";\nexport function Vec3ArrayDistanceSort(origion, array) {\n    //filter tasks to keep them close to the player\n    return array.sort((a, b) => {\n        const aDistance = Distance3D(a[0], a[1], a[2], origion[0], origion[1], origion[2]);\n        const bDistance = Distance3D(b[0], b[1], b[2], origion[0], origion[1], origion[2]);\n        //if a is closer then b put it first\n        if (aDistance < bDistance)\n            return -1;\n        //if b is closer then a put it first\n        if (aDistance > bDistance)\n            return 1;\n        //no change\n        return 0;\n    });\n}\nexport function LocationDataDistanceSort(origion, array) {\n    //filter tasks to keep them close to the player\n    return array.sort((a, b) => {\n        const aDistance = Distance3D(a[1], a[2], a[3], origion[1], origion[2], origion[3]);\n        const bDistance = Distance3D(b[1], b[2], b[3], origion[1], origion[2], origion[3]);\n        //if a is closer then b put it first\n        if (aDistance < bDistance)\n            return -1;\n        //if b is closer then a put it first\n        if (aDistance > bDistance)\n            return 1;\n        //no change\n        return 0;\n    });\n}\n","/** # Visit All\n * ---\n * Given a starting point and an end point it will visit all voxels that are between them.\n * @param startPoint\n * @param endPoint\n * @param visitor\n * @returns an array of numbers with a stride of 3 for positions\n */\nexport const VisitAll = (startPoint, endPoint, visitor = (x, y, z) => {\n    return true;\n}) => {\n    const gx0 = startPoint.x;\n    const gy0 = startPoint.y;\n    const gz0 = startPoint.z;\n    const gx1 = endPoint.x;\n    const gy1 = endPoint.y;\n    const gz1 = endPoint.z;\n    const positons = [];\n    const gx0idx = Math.floor(gx0);\n    const gy0idx = Math.floor(gy0);\n    const gz0idx = Math.floor(gz0);\n    const gx1idx = Math.floor(gx1);\n    const gy1idx = Math.floor(gy1);\n    const gz1idx = Math.floor(gz1);\n    const sx = gx1idx > gx0idx ? 1 : gx1idx < gx0idx ? -1 : 0;\n    const sy = gy1idx > gy0idx ? 1 : gy1idx < gy0idx ? -1 : 0;\n    const sz = gz1idx > gz0idx ? 1 : gz1idx < gz0idx ? -1 : 0;\n    let gx = gx0idx;\n    let gy = gy0idx;\n    let gz = gz0idx;\n    const gxp = gx0idx + (gx1idx > gx0idx ? 1 : 0);\n    const gyp = gy0idx + (gy1idx > gy0idx ? 1 : 0);\n    const gzp = gz0idx + (gz1idx > gz0idx ? 1 : 0);\n    const vx = gx1 === gx0 ? 1 : gx1 - gx0;\n    const vy = gy1 === gy0 ? 1 : gy1 - gy0;\n    const vz = gz1 === gz0 ? 1 : gz1 - gz0;\n    const vxvy = vx * vy;\n    const vxvz = vx * vz;\n    const vyvz = vy * vz;\n    let errx = (gxp - gx0) * vyvz;\n    let erry = (gyp - gy0) * vxvz;\n    let errz = (gzp - gz0) * vxvy;\n    const derrx = sx * vyvz;\n    const derry = sy * vxvz;\n    const derrz = sz * vxvy;\n    do {\n        if (!visitor(gx, gy, gz))\n            break;\n        positons.push(gx, gy, gz);\n        if (gx === gx1idx && gy === gy1idx && gz === gz1idx)\n            break;\n        let xr = Math.abs(errx);\n        let yr = Math.abs(erry);\n        let zr = Math.abs(errz);\n        if (sx !== 0 && (sy === 0 || xr < yr) && (sz === 0 || xr < zr)) {\n            gx += sx;\n            errx += derrx;\n        }\n        else if (sy !== 0 && (sz === 0 || yr < zr)) {\n            gy += sy;\n            erry += derry;\n        }\n        else if (sz !== 0) {\n            gz += sz;\n            errz += derrz;\n        }\n    } while (true);\n    return positons;\n};\n","export {};\n","import { BoundingBox } from \"./Classes/BoundingBox.js\";\nimport { Plane } from \"./Classes/Plane.js\";\nimport { SimpleBoundingBox } from \"./Classes/SimpleBoundingBox.js\";\nimport { Vector3 } from \"./Classes/Vector3.js\";\nimport { VisitAll } from \"./Functions/VisitAll.js\";\n/**# Voxel Math\n * ---\n * Can be used in any thread that needs it.\n * Has functions for collision detection, finding voxels in a direction, and path finding.\n */\nexport const VoxelMath = {\n    visitAll: VisitAll,\n    getVector3(x, y, z) {\n        return new Vector3(x, y, z);\n    },\n    getPlane(pv1, pv2, pv3, pv4) {\n        return new Plane({\n            v1: pv1,\n            v2: pv2,\n            v3: pv3,\n            v4: pv4,\n        });\n    },\n    getSimpleBoundingBox(origin, dimensions) {\n        return new SimpleBoundingBox(origin, dimensions);\n    },\n    getBoundingBox(data) {\n        return new BoundingBox(data);\n    },\n    convertToOriginGridSpace(position) {\n        position[0] = Math.round(position[0]) + 0.5;\n        position[1] = Math.round(position[1]) + 0.5;\n        position[2] = Math.round(position[2]) + 0.5;\n        return position;\n    },\n    distance2D(x1, x2, y1, y2) {\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        return Math.sqrt(dx * dx + dy * dy);\n    },\n    distance3D(x1, y1, z1, x2, y2, z2) {\n        const a = x2 - x1;\n        const b = y2 - y1;\n        const c = z2 - z1;\n        return Math.sqrt(a * a + b * b + c * c);\n    },\n};\n","export * from \"./VoxelMath.js\";\nexport * from \"./Classes/BoundingBox.js\";\nexport * from \"./Classes/Plane.js\";\nexport * from \"./Classes/SimpleBoundingBox.js\";\nexport * from \"./Classes/Vector3.js\";\nexport * from \"./Classes/Vector3.js\";\nexport * from \"./Functions/Distance2d.js\";\nexport * from \"./Functions/Distance3d.js\";\nexport * from \"./Functions/DistnaceSort.js\";\nexport * from \"./Functions/VisitAll.js\";\nexport * from \"./Types/Math.types.js\";\n","import { DBO } from \"divine-binary-object/index.js\";\nimport { ThreadComm } from \"threadcomm\";\nimport { LocationBoundTool } from \"../Classes/LocationBoundTool.js\";\nexport class RichDataTool extends LocationBoundTool {\n    segment = \"voxels\";\n    comm;\n    _enabled = false;\n    constructor() {\n        super();\n        this.comm = ThreadComm.getComm(\"rich-world\");\n        if (!this.comm || !this.comm.isPortSet()) {\n            this._enabled = false;\n            if (this.comm) {\n                this.comm.onSetPort(() => {\n                    this._enabled = true;\n                });\n            }\n            return;\n        }\n        if (this.comm.isPortSet()) {\n            this._enabled = true;\n        }\n    }\n    isEnabled() {\n        return this._enabled;\n    }\n    setSegment(segment) {\n        this.segment = segment;\n        return this;\n    }\n    columnHasData(check) {\n        this.comm.runPromiseTasks(\"has-data\", this.location, [], (hadData) => {\n            check(hadData);\n        });\n    }\n    columnHasDataAsync() {\n        return new Promise((resolve) => {\n            this.columnHasData((hasData) => {\n                resolve(hasData);\n            });\n        });\n    }\n    getData(onDone) {\n        this.comm.runPromiseTasks(\"get-data\", [this.location, this.segment], [], (data) => {\n            if (!data)\n                return onDone(false);\n            onDone(DBO.bufferToObject(data));\n        });\n    }\n    getDataAsync() {\n        return new Promise((resolve) => {\n            this.getData((data) => {\n                resolve(data);\n            });\n        });\n    }\n    setData(data, onDone = (data) => { }) {\n        const buffer = DBO.objectToBuffer(data);\n        this.comm.runPromiseTasks(\"set-data\", [this.location, this.segment, buffer], [buffer], (success) => {\n            onDone(success);\n        });\n    }\n    setDataAsync(data) {\n        return new Promise((resolve) => {\n            this.setData(data, (updated) => {\n                resolve(updated);\n            });\n        });\n    }\n    removeData(onDone) {\n        this.comm.runPromiseTasks(\"remove-data\", [this.location, this.segment], [], (removed) => {\n            onDone(removed);\n        });\n    }\n    removeDataAsync() {\n        return new Promise((resolve) => {\n            this.removeData((removed) => {\n                resolve(removed);\n            });\n        });\n    }\n    removeColumn(onDone) {\n        this.comm.runPromiseTasks(\"remove-column\", this.location, [], (removed) => {\n            onDone(removed);\n        });\n    }\n    removeColumnAsync() {\n        return new Promise((resolve) => {\n            this.removeData((removed) => {\n                resolve(removed);\n            });\n        });\n    }\n    getColumn(onDone) {\n        this.comm.runPromiseTasks(\"get-column\", this.location, [], (data) => {\n            onDone(data);\n        });\n    }\n    getColumnAsync() {\n        return new Promise((resolve) => {\n            this.getColumn((data) => {\n                resolve(data);\n            });\n        });\n    }\n    setColumn(column, onDone) {\n        this.comm.runPromiseTasks(\"set-column\", [this.location, column], [], (success) => {\n            onDone(success);\n        });\n    }\n    setColumnAsync(column) {\n        return new Promise((resolve) => {\n            this.setColumn(column, (success) => {\n                resolve(success);\n            });\n        });\n    }\n    releaeAllData() {\n        this.comm.runTasks(\"release-all-data\", [], []);\n    }\n}\n"],"names":[],"sourceRoot":""}