{"version":3,"file":"compiled_environments_electron_client_dataloader_js.DVE.js","mappings":";;;;;;;;;;;;;;AAAO;AACP,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACP2C;AACL;AACc;AACH;AAC1C;AACP,UAAU;AACV;AACA,cAAc,sDAAe;AAC7B;AACA;AACA,qCAAqC,+DAAwB;AAC7D;AACA,uBAAuB,+DAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA,uBAAuB,4DAAqB;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAmB;AAC5C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,8BAA8B,sEAA4B;AAC1D;AACA;AACA;AACA,8DAA8D,sEAAmB;AACjF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,+DAAwB;AACtC;AACA,KAAK;AACL;AACA,8BAA8B,sEAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,+DAAc;AAChC;AACA;AACA,qBAAqB,sEAAmB;AACxC;AACA,8BAA8B,sEAA4B;AAC1D;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC3FuD;AACT;AAC2B;AAClE;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,qEAA0B;AACxC;AACA,KAAK;AACL;AACA,cAAc,qEAA0B;AACxC,4BAA4B,4EAAiC,CAAC,yGAAiC;AAC/F;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,qEAA0B;AACxC,6BAA6B,yEAA8B,CAAC,yGAAiC;AAC7F;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,qEAA0B;AACxC,6BAA6B,mEAAwB,CAAC,yGAAiC;AACvF;AACA;AACA,4BAA4B,iFAAiC;AAC7D,KAAK;AACL;AACA,iCAAiC,+EAA+B;AAChE,cAAc,qEAA0B;AACxC,cAAc,mEAAwB,CAAC,yGAAiC;AACxE,cAAc,4EAAiC,CAAC,yGAAiC;AACjF;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC3CuD;AACa;AACb;AACoB;AACV;AACjE,MAAM,uEAAW,KAAK,sEAAe;AACrC,MAAM,+DAAY;AAClB,MAAM,yEAAiB;AACvB,iFAAe,CAAC,iEAAK;;;;;;;;;;;;;;;;;;;;ACR+B;AACW;AAC6B;AAC5F;AACO,8BAA8B,sGAAW;AAChD;AACA,QAAQ,4EAAiB;AACzB;AACA,yBAAyB,8EAA2B;AACpD,qBAAqB,qFAA0B;AAC/C;AACA;AACA,QAAQ,4EAAiB;AACzB;AACA,yBAAyB,wEAAqB;AAC9C,qBAAqB,+EAAoB;AACzC;AACA;AACA,QAAQ,4EAAiB;AACzB;AACA,yBAAyB,wEAAqB;AAC9C,qBAAqB,+EAAoB;AACzC;AACA;AACA,QAAQ,4EAAiB;AACzB;AACA,mBAAmB,qEAAkB;AACrC,eAAe,4EAAiB;AAChC;AACA;AACA,QAAQ,4EAAiB;AACzB,wBAAwB,iFAAsB;AAC9C;AACA,yBAAyB,0EAAuB;AAChD,qBAAqB,iFAAsB;AAC3C;AACA;AACA,QAAQ,4EAAiB;AACzB;AACA,yBAAyB,6EAA0B;AACnD,qBAAqB,oFAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA,QAAQ,4EAAiB;AACzB,qBAAqB,iFAAsB;AAC3C;AACA;;;;;;;;;;;;;;;;ACjDuD;AAChD;AACP;AACA;AACA;AACA,iCAAiC,+EAA+B;AAChE;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B,GAAG,WAAW;AACrE;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA,uCAAuC,4FAA4C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oDAAoD,qBAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mDAAmD,qBAAqB,SAAS,MAAM;AACvF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC,iFAAiC;AACpE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC5IiE;AAC1D;AACP,UAAU,yEAAiB;AAC3B;AACA,cAAc,gFAAwB;AACtC;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACRA;AACO;AACP;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACf6D;AACtD;AACP;AACA;AACA,oBAAoB,2EAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACbA;AAC0D;AACoB;AACH;AACxB;AACe;AACF;AACZ;AACpD,2BAA2B,mFAAc;AAClC;AACP;AACA,eAAe;AACf,gBAAgB;AAChB;AACA;AACA,4BAA4B,qEAAY;AACxC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2EAAuB;AAC/C,YAAY,qFAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,oBAAoB;AAClF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mGAAkC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,oBAAoB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,oBAAoB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oBAAoB;AAC/E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,kFAAwB;AACxC;AACA;AACA;AACA,yBAAyB,qGAAoC;AAC7D;AACA,YAAY,qFAAwB;AACpC;AACA;AACA;AACA;AACA,gBAAgB,qFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oBAAoB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,GAAG;AACxD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,kFAAwB;AACxC;AACA;AACA;AACA;AACA,kEAAkE,oBAAoB;AACtF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,oBAAoB;AACrF;AACA;AACA;AACA,KAAK;AACL;AACA,iFAAiC;AACjC;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxKD;AACoE;AACpB;AACO;AACF;AACqB;AAC1E;AACuE;AACvE;AACkD;AACW;AACY;AACjC;AACqB;AACR;AAC9C;AACP;AACA,QAAQ,kDAAU;AAClB,UAAU,wDAAI;AACd,cAAc,4EAAc;AAC5B,kBAAkB,+DAAY;AAC9B,UAAU,6DAAW;AACrB,eAAe,oEAAS;AACxB,gBAAgB,qEAAU;AAC1B,WAAW,sEAAe;AAC1B,gBAAgB,mFAAkB;AAClC,iBAAiB,kFAAkB;AACnC;AACA;AACA,cAAc,+DAAU;AACxB,KAAK;AACL;AACA,mBAAmB,sEAAY;AAC/B,KAAK;AACL;AACA,mBAAmB,8DAAQ;AAC3B,KAAK;AACL;;;;;;;;;;;;;;;;;ACrC4E;AACpC;AACjC;AACP;AACA;AACA;AACA;AACA,UAAU,wDAAgB;AAC1B;AACA;AACA,mBAAmB,4FAA6B;AAChD,SAAS;AACT;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACdA;AAC8E;AACA;AACF;AACc;AACnF;AACP,iBAAiB,mFAAc;AAC/B,iBAAiB,mFAAc;AAC/B,gBAAgB,iFAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,4EAAgB;AAC/C,+BAA+B,mFAAuB;AACtD,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kFAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC9E0D;AAClB;AACgD;AACtB;AACD;AAC1D;AACP,sBAAsB,gEAAwB;AAC9C,8BAA8B,8GAAmC;AACjE;AACA,KAAK;AACL,gBAAgB,gEAAwB;AACxC,cAAc,wGAA6B;AAC3C;AACA,KAAK;AACL,gBAAgB,gEAAwB;AACxC,YAAY,kFAAwB;AACpC;AACA;AACA;AACA;AACA;AACA,cAAc,wGAA6B;AAC3C,yBAAyB,sEAAY;AACrC,gBAAgB,kFAAwB;AACxC;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,kBAAkB,gEAAwB;AAC1C,aAAa,kFAAwB;AACrC;AACA;AACA;AACA;AACA,cAAc,0GAA+B;AAC7C,QAAQ,4FAA+B;AACvC;AACA;AACA,SAAS;AACT,KAAK;AACL,aAAa,gEAAwB;AACrC,cAAc,qGAA0B;AACxC;AACA,KAAK;AACL,kBAAkB,gEAAwB;AAC1C,YAAY,kFAAwB;AACpC;AACA;AACA;AACA;AACA;AACA,6BAA6B,0GAA+B;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,gEAAwB;AAC7C,2BAA2B,6GAAkC;AAC7D;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AClEmD;AAC5C;AACP;AACA;AACA,eAAe,sEAAmB;AAClC;AACA;;;;;;;;;;;;;;;;;;;;;ACNuE;AAC/B;AAC2B;AACf;AAC7C,mBAAmB,yDAAiB;AACpC,sBAAsB,6DAAqB;AAC3C,kBAAkB,6DAAqB;AAC9C,gEAAwB;AACxB,IAAI,4FAAqC;AACzC,IAAI,yFAA2B;AAC/B,IAAI,4EAA4B;AAChC,CAAC;;;;;;;;;;;;;;;;ACXgD;;;;;;;;;;;;;;;;ACA1C;AACA;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACwC;AACiB;AACgB;AACZ;AACiB;AACvB;AACqB;AAClB;AACT;AACqB;AACQ;AACL;AACZ;AACtD;AACP;AACA,iBAAiB,6DAAqB,CAAC,mGAA6B;AACpE,YAAY,+FAAkC;AAC9C,SAAS;AACT,iBAAiB,6DAAqB,CAAC,mGAA6B;AACpE,YAAY,+FAAkC;AAC9C,SAAS;AACT,KAAK;AACL;AACA,eAAe,6DAAqB,CAAC,8FAAwB;AAC7D,YAAY,sFAAkC;AAC9C,SAAS;AACT,mBAAmB,6DAAqB,CAAC,kGAA4B;AACrE,YAAY,8FAAiC;AAC7C,SAAS;AACT,KAAK;AACL;AACA,mBAAmB,6DAAqB,CAAC,2FAAqB;AAC9D,YAAY,yGAAoC;AAChD,SAAS;AACT,eAAe,6DAAqB,CAAC,uFAAiB;AACtD,YAAY,4EAAuB;AACnC,SAAS;AACT,YAAY,+EAA0B;AACtC,SAAS;AACT,gBAAgB,6DAAqB,CAAC,wFAAkB;AACxD,YAAY,6EAAwB;AACpC,SAAS;AACT,YAAY,gFAA2B;AACvC,SAAS;AACT,gBAAgB,6DAAqB,CAAC,wFAAkB;AACxD,YAAY,6EAAwB;AACpC,SAAS;AACT,YAAY,gFAA2B;AACvC,SAAS;AACT,sBAAsB,6DAAqB,CAAC,8FAAwB;AACpE,YAAY,4FAAwB;AACpC,SAAS;AACT,YAAY,+FAA2B;AACvC,SAAS;AACT,KAAK;AACL;AACA,eAAe,6DAAqB,CAAC,2FAAqB;AAC1D,YAAY,gEAAe;AAC3B,YAAY,+DAAc;AAC1B,SAAS;AACT,mBAAmB,6DAAqB,CAAC,+FAAyB;AAClE,YAAY,6EAAmB;AAC/B,SAAS;AACT,eAAe,6DAAqB,CAAC,2FAAqB;AAC1D,YAAY,sEAAe;AAC3B,SAAS;AACT,gBAAgB,6DAAqB,CAAC,4FAAsB;AAC5D,YAAY,yEAAgB;AAC5B,SAAS;AACT,gBAAgB,6DAAqB,CAAC,4FAAsB;AAC5D,YAAY,yEAAgB;AAC5B,YAAY,+EAAsB;AAClC,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;AC3EoD;AACZ;AAC4B;AAC7D,2BAA2B,4EAAiB;AACnD;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB,6EAAkB;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,wCAAwC;AACxC,uBAAuB,6EAAkB;AACzC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxHO;AACP,gBAAgB;AAChB;AACA,kBAAkB;AAClB;AACA;AACA,mCAAmC,YAAY;AAC/C,kCAAkC,YAAY;AAC9C,kCAAkC,YAAY;AAC9C,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,IAAI,GAAG,KAAK;AAClC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,IAAI,GAAG,KAAK;AAClC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,IAAI,GAAG,KAAK;AAClC,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;ACpFsC;AACsB;AACrD;AACP;AACA,cAAc,sDAAe;AAC7B,KAAK;AACL;AACA;AACA,qCAAqC,+DAAwB;AAC7D;AACA,uBAAuB,+DAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,YAAY,iFAAyB;AACrC;AACA;AACA,uBAAuB,4DAAqB;AAC5C,YAAY,iFAAyB;AACrC;AACA,eAAe,qEAAa;AAC5B,KAAK;AACL;AACA,cAAc,+DAAwB;AACtC,KAAK;AACL;;;;;;;;;;;;;;;;;;AC9BiD;AACL;;;;;;;;;;;;;;;;;ACDA;AACJ;AACjC;AACP;AACA;AACA;AACA,qCAAqC,gCAAgC;AACrE,oBAAoB,6DAAqB,EAAE,UAAU,6DAAqB,EAAE,WAAW,8DAAsB,CAAC;AAC9G,KAAK,QAAQ;AACb,sBAAsB,yEAA8B;AACpD;AACA;AACA;;;;;;;;;;;;;;;;;ACZwC;AACI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAA+B,YAAY,kBAAkB,GAAG,GAAG;AAC3E;AACA;AACA;AACA,sBAAsB,6DAAqB;AAC3C,wBAAwB,+DAAuB;AAC/C,wBAAwB,8DAAsB;AAC9C,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6EAAkC,YAAY,kBAAkB,GAAG,QAAQ;AACnF;AACA;AACyB;;;;;;;;;;;;;;;;;;;ACxC0B;AACH;AACS;AACN;AACnD,sEAAoB;AACb;AACP,gBAAgB;AAChB;AACA,uBAAuB;AACvB,UAAU,wDAAW;AACrB;AACA,4BAA4B,2DAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B,2DAAQ;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA,6BAA6B,2DAAQ;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,aAAa,GAAG,gBAAgB;AAC7F;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4DAA4D,gDAAQ;AACpE,oCAAoC,gDAAQ;AAC5C;AACA;AACA,qBAAqB;AACrB;AACA,oCAAoC,mDAAW;AAC/C;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,oCAAoC,gDAAQ;AAC5C;AACA;AACA,qBAAqB;AACrB;AACA,oCAAoC,mDAAW;AAC/C;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;ACrIwC;AACW;AAC5C;AACP,IAAI,gEAAwB;AAC5B,mBAAmB,4EAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gEAAwB;AAC5B,mBAAmB,4EAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACrByD;AACT;AACM;AACF;AACQ;AACrD;AACP;AACA;AACA;AACA,WAAW,wDAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAY;AAClC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAmB;AAClC;AACA;AACA;AACA,sBAAsB,4DAAY;AAClC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,8BAA8B,oEAAa;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,8BAA8B,oEAAa;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAY;AAClC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+BAA+B,oEAAa;AAC5C;AACA;AACA,oBAAoB,mFAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oEAAa;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,uBAAuB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,8BAA8B,+BAA+B;AAChG;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA;AACA,sBAAsB,4DAAY;AAClC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAY;AAClC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,eAAe;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAa;AAC3C;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4DAAY;AAC1C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;AC/iBU;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;ACAmC;AACF;AACE;;;;;;;;;;;;;;;ACFtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChBwD;AACjD;AACP;AACA,UAAU,iEAAa;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACzBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACjB+B;AACQ;AACA;;;;;;;;;;;;;;;;;;;ACFF;AACK;;;;;;;;;;;;;;;ACDnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;ACxFqC;AAC9B;AACP,UAAU,8CAAM;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACZuC;;;;;;;;;;;;;;;;ACAM;;;;;;;UCA7C;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;WClCA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,aAAa;WACb;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;;;;;WCpCA;WACA;WACA;WACA;;;;;UEHA;UACA","sources":["webpack://dve-testing/./compiled/core/data/ENV/DVEENV.js","webpack://dve-testing/./compiled/databases/App/AppDataBase.js","webpack://dve-testing/./compiled/databases/World/WorldData.js","webpack://dve-testing/./compiled/environments/electron/client/dataloader.js","webpack://dve-testing/./compiled/io/client/DataHandler.js","webpack://dve-testing/./compiled/io/client/Server/DVEDServer.js","webpack://dve-testing/./compiled/io/client/Tasks/RegisterIOTasks.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/util/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/DataHandler/DataHandlerBaes.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/DataHandler/DataHandlerWrapper.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/DivineVoxelEngineDataLoader.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/Init/InitWorker.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/Serializers/WorldDataSerializer.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/Tasks/DataLoaderTasks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/Threads/DataLoaderThreadState.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/Threads/DataLoaderThreads.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/DataHeaders.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataSyncNode.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/RichDataTool.js","webpack://dve-testing/../../DSLIBS/dvePlugins/Data/dist/Broswer/DataBase/WorldDataBase.js","webpack://dve-testing/../../DSLIBS/dvePlugins/Data/dist/Broswer/DivineVoxelEngineDataClient.js","webpack://dve-testing/../../DSLIBS/dvePlugins/Data/dist/Broswer/index.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Classes/Errors.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Classes/SecureIDBWrap.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Core/ZeneithDBCore.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Core/ZeneithTasks.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Database/Database.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Meta/Database/Database.types.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Meta/Database/Schema.types.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Meta/Zeneith/Database.schema.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Meta/index.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Store/ObjectStore.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/ZeneithDB.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/ZeneithUtil.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/index.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/index.js","webpack://dve-testing/./node_modules/crystal-compressor/CrystalCompressor/CCCore.js","webpack://dve-testing/./node_modules/crystal-compressor/CrystalCompressor/CrystalCompressor.js","webpack://dve-testing/./node_modules/crystal-compressor/CrystalCompressor/index.js","webpack://dve-testing/./node_modules/crystal-compressor/index.js","webpack://dve-testing/webpack/bootstrap","webpack://dve-testing/webpack/runtime/async module","webpack://dve-testing/webpack/runtime/chunk loaded","webpack://dve-testing/webpack/runtime/define property getters","webpack://dve-testing/webpack/runtime/ensure chunk","webpack://dve-testing/webpack/runtime/get javascript chunk filename","webpack://dve-testing/webpack/runtime/global","webpack://dve-testing/webpack/runtime/hasOwnProperty shorthand","webpack://dve-testing/webpack/runtime/make namespace object","webpack://dve-testing/webpack/runtime/publicPath","webpack://dve-testing/webpack/runtime/importScripts chunk loading","webpack://dve-testing/webpack/runtime/startup chunk dependencies","webpack://dve-testing/webpack/before-startup","webpack://dve-testing/webpack/startup","webpack://dve-testing/webpack/after-startup"],"sourcesContent":["export const DVEENV = {\r\n    data: {},\r\n    async $INIT(url = \".DVE_ENV\") {\r\n        const envDataResponse = await fetch(url);\r\n        const envData = await envDataResponse.json();\r\n        this.data = envData;\r\n    },\r\n};\r\n","import { DVEDBrowser } from \"dved/Broswer\";\r\nimport { ZeneithDB } from \"zeneithdb\";\r\nimport { DVEENV } from \"../../core/data/ENV/DVEENV\";\r\nimport { StringToNumber } from \"divine-rng/util\";\r\nexport const AppDataBase = {\r\n    db: {},\r\n    async $INIT() {\r\n        await ZeneithDB.$INIT();\r\n        const dbName = \"ECD_APP\";\r\n        let db;\r\n        const existanceCheck = await ZeneithDB.databaseExists(dbName);\r\n        if (!existanceCheck) {\r\n            db = await ZeneithDB.createDatabase({\r\n                databaseName: dbName,\r\n                collections: [\r\n                    {\r\n                        name: \"meta-data\",\r\n                        schema: [],\r\n                    },\r\n                ],\r\n            });\r\n            this.db = db;\r\n        }\r\n        else {\r\n            db = await ZeneithDB.getDatabase(dbName);\r\n            this.db = db;\r\n        }\r\n        await this.db.open();\r\n    },\r\n    async inSaveRecord(id) {\r\n        const saveRecord = await this.db.getData(\"meta-data\", \"save-record\");\r\n        if (!saveRecord) {\r\n            this.db.setData(\"meta-data\", \"save-record\", {});\r\n            return false;\r\n        }\r\n        const save = saveRecord[id];\r\n        return save !== undefined;\r\n    },\r\n    async addToSaveRecord(id) {\r\n        let saveRecord = await this.db.getData(\"meta-data\", \"save-record\");\r\n        if (!saveRecord) {\r\n            saveRecord = {};\r\n        }\r\n        saveRecord[id] = DVEENV.data.version;\r\n        this.db.setData(\"meta-data\", \"save-record\", saveRecord);\r\n    },\r\n    async removeFromSaveRecord(id) {\r\n        let saveRecord = await this.db.getData(\"meta-data\", \"save-record\");\r\n        if (!saveRecord)\r\n            return false;\r\n        delete saveRecord[id];\r\n        this.db.setData(\"meta-data\", \"save-record\", saveRecord);\r\n    },\r\n    async getWorldSave(id) {\r\n        const worldDB = await DVEDBrowser.getWorldDataBase(id);\r\n        const inWorldSave = await this.inSaveRecord(id);\r\n        if (!inWorldSave) {\r\n            await this.addToSaveRecord(id);\r\n            worldDB.database.setData(\"world-meta\", \"version\", DVEENV.data.version);\r\n        }\r\n    },\r\n    async getAllSaves() {\r\n        const saveRecord = await this.db.getData(\"meta-data\", \"save-record\");\r\n        if (!saveRecord)\r\n            return {};\r\n        return saveRecord;\r\n    },\r\n    async removeWorldSave(id) {\r\n        await ZeneithDB.deleteDatabase(id);\r\n        await this.removeFromSaveRecord(id);\r\n    },\r\n    async getSavedata(id) {\r\n        const worldDB = await DVEDBrowser.getWorldDataBase(id);\r\n        await this.addToSaveRecord(id);\r\n        const data = await worldDB.database.getData(\"world-meta\", \"save-data\");\r\n        if (!data)\r\n            return false;\r\n        return data;\r\n    },\r\n    async createNewSave(title, seed) {\r\n        const saveData = {\r\n            title: title,\r\n            seed: StringToNumber(seed),\r\n            created: Date.now(),\r\n            lastPlayed: Date.now(),\r\n            version: DVEENV.data.version,\r\n        };\r\n        const worldDB = await DVEDBrowser.getWorldDataBase(title);\r\n        await this.addToSaveRecord(title);\r\n        worldDB.database.setData(\"world-meta\", \"save-data\", saveData);\r\n    },\r\n};\r\n","import { CrystalCompressor } from \"crystal-compressor\";\r\nimport { WorldDataBase } from \"dved/Broswer/\";\r\nimport { WorldSpaces } from \"divine-voxel-engine/Data/World/WorldSpaces\";\r\nexport const WorldData = {\r\n    async setPath(id) {\r\n        return true;\r\n    },\r\n    dataType: \"world-data\",\r\n    setType(data) {\r\n        this.dataType = data;\r\n    },\r\n    async columnExists(location) {\r\n        await WorldDataBase.setDimension(location[0]);\r\n        return (await this.columnTimestamp(location)) > 0;\r\n    },\r\n    async columnTimestamp(location) {\r\n        await WorldDataBase.setDimension(location[0]);\r\n        const stamp = await WorldDataBase.columnTimestamp.get(WorldSpaces.column.getKeyLocation(location), this.dataType);\r\n        if (!stamp)\r\n            return 0;\r\n        return stamp;\r\n    },\r\n    async loadRegionHeader(location) {\r\n        await WorldDataBase.setDimension(location[0]);\r\n        const buffer = await WorldDataBase.regionHeader.get(WorldSpaces.region.getKeyLocation(location), this.dataType);\r\n        if (!buffer)\r\n            return new ArrayBuffer(0);\r\n        return buffer;\r\n    },\r\n    async loadColumn(location) {\r\n        await WorldDataBase.setDimension(location[0]);\r\n        const buffer = await WorldDataBase.column.get(WorldSpaces.column.getKeyLocation(location), this.dataType);\r\n        if (!buffer)\r\n            return new ArrayBuffer(0);\r\n        return await (await CrystalCompressor.decompressArray(buffer, \"Uint8\")).buffer;\r\n    },\r\n    async saveColumn(location, buffer) {\r\n        const compressed = await CrystalCompressor.compressArray(new Uint8Array(buffer));\r\n        await WorldDataBase.setDimension(location[0]);\r\n        await WorldDataBase.column.set(WorldSpaces.column.getKeyLocation(location), this.dataType, compressed.buffer);\r\n        await WorldDataBase.columnTimestamp.set(WorldSpaces.column.getKeyLocation(location), this.dataType, Date.now());\r\n        return true;\r\n    },\r\n};\r\n","import { DVEDL } from \"divine-voxel-engine/DataLoader\";\r\nimport { DVEDDataHanlder } from \"../../../io/client/DataHandler.js\";\r\nimport { DVEENV } from \"../../../core/data/ENV/DVEENV\";\r\nimport { RegisterIOTasks } from \"../../../io/client/Tasks/RegisterIOTasks\";\r\nimport { AppDataBase } from \"../../../databases/App/AppDataBase\";\r\nawait DVEDL.$INIT(new DVEDDataHanlder());\r\nawait DVEENV.$INIT(\"../.DVE_ENV\");\r\nawait AppDataBase.$INIT();\r\nRegisterIOTasks(DVEDL);\r\n","import { DVEDServer } from \"./Server/DVEDServer.js\";\r\nimport { WorldData } from \"../../databases/World/WorldData.js\";\r\nimport { DataHandler } from \"divine-voxel-engine/DataLoader/DataHandler/DataHandlerBaes.js\";\r\nlet mode = \"indexdb\";\r\nexport class DVEDDataHanlder extends DataHandler {\r\n    async getRegionHeader(location) {\r\n        WorldData.setType(this.dataType);\r\n        if (this.mode == \"server\")\r\n            return await DVEDServer.loadRegionHeader(location);\r\n        return await WorldData.loadRegionHeader(location);\r\n    }\r\n    async getColumn(location) {\r\n        WorldData.setType(this.dataType);\r\n        if (this.mode == \"server\")\r\n            return await DVEDServer.loadColumn(location);\r\n        return await WorldData.loadColumn(location);\r\n    }\r\n    async saveColumn(location, buffer) {\r\n        WorldData.setType(this.dataType);\r\n        if (this.mode == \"server\")\r\n            return await DVEDServer.saveColumn(location, buffer);\r\n        return await WorldData.saveColumn(location, buffer);\r\n    }\r\n    async setPath(id) {\r\n        WorldData.setType(this.dataType);\r\n        if (this.mode == \"server\")\r\n            return DVEDServer.setPath(id);\r\n        return WorldData.setPath(id);\r\n    }\r\n    async columnExists(location) {\r\n        WorldData.setType(this.dataType);\r\n        const d = await WorldData.columnExists(location);\r\n        if (this.mode == \"server\")\r\n            return await DVEDServer.columnExists(location);\r\n        return await WorldData.columnExists(location);\r\n    }\r\n    async columnTimestamp(location) {\r\n        WorldData.setType(this.dataType);\r\n        if (this.mode == \"server\")\r\n            return await DVEDServer.columnTimestamp(location);\r\n        return await WorldData.columnTimestamp(location);\r\n    }\r\n    async columnHasSegment(location, segment) {\r\n        if (this.mode == \"server\") {\r\n            return false;\r\n        }\r\n        WorldData.setType(segment);\r\n        return await WorldData.columnExists(location);\r\n    }\r\n}\r\n","import { CrystalCompressor } from \"crystal-compressor\";\r\nexport const DVEDServer = {\r\n    url: `http://127.0.0.1:3000`,\r\n    async _compressToString(buffer) {\r\n        let dataString = \"\";\r\n        const compressed = await CrystalCompressor.compressArray(new Uint8Array(buffer));\r\n        let length = compressed.length;\r\n        for (let i = 0; i < length; i++) {\r\n            dataString += String.fromCharCode(compressed[i]);\r\n        }\r\n        return dataString;\r\n    },\r\n    async sendDVEDMessage(dveMessage, buffer) {\r\n        let dataString = \"\";\r\n        if (buffer) {\r\n            if (Array.isArray(buffer)) {\r\n            }\r\n            else {\r\n                dataString = await this._compressToString(buffer);\r\n            }\r\n        }\r\n        const message = `|${JSON.stringify(dveMessage)}|${dataString}`;\r\n        return fetch(this.url, {\r\n            method: \"POST\",\r\n            body: message,\r\n            headers: { \"Content-Type\": \"application/dved\" },\r\n        });\r\n    },\r\n    async setPath(id) {\r\n        const response = await this.sendDVEDMessage({\r\n            type: \"set-path\",\r\n            id: id,\r\n        });\r\n        const error = (await this._determineError(response)) != Infinity;\r\n        if (error) {\r\n            console.warn(`Problem setting path with id ${id}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    async _determineError(response) {\r\n        let error = Infinity;\r\n        if (!response)\r\n            error = -1;\r\n        const responseBuffer = await response.arrayBuffer();\r\n        if (!responseBuffer)\r\n            error = -1;\r\n        const responseCode = new Uint8Array(responseBuffer)[0];\r\n        if (responseCode !== 1)\r\n            error = responseCode;\r\n        if (error !== Infinity)\r\n            return error;\r\n        return Infinity;\r\n    },\r\n    async columnExists(location) {\r\n        const response = await this.sendDVEDMessage({\r\n            type: `column-exists`,\r\n            location: location,\r\n        });\r\n        const buffer = await response.arrayBuffer();\r\n        if (!buffer)\r\n            return false;\r\n        const data = new Uint8Array(buffer);\r\n        return data[0] == 1;\r\n    },\r\n    async columnTimestamp(location) {\r\n        const response = await this.sendDVEDMessage({\r\n            type: `column-timestamp`,\r\n            location: location,\r\n        });\r\n        const buffer = await response.arrayBuffer();\r\n        if (!buffer)\r\n            return 0;\r\n        const data = new Uint32Array(buffer);\r\n        return data[0];\r\n    },\r\n    async loadColumn(location) {\r\n        try {\r\n            const response = await this.sendDVEDMessage({\r\n                type: `load-column`,\r\n                location: location,\r\n            });\r\n            const buffer = await response.arrayBuffer();\r\n            if (buffer.byteLength == 0) {\r\n                throw new Error(`Column at ${location.toString()} could not be loaded`);\r\n            }\r\n            const uncompressed = await CrystalCompressor.core.decompressArrayBuffer(buffer);\r\n            return uncompressed.buffer;\r\n        }\r\n        catch (error) {\r\n            console.log(error);\r\n            return new Uint8Array(0).buffer;\r\n        }\r\n    },\r\n    async loadRegionHeader(location) {\r\n        try {\r\n            const response = await this.sendDVEDMessage({\r\n                type: `load-region-header`,\r\n                location: location,\r\n            });\r\n            const buffer = await response.arrayBuffer();\r\n            if (buffer.byteLength == 1) {\r\n                throw new Error(`Region header at ${location.toString()} could not be loaded`);\r\n            }\r\n            return buffer;\r\n        }\r\n        catch (error) {\r\n            console.log(error);\r\n            return new Uint8Array(0).buffer;\r\n        }\r\n    },\r\n    async saveColumn(location, buffer) {\r\n        const response = await this.sendDVEDMessage({\r\n            type: `save-column`,\r\n            location: location,\r\n        }, buffer);\r\n        const error = (await this._determineError(response)) != Infinity;\r\n        if (error) {\r\n            console.warn(`Problem saving data at ${location.toString()} code : ${error}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    async loadRegion(location) {\r\n        const response = await this.sendDVEDMessage({\r\n            type: `load-column`,\r\n            location: location,\r\n        });\r\n        const buffer = await response.arrayBuffer();\r\n        const uncompressed = await CrystalCompressor.decompressArray(buffer, \"Uint8\");\r\n        return [uncompressed.buffer];\r\n    },\r\n    async saveRegion(buffer) {\r\n        const proms = [];\r\n        for (const column of buffer) {\r\n            proms.push(this.saveColumn(column[0], column[1]));\r\n        }\r\n        await Promise.all(proms);\r\n        return true;\r\n    },\r\n};\r\n","import { AppDataBase } from \"../../../databases/App/AppDataBase\";\r\nexport async function RegisterIOTasks(DVEDL) {\r\n    await AppDataBase.$INIT();\r\n    DVEDL.TC.registerTasks(\"set-save\", async (id, onDone) => {\r\n        await AppDataBase.getWorldSave(id);\r\n        if (onDone)\r\n            onDone();\r\n    }, \"deferred\");\r\n}\r\n","//https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\nexport function StringToNumber(str, seed = 0) {\n    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n    for (let i = 0, ch; i < str.length; i++) {\n        ch = str.charCodeAt(i);\n        h1 = Math.imul(h1 ^ ch, 2654435761);\n        h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n    h1 =\n        Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^\n            Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n    h2 =\n        Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^\n            Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n    return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n}\n","import { DataHanlderWrapper } from \"./DataHandlerWrapper.js\";\nexport class DataHandler {\n    mode = \"indexdb\";\n    constructor() {\n        this.mode = DataHanlderWrapper.mode;\n    }\n    setMode(mode) {\n        this.mode = mode;\n    }\n    dataType = \"world-data\";\n    setDataType(type) {\n        this.dataType = type;\n    }\n}\n","//objects\nimport { DVEDL } from \"../DivineVoxelEngineDataLoader.js\";\nimport { ColumnDataTool } from \"../../Tools/Data/WorldData/ColumnDataTool.js\";\nimport { WorldDataSerialize } from \"../Serializers/WorldDataSerializer.js\";\nimport { Util } from \"../../Global/Util.helper.js\";\nimport { WorldRegister } from \"../../Data/World/WorldRegister.js\";\nimport { RichDataTool } from \"../../Tools/Data/RichDataTool.js\";\nimport { DataHooks } from \"../../Data/DataHooks.js\";\nconst columnDatatool = new ColumnDataTool();\nexport const DataHanlderWrapper = {\n    mode: \"indexdb\",\n    handler: {},\n    richData: {},\n    $INIT(handler) {\n        this.handler = handler;\n        this.richData = new RichDataTool();\n    },\n    async loadRegionHeader(location) {\n        this.handler.setDataType(\"world-data\");\n        try {\n            const headerBuffer = await this.handler.getRegionHeader(location);\n            if (!headerBuffer)\n                return false;\n            const sab = Util.convertBufferToSAB(headerBuffer);\n            DVEDL.worldComm.runTasks(\"load-region-header\", [\n                location,\n                sab,\n            ]);\n            this.handler.setDataType(\"world-data\");\n            return true;\n        }\n        catch (error) {\n            console.error(`Problem getting region header at ${location.toString()}`);\n            console.error(error);\n            return false;\n        }\n    },\n    async saveColumn(location) {\n        this.handler.setDataType(\"world-data\");\n        if (columnDatatool.setLocation(location).loadIn()) {\n            try {\n                if (columnDatatool.isStored())\n                    return true;\n                columnDatatool.markAsStored();\n                const column = WorldDataSerialize.serializeColumn(location);\n                if (!column)\n                    return false;\n                this.handler.setDataType(\"world-data\");\n                const success = await this.handler.saveColumn(location, column);\n                if (!success) {\n                    columnDatatool.markAsNotStored();\n                    throw new Error(`Could not store column at ${location.toString()}`);\n                }\n                if (this.richData._enabled) {\n                    const column = await this.richData.setLocation(location).getColumnAsync();\n                    if (column) {\n                        this.handler.setDataType(\"rich-data\");\n                        const success = await this.handler.saveColumn(location, column);\n                        if (!success) {\n                            columnDatatool.markAsNotStored();\n                            throw new Error(`Rich data could not store column at ${location.toString()}`);\n                        }\n                    }\n                }\n                this.handler.setDataType(\"world-data\");\n            }\n            catch (error) {\n                console.error(`Problem storing column at ${location.toString()}`);\n                console.error(error);\n            }\n        }\n    },\n    async loadColumn(location) {\n        this.handler.setDataType(\"world-data\");\n        try {\n            if (WorldRegister.column.get(location))\n                return true;\n            this.handler.setDataType(\"world-data\");\n            const column = await this.handler.getColumn(location);\n            const data = WorldDataSerialize.deSerializeColumn(column);\n            columnDatatool.setBuffer(data.column);\n            DVEDL.worldComm.runTasks(\"load-column\", [\n                location,\n                data.column,\n            ]);\n            for (const chunk of data.chunks) {\n                DVEDL.worldComm.runTasks(\"load-chunk\", [\n                    location,\n                    chunk,\n                ]);\n            }\n            if (this.richData._enabled && columnDatatool.hasRichData()) {\n                this.handler.setDataType(\"rich-data\");\n                const richColumn = await this.handler.getColumn(location);\n                if (!richColumn)\n                    return false;\n                await this.richData.setLocation(location).setColumnAsync(richColumn);\n            }\n            this.handler.setDataType(\"world-data\");\n            return true;\n        }\n        catch (error) {\n            console.error(`Problem loading column at ${location.toString()}`);\n            console.error(error);\n            return false;\n        }\n    },\n    async unLoadColumn(location) {\n        this.handler.setDataType(\"world-data\");\n        if (columnDatatool.setLocation(location).loadIn()) {\n            try {\n                if (!columnDatatool.isStored()) {\n                    await this.saveColumn(location);\n                }\n                if (this.richData._enabled &&\n                    (await this.richData.setLocation(location).columnHasDataAsync())) {\n                    await this.richData.removeColumnAsync();\n                }\n                this.handler.setDataType(\"world-data\");\n            }\n            catch (error) {\n                console.error(`Problem storing column at ${location.toString()}`);\n                console.error(error);\n            }\n        }\n        else {\n            return true;\n        }\n    },\n    async setPath(id) {\n        this.handler.setDataType(\"world-data\");\n        try {\n            await this.handler.setPath(id);\n            return true;\n        }\n        catch (error) {\n            console.error(`Problem setting path to ${id}`);\n            console.error(error);\n            return false;\n        }\n    },\n    async columnExists(location) {\n        this.handler.setDataType(\"world-data\");\n        try {\n            if (WorldRegister.column.get(location))\n                return true;\n            return await this.handler.columnExists(location);\n        }\n        catch (error) {\n            console.error(`Problem checking if column exists at ${location.toString()}`);\n            console.error(error);\n            return false;\n        }\n    },\n    async columnTimestamp(location) {\n        this.handler.setDataType(\"world-data\");\n        try {\n            return await this.handler.columnTimestamp(location);\n        }\n        catch (error) {\n            console.error(`Problem getting column timestamp at ${location.toString()}`);\n            console.error(error);\n            return 0;\n        }\n    },\n};\nDataHooks.settingsSynced.addToRun((data) => {\n    DataHanlderWrapper.mode = data.data.mode;\n});\n","//objects\nimport { EngineSettings } from \"../Data/Settings/EngineSettings.js\";\nimport { Util } from \"../Global/Util.helper.js\";\nimport { DataSyncNode } from \"../Data/DataSyncNode.js\";\nimport { DataManager } from \"../Data/DataManager.js\";\nimport { WorldDataSerialize } from \"./Serializers/WorldDataSerializer.js\";\n//intercomms\nimport { WorldComm, ParentComm } from \"./Threads/DataLoaderThreads.js\";\n//functions\nimport { InitWorker } from \"./Init/InitWorker.js\";\nimport { DataLoaderTasks } from \"./Tasks/DataLoaderTasks.js\";\nimport { DataHanlderWrapper } from \"./DataHandler/DataHandlerWrapper.js\";\nimport { ThreadComm } from \"threadcomm\";\nimport { RichDataTool } from \"../Tools/Data/RichDataTool.js\";\nimport { DataTool } from \"../Tools/Data/DataTool.js\";\nexport const DVEDL = {\n    environment: \"browser\",\n    TC: ThreadComm,\n    UTIL: Util,\n    settings: EngineSettings,\n    dataSyncNode: DataSyncNode,\n    data: DataManager,\n    worldComm: WorldComm,\n    parentComm: ParentComm,\n    tasks: DataLoaderTasks,\n    serializer: WorldDataSerialize,\n    dataHandler: DataHanlderWrapper,\n    async $INIT(dataHanlder) {\n        this.dataHandler.$INIT(dataHanlder);\n        await InitWorker(this);\n    },\n    getRichDataTool() {\n        return new RichDataTool();\n    },\n    getDataTool() {\n        return new DataTool();\n    },\n};\n","import { DataLoaderThreadState } from \"../Threads/DataLoaderThreadState.js\";\nimport { ThreadComm } from \"threadcomm\";\nexport async function InitWorker(DVED) {\n    let parent = \"render\";\n    if (DVED.environment == \"node\") {\n        parent = \"server\";\n    }\n    await ThreadComm.$INIT(\"data-loader\", parent);\n    await DVED.UTIL.createPromiseCheck({\n        check: () => {\n            return DataLoaderThreadState.isReady();\n        },\n        checkInterval: 1,\n    });\n}\n","//objects\nimport { RegionDataTool } from \"../../Tools/Data/WorldData/RegionDataTool.js\";\nimport { ColumnDataTool } from \"../../Tools/Data/WorldData/ColumnDataTool.js\";\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\nimport { WorldDataHeaders, DVEMessageHeader, } from \"../../Data/Constants/DataHeaders.js\";\nexport const WorldDataSerialize = {\n    regions: new RegionDataTool(),\n    columns: new ColumnDataTool(),\n    chunks: new ChunkDataTool(),\n    serializeRegion(location) {\n        if (!this.regions\n            .setDimension(location[0])\n            .loadInAt(location[1], location[2], location[3]))\n            return false;\n        const region = this.regions.getRegion();\n        const columnBuffers = [];\n        region.columns.forEach((column) => {\n            this.columns.setColumn(column);\n            const location = this.columns.getLocationData();\n            const columnBuffer = this.serializeColumn(location);\n            if (columnBuffer)\n                columnBuffers.push([[...location], columnBuffer]);\n        });\n        return columnBuffers;\n    },\n    serializeColumn(location) {\n        if (!this.columns.setLocation(location).loadIn())\n            return false;\n        const columnSize = this.columns.getBufferSizeForWholeColumn();\n        const columnBuffer = new ArrayBuffer(columnSize);\n        const columnArray = new Uint8Array(columnBuffer);\n        const column = this.columns.getColumn();\n        let offset = this._readDataIntoBuffer(0, columnArray, column.buffer);\n        column.chunks.forEach((chunk) => {\n            offset += this._readDataIntoBuffer(offset, columnArray, chunk.buffer);\n        });\n        return columnArray;\n    },\n    deSerializeRegion(regionBuffers) {\n        for (const buffer of regionBuffers) {\n            this.deSerializeColumn(buffer);\n        }\n    },\n    deSerializeColumn(columnBuffer) {\n        const dv = new DataView(columnBuffer);\n        if (dv.getUint16(0) != DVEMessageHeader &&\n            dv.getUint16(2) != WorldDataHeaders.column) {\n            throw new Error(`Column at ${location} is not the correct format.`);\n        }\n        const chunks = [];\n        const columnSAB = new SharedArrayBuffer(this.columns.getBufferSize());\n        const columnArray = new Uint8Array(columnSAB);\n        let offset = this._readDataIntoBuffer(0, columnArray, columnBuffer, 0, this.columns.getBufferSize());\n        const columnBufferLength = columnBuffer.byteLength;\n        while (offset < columnBufferLength) {\n            const dataType = dv.getUint16(offset + 2);\n            if (dataType == WorldDataHeaders.chunk) {\n                const chunkSAB = new SharedArrayBuffer(this.chunks.getBufferSize());\n                const chunkArray = new Uint8Array(chunkSAB);\n                offset += this._readDataIntoBuffer(0, chunkArray, columnBuffer, offset, this.chunks.getBufferSize());\n                chunks.push(chunkSAB);\n                continue;\n            }\n            throw new Error(`Error loading column at: ${location}`);\n        }\n        return {\n            column: columnSAB,\n            chunks: chunks,\n        };\n    },\n    _readDataIntoBuffer(offset, target, source, sourceOffset = 0, sourceLength = -1) {\n        const bufferArray = new Uint8Array(source, sourceOffset, sourceLength == -1 ? source.byteLength : sourceLength);\n        let i = bufferArray.length;\n        while (i--) {\n            target[i + offset] = bufferArray[i];\n        }\n        return bufferArray.length;\n    },\n};\n","import { DVEDL } from \"../DivineVoxelEngineDataLoader.js\";\nimport { ThreadComm } from \"threadcomm\";\nimport { DataHanlderWrapper } from \"../../DataLoader/DataHandler/DataHandlerWrapper.js\";\nimport { WorldRegister } from \"../../Data/World/WorldRegister.js\";\nimport { SafeInterval } from \"../../Global/Util/SafeInterval.js\";\nexport const DataLoaderTasks = {\n    loadRegionHeader: ThreadComm.registerTasks(\"load-region-header\", async (data, onDone) => {\n        const success = await DataHanlderWrapper.loadRegionHeader(data);\n        return onDone ? onDone(success) : false;\n    }, \"deferred\"),\n    saveColumn: ThreadComm.registerTasks(\"save-column\", async (data, onDone) => {\n        await DataHanlderWrapper.saveColumn(data);\n        return onDone ? onDone() : false;\n    }, \"deferred\"),\n    loadColumn: ThreadComm.registerTasks(\"load-column\", async (data, onDone) => {\n        if (WorldRegister.column.get(data)) {\n            if (onDone) {\n                onDone();\n            }\n            return;\n        }\n        await DataHanlderWrapper.loadColumn(data);\n        const inte = new SafeInterval().setInterval(1).setOnRun(() => {\n            if (WorldRegister.column.get(data)) {\n                onDone ? onDone(true) : false;\n                inte.stop();\n            }\n        });\n        inte.stop();\n    }, \"deferred\"),\n    unLoadColumn: ThreadComm.registerTasks(\"unload-column\", async (data, onDone) => {\n        if (!WorldRegister.column.get(data)) {\n            if (onDone)\n                onDone();\n            return;\n        }\n        await DataHanlderWrapper.unLoadColumn(data);\n        DVEDL.worldComm.runPromiseTasks(\"unload-column\", data, [], () => {\n            if (onDone)\n                onDone();\n        });\n    }, \"deferred\"),\n    setPath: ThreadComm.registerTasks(\"set-path\", async (data, onDone) => {\n        await DataHanlderWrapper.setPath(data[0]);\n        return onDone ? onDone() : false;\n    }, \"deferred\"),\n    columnExists: ThreadComm.registerTasks(\"column-exists\", async (data, onDone) => {\n        if (WorldRegister.column.get(data)) {\n            if (onDone) {\n                onDone();\n            }\n            return;\n        }\n        const exists = await DataHanlderWrapper.columnExists(data);\n        if (onDone) {\n            onDone(exists);\n        }\n        return false;\n    }, \"deferred\"),\n    columnTimestamp: ThreadComm.registerTasks(\"column-timestamp\", async (data, onDone) => {\n        const time = await DataHanlderWrapper.columnTimestamp(data);\n        if (onDone) {\n            onDone(time);\n        }\n        return 0;\n    }, \"deferred\"),\n};\n","import { WorldComm } from \"./DataLoaderThreads.js\";\nexport const DataLoaderThreadState = {\n    _settingsSynced: false,\n    isReady() {\n        return WorldComm.isPortSet() && this._settingsSynced;\n    }\n};\n","import { EngineSettings } from \"../../Data/Settings/EngineSettings.js\";\nimport { ThreadComm } from \"threadcomm\";\nimport { DataLoaderThreadState } from \"./DataLoaderThreadState.js\";\nimport { DataHooks } from \"../../Data/DataHooks.js\";\nexport const ParentComm = ThreadComm.parent;\nexport const RichWorldComm = ThreadComm.createComm(\"rich-world\");\nexport const WorldComm = ThreadComm.createComm(\"world\");\nThreadComm.registerTasks(\"sync-settings\", (settings) => {\n    DataLoaderThreadState._settingsSynced = true;\n    EngineSettings.syncSettings(settings);\n    DataHooks.settingsSynced.run(settings);\n});\n","export * from \"./DivineVoxelEngineDataLoader.js\";\n","export const DVEMessageHeader = 0xffff;\nexport const WorldDataHeaders = {\n    region: 0,\n    column: 1,\n    chunk: 2,\n};\n","//objects\nimport { ThreadComm } from \"threadcomm\";\nimport { WorldRegister } from \"./World/WorldRegister.js\";\nimport { DataSyncIds } from \"../Common/Threads/Contracts/DataSyncIds.js\";\nimport { VoxelPaletteReader } from \"./Voxel/VoxelPalette.js\";\nimport { DimensionsRegister } from \"./World/Dimensions/DimensionsRegister.js\";\nimport { ChunkTags } from \"./World/Chunk/ChunkTags.js\";\nimport { RegionHeaderTags, RegionTags } from \"./World/Region/RegionTags.js\";\nimport { ColumnTags } from \"./World/Column/ColumnTags.js\";\nimport { VoxelTags } from \"./Voxel/VoxelTags.js\";\nimport { MappedDataRegister } from \"./Register/MappedDataRegister.js\";\nimport { RegionHeaderRegister } from \"./World/Region/RegionHeaderRegister.js\";\nimport { SubstancePaletteReader } from \"./Substance/SubstancePalette.js\";\nimport { SubstanceTags } from \"./Substance/SubstanceTags.js\";\nexport const DataSyncNode = {\n    maps: {\n        strings: ThreadComm.onDataSync(DataSyncIds.registerStringMap, (data) => {\n            MappedDataRegister.stringMaps.sync(data);\n        }),\n        objects: ThreadComm.onDataSync(DataSyncIds.registerObjectMap, (data) => {\n            MappedDataRegister.objectMaps.sync(data);\n        }),\n    },\n    palettes: {\n        voxel: ThreadComm.onDataSync(DataSyncIds.voxelPalette, ([palette, map]) => {\n            VoxelPaletteReader.setVoxelPalette(palette, map);\n        }),\n        substance: ThreadComm.onDataSync(DataSyncIds.substancePalette, ([palette, map]) => {\n            SubstancePaletteReader.setPalette(palette, map);\n        }),\n    },\n    worldData: {\n        dimension: ThreadComm.onDataSync(DataSyncIds.dimesnion, (data) => {\n            DimensionsRegister.registerDimension(data.id, data.options);\n        }),\n        chunk: ThreadComm.onDataSync(DataSyncIds.chunk, (data) => {\n            WorldRegister.chunk.add(data[0], data[1]);\n        }, (data) => {\n            WorldRegister.chunk.remove(data);\n        }),\n        column: ThreadComm.onDataSync(DataSyncIds.column, (data) => {\n            WorldRegister.column.add(data[0], data[1]);\n        }, (data) => {\n            WorldRegister.column.remove(data);\n        }),\n        region: ThreadComm.onDataSync(DataSyncIds.region, (data) => {\n            WorldRegister.region.add(data[0], data[1]);\n        }, (data) => {\n            WorldRegister.region.remove(data);\n        }),\n        regionHeader: ThreadComm.onDataSync(DataSyncIds.regionHeader, (data) => {\n            RegionHeaderRegister.add(data[0], data[1]);\n        }, (data) => {\n            RegionHeaderRegister.remove(data);\n        }),\n    },\n    tags: {\n        voxel: ThreadComm.onDataSync(DataSyncIds.voxelTags, (data) => {\n            VoxelTags.$INIT(data[0]);\n            VoxelTags.sync(new Uint16Array(data[1]));\n        }),\n        substance: ThreadComm.onDataSync(DataSyncIds.substanceTags, (data) => {\n            SubstanceTags.$INIT(data);\n        }),\n        chunk: ThreadComm.onDataSync(DataSyncIds.chunkTags, (data) => {\n            ChunkTags.$INIT(data);\n        }),\n        column: ThreadComm.onDataSync(DataSyncIds.columnTags, (data) => {\n            ColumnTags.$INIT(data);\n        }),\n        region: ThreadComm.onDataSync(DataSyncIds.regionTags, (data) => {\n            RegionTags.$INIT(data[0]);\n            RegionHeaderTags.$INIT(data[1]);\n        }),\n    },\n};\n","import { DBO } from \"divine-binary-object/index.js\";\nimport { ThreadComm } from \"threadcomm\";\nimport { LocationBoundTool } from \"../Classes/LocationBoundTool.js\";\nexport class RichDataTool extends LocationBoundTool {\n    segment = \"voxels\";\n    comm;\n    _enabled = false;\n    constructor() {\n        super();\n        this.comm = ThreadComm.getComm(\"rich-world\");\n        if (!this.comm || !this.comm.isPortSet()) {\n            this._enabled = false;\n            if (this.comm) {\n                this.comm.onSetPort(() => {\n                    this._enabled = true;\n                });\n            }\n            return;\n        }\n        if (this.comm.isPortSet()) {\n            this._enabled = true;\n        }\n    }\n    isEnabled() {\n        return this._enabled;\n    }\n    setSegment(segment) {\n        this.segment = segment;\n        return this;\n    }\n    columnHasData(check) {\n        this.comm.runPromiseTasks(\"has-data\", this.location, [], (hadData) => {\n            check(hadData);\n        });\n    }\n    columnHasDataAsync() {\n        return new Promise((resolve) => {\n            this.columnHasData((hasData) => {\n                resolve(hasData);\n            });\n        });\n    }\n    getData(onDone) {\n        this.comm.runPromiseTasks(\"get-data\", [this.location, this.segment], [], (data) => {\n            if (!data)\n                return onDone(false);\n            onDone(DBO.bufferToObject(data));\n        });\n    }\n    getDataAsync() {\n        return new Promise((resolve) => {\n            this.getData((data) => {\n                resolve(data);\n            });\n        });\n    }\n    setData(data, onDone = (data) => { }) {\n        const buffer = DBO.objectToBuffer(data);\n        this.comm.runPromiseTasks(\"set-data\", [this.location, this.segment, buffer], [buffer], (success) => {\n            onDone(success);\n        });\n    }\n    setDataAsync(data) {\n        return new Promise((resolve) => {\n            this.setData(data, (updated) => {\n                resolve(updated);\n            });\n        });\n    }\n    removeData(onDone) {\n        this.comm.runPromiseTasks(\"remove-data\", [this.location, this.segment], [], (removed) => {\n            onDone(removed);\n        });\n    }\n    removeDataAsync() {\n        return new Promise((resolve) => {\n            this.removeData((removed) => {\n                resolve(removed);\n            });\n        });\n    }\n    removeColumn(onDone) {\n        this.comm.runPromiseTasks(\"remove-column\", this.location, [], (removed) => {\n            onDone(removed);\n        });\n    }\n    removeColumnAsync() {\n        return new Promise((resolve) => {\n            this.removeData((removed) => {\n                resolve(removed);\n            });\n        });\n    }\n    getColumn(onDone) {\n        this.comm.runPromiseTasks(\"get-column\", this.location, [], (data) => {\n            onDone(data);\n        });\n    }\n    getColumnAsync() {\n        return new Promise((resolve) => {\n            this.getColumn((data) => {\n                resolve(data);\n            });\n        });\n    }\n    setColumn(column, onDone) {\n        this.comm.runPromiseTasks(\"set-column\", [this.location, column], [], (success) => {\n            onDone(success);\n        });\n    }\n    setColumnAsync(column) {\n        return new Promise((resolve) => {\n            this.setColumn(column, (success) => {\n                resolve(success);\n            });\n        });\n    }\n    releaeAllData() {\n        this.comm.runTasks(\"release-all-data\", [], []);\n    }\n}\n","export const WorldDataBase = {\n    database: {},\n    dimension: \"\",\n    typeStores: {},\n    async setDimension(dimensionId) {\n        if (this.dimension != dimensionId) {\n            const worldDataId = `${dimensionId}-world-data`;\n            const richDataId = `${dimensionId}-rich-data`;\n            const entitiesId = `${dimensionId}-entities`;\n            const dboId = `${dimensionId}-dbo`;\n            this.database.close();\n            await this.database.addCollection([\n                {\n                    name: worldDataId,\n                    schema: [],\n                },\n                {\n                    name: richDataId,\n                    schema: [],\n                },\n                {\n                    name: entitiesId,\n                    schema: [],\n                },\n                {\n                    name: dboId,\n                    schema: [],\n                },\n            ]);\n            this.typeStores[\"world-data\"] = await this.database.getCollection(worldDataId);\n            this.typeStores[\"rich-data\"] = await this.database.getCollection(richDataId);\n            this.typeStores[\"entities\"] = await this.database.getCollection(entitiesId);\n            this.typeStores[\"dbo\"] = await this.database.getCollection(dboId);\n        }\n        this.dimension = dimensionId;\n    },\n    setDataBase(database) {\n        this.dimension = \"\";\n        this.database = database;\n        //@ts-ignore\n        this.typeStores = {};\n    },\n    regionHeader: {\n        async set(key, type, data) {\n            await WorldDataBase.typeStores[type].set(this._getKey(key, type), data);\n        },\n        async get(key, type) {\n            const buffer = (await WorldDataBase.typeStores[type].get(this._getKey(key, type)));\n            if (!buffer)\n                return false;\n            return buffer;\n        },\n        _getKey(key, type) {\n            return `${key}_${type}_region_header`;\n        },\n    },\n    column: {\n        async set(key, type, data) {\n            await WorldDataBase.typeStores[type].set(this._getKey(key, type), data);\n        },\n        async get(key, type) {\n            const buffer = (await WorldDataBase.typeStores[type].get(this._getKey(key, type)));\n            if (!buffer)\n                return false;\n            return await buffer;\n        },\n        _getKey(key, type) {\n            return `${key}_${type}_column`;\n        },\n    },\n    columnTimestamp: {\n        async set(key, type, timeStamp) {\n            await WorldDataBase.typeStores[type].set(this._getKey(key, type), timeStamp);\n        },\n        async get(key, type) {\n            const timeStamp = (await WorldDataBase.typeStores[type].get(this._getKey(key, type)));\n            if (!timeStamp)\n                return false;\n            return Number(timeStamp);\n        },\n        _getKey(key, type) {\n            return `${key}_${type}_column_timestamp`;\n        },\n    },\n};\n","import { ZeneithDB } from \"zeneithdb\";\nimport { WorldDataBase } from \"./DataBase/WorldDataBase.js\";\nexport const DVEDBrowser = {\n    async $INIT() {\n        await ZeneithDB.$INIT();\n    },\n    async getWorldDataBase(dbName, dimension = \"main\") {\n        let db;\n        const existanceCheck = await ZeneithDB.databaseExists(dbName);\n        if (!existanceCheck) {\n            db = await ZeneithDB.createDatabase({\n                databaseName: dbName,\n                collections: [\n                    {\n                        name: \"world-meta\",\n                        schema: [],\n                    },\n                ],\n            });\n            WorldDataBase.setDataBase(db);\n        }\n        else {\n            db = await ZeneithDB.getDatabase(dbName);\n            WorldDataBase.setDataBase(db);\n        }\n        return WorldDataBase;\n    },\n    async deleteWorldDataBase(dbName) {\n        await ZeneithDB.deleteDatabase(dbName);\n    },\n};\n","export * from \"./DivineVoxelEngineDataClient.js\";\nexport * from \"./DataBase/WorldDataBase.js\";\n","import { ZeneithDB } from \"../ZeneithDB.js\";\nimport { ThreadComm } from \"threadcomm\";\nexport class ZeneithError extends Error {\n    constructor(message, data) {\n        super();\n        console.group();\n        console.error(`[ZDB ERROR: ${new Date().toLocaleTimeString()}]\r\n   [THREAD: name: ${ThreadComm.threadName} number: ${ThreadComm.threadName} parent : ${ThreadComm.parent.name}]\r\n   ${message}`, data);\n        console.table(ZeneithDB.core.loadedDatabases);\n        console.groupEnd();\n    }\n}\n","import { ThreadComm } from \"threadcomm\";\nimport { ZeneithDB } from \"../ZeneithDB.js\";\nclass SecureIDBWrap {\n    id;\n    data;\n    static dbs = new Map();\n    static clear(id) {\n        const cdb = SecureIDBWrap.dbs.get(id);\n        if (!cdb)\n            return;\n        cdb.close();\n        SecureIDBWrap.dbs.delete(id);\n    }\n    connectionId = crypto.randomUUID();\n    constructor(id, data) {\n        this.id = id;\n        this.data = data;\n        if (SecureIDBWrap.dbs.get(id)) {\n            const cdb = SecureIDBWrap.dbs.get(id);\n            cdb.close();\n        }\n        SecureIDBWrap.dbs.set(this.id, data);\n        ZeneithDB.core.dataBase.setData(\"meta\", `${this.connectionId}-${id}`, {\n            time: new Date().toLocaleTimeString(),\n            dataBaseId: id,\n            thread: {\n                name: ThreadComm.threadName,\n                number: ThreadComm.threadNumber,\n                parent: ThreadComm.parent.name,\n            },\n        });\n    }\n    get() {\n        return this.data;\n    }\n    null() {\n        SecureIDBWrap.clear(this.id);\n        ZeneithDB.core.dataBase.removeData(\"meta\", `${this.connectionId}-${this.id}`);\n    }\n}\nexport { SecureIDBWrap };\n","import { DataBase } from \"../Database/Database.js\";\nimport { ZeneithUtil } from \"../ZeneithUtil.js\";\nimport { RegisterZeneithTasks } from \"./ZeneithTasks.js\";\nimport { CommBase, CommManager } from \"threadcomm\";\nRegisterZeneithTasks();\nexport const ZeneithDBCore = {\n    dataBase: {},\n    __version: 1,\n    loadedDatabases: {},\n    util: ZeneithUtil,\n    async initialize() {\n        this.dataBase = new DataBase({\n            databaseName: \"ZeneithDB\",\n            collections: [\n                {\n                    name: \"meta\",\n                    schema: [],\n                },\n                {\n                    name: \"collections\",\n                    schema: [],\n                },\n                {\n                    name: \"databases\",\n                    schema: [],\n                },\n            ],\n        }, true);\n        const version = await this.dataBase.getDatabaeVersion();\n        if (version != this.__version + 1) {\n            console.warn(\"ZeneithDB is being created.\");\n            await this.dataBase.__create();\n        }\n        await this.dataBase.open();\n        await this.dataBase.removeAllData(\"meta\");\n    },\n    async createDataBase(data) {\n        if (this.loadedDatabases[data.databaseName])\n            return this.loadedDatabases[data.databaseName];\n        const databaseCheck = await this.dataBase.getData(\"databases\", data.databaseName);\n        if (databaseCheck) {\n            throw new Error(`The database ${data.databaseName} already exists. Use 'updateDatabase' to update the database instead.`);\n        }\n        await this.dataBase.setData(\"databases\", data.databaseName, {\n            collectionCount: data.collections.length,\n            creationData: data,\n        });\n        const database = new DataBase(data);\n        this.loadedDatabases[data.databaseName] = database;\n        await database.__create();\n        return database;\n    },\n    async updateDatBaseData(data) {\n        await this.dataBase.setData(\"databases\", data.databaseName, {\n            collectionCount: data.collections.length,\n            creationData: data,\n        });\n    },\n    async getDataBase(dataBasename) {\n        if (this.loadedDatabases[dataBasename]) {\n            return this.loadedDatabases[dataBasename];\n        }\n        await this.dataBase.open();\n        const dataBaseCheck = await this.dataBase.getData(\"databases\", dataBasename);\n        if (!dataBaseCheck) {\n            throw new Error(`The database ${dataBasename} does not exists inside of ZeneithDB.`);\n        }\n        const database = new DataBase(dataBaseCheck.creationData);\n        this.loadedDatabases[dataBasename] = database;\n        return database;\n    },\n    async dataBaseExist(dataBasename) {\n        const check = await this.dataBase.getData(\"databases\", dataBasename);\n        if (!check) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    },\n    async deleteDataBase(dataBasename) {\n        delete this.loadedDatabases[dataBasename];\n        await this.dataBase.open();\n        const check = await this.dataBase.getData(\"databases\", dataBasename);\n        if (!check) {\n            return false;\n        }\n        this.dataBase.removeData(\"databases\", dataBasename);\n        for (const collection of check.creationData.collections) {\n            await this.dataBase.removeData(\"collections\", `${dataBasename}-${collection.name}`);\n        }\n        indexedDB.deleteDatabase(dataBasename);\n    },\n    tasks: {\n        close(comm, id) {\n            return new Promise(async (resolve, reject) => {\n                console.log(\"closing \", id, comm instanceof CommBase);\n                if (comm instanceof CommBase) {\n                    return comm.runPromiseTasks(\"zdb-close-database\", id, [], () => {\n                        resolve(true);\n                    });\n                }\n                if (comm instanceof CommManager) {\n                    await Promise.all(comm.__comms.map((_) => new Promise((r) => {\n                        _.runPromiseTasks(\"zdb-close-database\", id, [], () => {\n                            r(true);\n                            console.log(id, \"close\", _.name);\n                        });\n                    })));\n                    return resolve(true);\n                }\n                reject(false);\n            });\n        },\n        open(comm, id) {\n            return new Promise(async (resolve, reject) => {\n                if (comm instanceof CommBase) {\n                    return comm.runPromiseTasks(\"zdb-open-database\", id, [], () => {\n                        resolve(true);\n                    });\n                }\n                if (comm instanceof CommManager) {\n                    await Promise.all(comm.__comms.map((_) => new Promise((r) => {\n                        _.runPromiseTasks(\"zdb-open-database\", id, [], () => {\n                            r(true);\n                        });\n                    })));\n                    return resolve(true);\n                }\n                reject(false);\n            });\n        },\n    },\n};\n","import { ThreadComm } from \"threadcomm\";\nimport { ZeneithDBCore } from \"./ZeneithDBCore.js\";\nexport function RegisterZeneithTasks() {\n    ThreadComm.registerTasks(\"zdb-close-database\", async (dbId, onDone) => {\n        const db = ZeneithDBCore.loadedDatabases[dbId];\n        if (!db)\n            return;\n        await db.waitTillTranscationDone();\n        db.close();\n        if (onDone)\n            onDone();\n    }, \"deferred\");\n    ThreadComm.registerTasks(\"zdb-open-database\", async (dbId, onDone) => {\n        const db = ZeneithDBCore.loadedDatabases[dbId];\n        if (!db)\n            return;\n        await db.waitTillTranscationDone();\n        db.open();\n        if (onDone)\n            onDone();\n    }, \"deferred\");\n}\n","import { ZeneithDBCore } from \"../Core/ZeneithDBCore.js\";\nimport { ZeneithUtil } from \"../ZeneithUtil.js\";\nimport { ObjectStore } from \"../Store/ObjectStore.js\";\nimport { ZeneithError } from \"../Classes/Errors.js\";\nimport { SecureIDBWrap } from \"../Classes/SecureIDBWrap.js\";\nexport class DataBase {\n    creationData;\n    outsideZeneith;\n    dataBaseName = \"\";\n    util = ZeneithUtil;\n    opened = false;\n    __db = null;\n    states = {\n        dataUpdating: false,\n        collectionUpdate: false,\n    };\n    get db() {\n        return this.__db;\n    }\n    set db(db) {\n        if (this.__db != null && db != null) {\n            throw new ZeneithError(\"Overrode active database.\", {\n                dataBaseID: this.dataBaseName,\n                dataBase: this,\n            });\n        }\n        this.__db = db;\n    }\n    _beingUpgrded = false;\n    _openeed = [];\n    _closed = [];\n    _activeTransaction = null;\n    constructor(creationData, outsideZeneith = false) {\n        this.creationData = creationData;\n        this.outsideZeneith = outsideZeneith;\n        this.dataBaseName = this.creationData.databaseName;\n    }\n    __open(version) {\n        this._openeed.push(performance.now());\n        if (this.db)\n            this.close();\n        this.db = null;\n        SecureIDBWrap.clear(this.dataBaseName);\n        return indexedDB.open(this.dataBaseName, version);\n    }\n    isOpen() {\n        return this.db !== null;\n    }\n    getUUID() {\n        return ZeneithUtil.getUUID();\n    }\n    open() {\n        if (this._beingUpgrded) {\n            throw new ZeneithError(\"Tried opening while updating\", {\n                dataBase: this,\n                dataBaseID: this.dataBaseName,\n                functionName: this.open.name,\n            });\n        }\n        if (this.isOpen())\n            return true;\n        const prom = new Promise((resolve, reject) => {\n            const request = this.__open();\n            request.onerror = (event) => {\n                reject(false);\n                throw new ZeneithError(\"Opening a database failed.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                });\n            };\n            request.onblocked = (event) => {\n                reject(false);\n                throw new ZeneithError(\"Opening a database was blocked\", {\n                    blocked: true,\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                });\n            };\n            request.onsuccess = (event) => {\n                this.db = new SecureIDBWrap(this.dataBaseName, request.result);\n                this.opened = true;\n                resolve(true);\n            };\n        });\n        return prom;\n    }\n    close() {\n        this._closed.push(performance.now());\n        if (!this.db) {\n            return false;\n        }\n        this.opened = false;\n        this.db.null();\n        this.db = null;\n        return true;\n    }\n    _openAtVersion(version = 1) {\n        const prom = new Promise(async (resolve, reject) => {\n            const request = this.__open(version);\n            request.onerror = (event) => {\n                reject(false);\n                throw new ZeneithError(\"Opening a database failed.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: this._openAtVersion.name,\n                });\n            };\n            request.onblocked = (event) => {\n                reject(false);\n                throw new ZeneithError(\"Opening a database was blocked\", {\n                    blocked: true,\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: this._openAtVersion.name,\n                });\n            };\n            request.onsuccess = (event) => {\n                this.db = new SecureIDBWrap(this.dataBaseName, request.result);\n                this.opened = true;\n                resolve(true);\n            };\n        });\n        return prom;\n    }\n    async __create() {\n        return await this.forceUpdate(undefined, true);\n    }\n    async forceUpdate(removeCollections, newDB = false) {\n        let version = newDB ? 1 : await this.getDatabaeVersion();\n        if (this._beingUpgrded) {\n            throw new ZeneithError(\"Tried updating while already updating\", {\n                dataBase: this,\n                dataBaseID: this.dataBaseName,\n                functionName: this.forceUpdate.name,\n            });\n        }\n        this._beingUpgrded = true;\n        this.close();\n        return new Promise((resolve, reject) => {\n            const request = this.__open(version + 1);\n            request.onerror = (event) => {\n                this._beingUpgrded = false;\n                reject(false);\n                throw new ZeneithError(\"Force update ran into an error.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: this.forceUpdate.name,\n                });\n            };\n            request.onblocked = (event) => {\n                this._beingUpgrded = false;\n                reject(false);\n                throw new ZeneithError(\"Force update was blocked.\", {\n                    blocked: true,\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: this.forceUpdate.name,\n                });\n            };\n            request.onupgradeneeded = (event) => {\n                const db = new SecureIDBWrap(this.dataBaseName, request.result);\n                this.db = db;\n                if (!this.outsideZeneith) {\n                    ZeneithDBCore.updateDatBaseData(this.creationData);\n                }\n                if (removeCollections) {\n                    for (const collectionName of removeCollections) {\n                        db.get().deleteObjectStore(collectionName);\n                    }\n                }\n                for (const collectionData of this.creationData.collections) {\n                    if (db.get().objectStoreNames.contains(collectionData.name))\n                        continue;\n                    this._processCollectionScehma(db.get().createObjectStore(collectionData.name), collectionData.schema);\n                }\n            };\n            request.onsuccess = (event) => {\n                if (!this.db)\n                    this.db = new SecureIDBWrap(this.dataBaseName, request.result);\n                this.close();\n                resolve(true);\n                this._beingUpgrded = false;\n            };\n        });\n    }\n    _processCollectionScehma(collection, schema) {\n        this.__traverseColletionScehma(collection, schema);\n    }\n    __traverseColletionScehma(collection, schema) {\n        for (const node of schema) {\n            if (Array.isArray(node)) {\n                this.__traverseColletionScehma(collection, node);\n                continue;\n            }\n            if (node.index) {\n                collection.createIndex(node.name, node.name, { unique: node.isUnique });\n            }\n            if (node.children) {\n                this.__traverseColletionScehma(collection, node.children);\n            }\n        }\n    }\n    async getCollection(id) {\n        if (!this.isOpen())\n            await this.open();\n        if (!this.db?.get().objectStoreNames.contains(id)) {\n            throw new Error(`${id} does not exists in database ${this.creationData.databaseName}`);\n        }\n        return new ObjectStore(this, id);\n    }\n    async addCollection(data) {\n        if (this._beingUpgrded) {\n            throw new ZeneithError(\"Tried adding collections while updating\", {\n                dataBase: this,\n                dataBaseID: this.dataBaseName,\n                functionName: this.addCollection.name,\n            });\n        }\n        try {\n            if (!this.isOpen())\n                await this.open();\n            let count = 0;\n            for (const store of data) {\n                if (this.db.get().objectStoreNames.contains(store.name))\n                    continue;\n                this.creationData.collections.push(store);\n                count++;\n            }\n            this.close();\n            if (count)\n                await this.forceUpdate();\n            return true;\n        }\n        catch (error) {\n            console.error(error);\n            return false;\n        }\n    }\n    async removeCollection(collectionName) {\n        if (this._beingUpgrded) {\n            throw new ZeneithError(\"Tried removing collections while updating\", {\n                dataBase: this,\n                dataBaseID: this.dataBaseName,\n                functionName: this.removeCollection.name,\n            });\n        }\n        try {\n            let deleteCollections = [];\n            if (typeof collectionName == \"string\") {\n                deleteCollections.push(collectionName);\n            }\n            else {\n                deleteCollections.push(...collectionName);\n            }\n            const collections = [];\n            for (const collection of this.creationData.collections) {\n                if (!deleteCollections.includes(collection.name)) {\n                    collections.push(collection);\n                }\n            }\n            this.creationData.collections = collections;\n            await this.forceUpdate(deleteCollections);\n            return true;\n        }\n        catch (error) {\n            console.log(`Failed making a new collection with the name ${collectionName}`);\n            console.error(error);\n            return false;\n        }\n    }\n    getDatabaeVersion() {\n        if (this.db)\n            return this.db.get().version;\n        const prom = new Promise((resolve, reject) => {\n            const request = this.__open();\n            request.onsuccess = (event) => {\n                const version = request.result.version;\n                this.db = new SecureIDBWrap(this.dataBaseName, request.result);\n                this.close();\n                resolve(version);\n            };\n            request.onerror = (event) => {\n                reject(false);\n                throw new ZeneithError(\"Get version ran into an error.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: this.getDatabaeVersion.name,\n                });\n            };\n            request.onblocked = (event) => {\n                this._beingUpgrded = false;\n                reject(false);\n                this.getDatabaeVersion.name;\n                throw new ZeneithError(\"Get version was blocked.\", {\n                    blocked: true,\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: this.getDatabaeVersion.name,\n                });\n            };\n        });\n        return prom;\n    }\n    doesCollectionExist(collectionName) {\n        if (!this.db) {\n            throw new Error(`Database ${this.dataBaseName} is not opened.`);\n        }\n        if (this.db.get().objectStoreNames.contains(collectionName)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    waitTillTranscationDone() {\n        return new Promise((resolve) => {\n            const inte = setInterval(() => {\n                if (this._activeTransaction)\n                    return;\n                clearInterval(inte);\n                resolve(true);\n            }, 10);\n        });\n    }\n    waitTillUpdatingDone() {\n        return new Promise((resolve) => {\n            const inte = setInterval(() => {\n                if (this._beingUpgrded)\n                    return;\n                clearInterval(inte);\n                resolve(true);\n            }, 10);\n        });\n    }\n    getData(collectionName, key) {\n        return new Promise(async (resolve, reject) => {\n            await this.waitTillUpdatingDone();\n            await this.waitTillTranscationDone();\n            if (!this.isOpen())\n                await this.open();\n            const transaction = this.db.get().transaction([collectionName], \"readonly\");\n            const objectStore = transaction.objectStore(collectionName);\n            this._activeTransaction = transaction;\n            const request = objectStore.get(key);\n            request.onerror = (event) => {\n                reject(false);\n                this._activeTransaction = null;\n                throw new ZeneithError(\"Error while getting data.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: \"getData\",\n                });\n            };\n            transaction.oncomplete = () => {\n                this._activeTransaction = null;\n                if (!request.result) {\n                    resolve(false);\n                }\n                else {\n                    resolve(request.result);\n                }\n            };\n        });\n    }\n    getAllData(collectionName) {\n        return new Promise(async (resolve, reject) => {\n            await this.waitTillUpdatingDone();\n            await this.waitTillTranscationDone();\n            if (!this.isOpen())\n                await this.open();\n            const transaction = this.db.get().transaction([collectionName], \"readonly\");\n            const request = transaction\n                .objectStore(collectionName)\n                .getAll();\n            this._activeTransaction = transaction;\n            request.onerror = (event) => {\n                reject(false);\n                throw new ZeneithError(\"Error while getting all data.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: \"getAllData\",\n                });\n            };\n            transaction.oncomplete = () => {\n                this._activeTransaction = null;\n                if (!request.result) {\n                    resolve(false);\n                }\n                else {\n                    resolve(request.result);\n                }\n            };\n        });\n    }\n    getAllKeys(collectionName) {\n        return new Promise(async (resolve, reject) => {\n            await this.waitTillUpdatingDone();\n            await this.waitTillTranscationDone();\n            if (!this.isOpen())\n                await this.open();\n            const transaction = this.db.get().transaction([collectionName], \"readonly\");\n            const request = transaction\n                .objectStore(collectionName)\n                .getAllKeys();\n            this._activeTransaction = transaction;\n            request.onerror = (event) => {\n                reject(false);\n                throw new ZeneithError(\"Error while getting all keys.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: \"getAllKeys\",\n                });\n            };\n            transaction.oncomplete = () => {\n                this._activeTransaction = null;\n                if (!request.result) {\n                    resolve(false);\n                }\n                else {\n                    resolve(request.result);\n                }\n            };\n        });\n    }\n    removeData(collectionName, key) {\n        this.states.dataUpdating = true;\n        return new Promise(async (resolve, reject) => {\n            await this.waitTillUpdatingDone();\n            await this.waitTillTranscationDone();\n            if (!this.isOpen())\n                await this.open();\n            const transaction = this.db.get().transaction([collectionName], \"readwrite\");\n            const request = transaction.objectStore(collectionName).delete(key);\n            this._activeTransaction = transaction;\n            request.onerror = (event) => {\n                reject(false);\n                this._activeTransaction = null;\n                throw new ZeneithError(\"Error while removing data.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: \"removeData\",\n                });\n            };\n            transaction.oncomplete = () => {\n                resolve(true);\n                this._activeTransaction = null;\n            };\n        });\n    }\n    removeAllData(collectionName) {\n        return new Promise(async (resolve, reject) => {\n            await this.waitTillUpdatingDone();\n            await this.waitTillTranscationDone();\n            if (!this.isOpen())\n                await this.open();\n            const transaction = this.db.get().transaction([collectionName], \"readwrite\");\n            const request = transaction.objectStore(collectionName).clear();\n            this._activeTransaction = transaction;\n            request.onerror = (event) => {\n                this._activeTransaction = null;\n                reject(false);\n                throw new ZeneithError(\"Error while removing all data.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: \"removeAllData\",\n                });\n            };\n            transaction.oncomplete = () => {\n                resolve(true);\n                this._activeTransaction = null;\n            };\n        });\n    }\n    setData(collectionName, key, setData) {\n        this.states.dataUpdating = true;\n        return new Promise(async (resolve, reject) => {\n            await this.waitTillUpdatingDone();\n            await this.waitTillTranscationDone();\n            if (!this.isOpen())\n                await this.open();\n            const transaction = this.db.get().transaction([collectionName], \"readwrite\");\n            const request = transaction.objectStore(collectionName).put(setData, key);\n            this._activeTransaction = transaction;\n            request.onerror = (event) => {\n                reject(false);\n                this._activeTransaction = null;\n                throw new ZeneithError(\"Error while setting data.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: \"setData\",\n                });\n            };\n            transaction.oncomplete = () => {\n                resolve(true);\n                this._activeTransaction = null;\n            };\n        });\n    }\n    updateData(collectionName, key, updateFunction) {\n        this.states.dataUpdating = true;\n        return new Promise(async (resolve, reject) => {\n            await this.waitTillUpdatingDone();\n            await this.waitTillTranscationDone();\n            if (!this.isOpen())\n                await this.open();\n            const transaction = this.db.get().transaction([collectionName], \"readwrite\");\n            const objectStore = transaction.objectStore(collectionName);\n            const request = objectStore.get(key);\n            this._activeTransaction = transaction;\n            request.onerror = (event) => {\n                reject(false);\n                this._activeTransaction = null;\n                throw new ZeneithError(\"Error while updating data.\", {\n                    dataBaseID: this.dataBaseName,\n                    event: event,\n                    dataBase: this,\n                    functionName: \"updateData\",\n                });\n            };\n            request.onsuccess = (event) => {\n                this._activeTransaction = null;\n                //@ts-ignore\n                const data = event.target.result;\n                if (!data) {\n                    resolve(false);\n                    transaction.commit();\n                    return;\n                }\n                const newData = updateFunction(data);\n                const requestUpdate = objectStore.put(newData);\n                requestUpdate.onerror = (event) => {\n                    this._activeTransaction = null;\n                    reject(false);\n                    throw new ZeneithError(\"Error while updating data.\", {\n                        dataBaseID: this.dataBaseName,\n                        event: event,\n                        dataBase: this,\n                        functionName: \"updateData\",\n                    });\n                };\n                transaction.oncomplete = () => {\n                    this._activeTransaction = null;\n                    resolve(true);\n                };\n            };\n        });\n    }\n}\n","export {};\n","export {};\n","export {};\n","export * from \"./Database/Database.types.js\";\nexport * from \"./Database/Schema.types.js\";\nexport * from \"./Zeneith/Database.schema.js\";\n","export class ObjectStore {\n    db;\n    id;\n    constructor(db, id) {\n        this.db = db;\n        this.id = id;\n    }\n    async get(id) {\n        return await this.db.getData(this.id, id);\n    }\n    async set(id, data) {\n        return await this.db.setData(this.id, id, data);\n    }\n    async delete(id) {\n        return await this.db.removeData(this.id, id);\n    }\n}\n","import { ZeneithDBCore } from \"./Core/ZeneithDBCore.js\";\nexport const ZeneithDB = {\n    __initalized: false,\n    core: ZeneithDBCore,\n    async $INIT() {\n        if (this.__initalized)\n            return;\n        await this.core.initialize();\n        this.__initalized = true;\n    },\n    async databaseExists(dataBaseName) {\n        return await this.core.dataBaseExist(dataBaseName);\n    },\n    async createDatabase(data) {\n        return await this.core.createDataBase(data);\n    },\n    async updateDatabase(data) {\n        return await this.core.createDataBase(data);\n    },\n    async getDatabase(name) {\n        return await this.core.getDataBase(name);\n    },\n    async deleteDatabase(name) {\n        return await this.core.deleteDataBase(name);\n    },\n};\n","export const ZeneithUtil = {\n    getUUID: function () {\n        let d = new Date().getTime();\n        let d2 = (performance && performance.now && performance.now() * 1000) || 0;\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n            let r = Math.random() * 16;\n            if (d > 0) {\n                r = (d + r) % 16 | 0;\n                d = Math.floor(d / 16);\n            }\n            else {\n                r = (d2 + r) % 16 | 0;\n                d2 = Math.floor(d2 / 16);\n            }\n            return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n        });\n    },\n};\n","export * from \"./ZeneithDB.js\";\nexport * from \"./Database/Database.js\";\nexport * from \"./Store/ObjectStore.js\";\n","export * from \"./ZeneithDB/index.js\";\nexport * from \"./ZeneithDB/Meta/index.js\";\n","export const CCCore = {\r\n    async compressArrayBuffer(input) {\r\n        //@ts-ignore\r\n        const cs = new CompressionStream(\"gzip\");\r\n        const writer = cs.writable.getWriter();\r\n        writer.write(input);\r\n        writer.close();\r\n        const output = [];\r\n        const reader = cs.readable.getReader();\r\n        let totalSize = 0;\r\n        while (true) {\r\n            const { value, done } = await reader.read();\r\n            if (done)\r\n                break;\r\n            output.push(value);\r\n            totalSize += value.byteLength;\r\n        }\r\n        const concatenated = new Uint8Array(totalSize);\r\n        let offset = 0;\r\n        for (const array of output) {\r\n            concatenated.set(array, offset);\r\n            offset += array.byteLength;\r\n        }\r\n        return concatenated;\r\n    },\r\n    async decompressArrayBuffer(input) {\r\n        //@ts-ignore\r\n        const ds = new DecompressionStream(\"gzip\");\r\n        const writer = ds.writable.getWriter();\r\n        writer.write(input);\r\n        writer.close();\r\n        const output = [];\r\n        const reader = ds.readable.getReader();\r\n        let totalSize = 0;\r\n        while (true) {\r\n            const { value, done } = await reader.read();\r\n            if (done)\r\n                break;\r\n            output.push(value);\r\n            totalSize += value.byteLength;\r\n        }\r\n        const concatenated = new Uint8Array(totalSize);\r\n        let offset = 0;\r\n        for (const array of output) {\r\n            concatenated.set(array, offset);\r\n            offset += array.byteLength;\r\n        }\r\n        return concatenated;\r\n    },\r\n    processArray(type, array) {\r\n        const returnArray = this.getArray[type](array.buffer);\r\n        return returnArray;\r\n    },\r\n    getArray: {\r\n        Int8: (buffer) => {\r\n            return new Int8Array(buffer);\r\n        },\r\n        Uint8: (buffer) => {\r\n            return new Uint8Array(buffer);\r\n        },\r\n        Uint8Clamped: (buffer) => {\r\n            return new Uint8ClampedArray(buffer);\r\n        },\r\n        Int16: (buffer) => {\r\n            return new Int16Array(buffer);\r\n        },\r\n        Uint16: (buffer) => {\r\n            return new Uint16Array(buffer);\r\n        },\r\n        Int32: (buffer) => {\r\n            return new Int32Array(buffer);\r\n        },\r\n        Uint32: (buffer) => {\r\n            return new Uint32Array(buffer);\r\n        },\r\n        Float32: (buffer) => {\r\n            return new Float32Array(buffer);\r\n        },\r\n        Float64: (buffer) => {\r\n            return new Float64Array(buffer);\r\n        },\r\n        BigInt64: (buffer) => {\r\n            return new BigInt64Array(buffer);\r\n        },\r\n        BigUint64: (buffer) => {\r\n            return new BigUint64Array(buffer);\r\n        },\r\n    },\r\n};\r\n","import { CCCore } from \"./CCCore.js\";\r\nexport const CrystalCompressor = {\r\n    core: CCCore,\r\n    version: 0.0,\r\n    async compressArray(array) {\r\n        const returnArray = await this.core.compressArrayBuffer(array.buffer);\r\n        return returnArray;\r\n    },\r\n    async decompressArray(buffer, type) {\r\n        const returnData = await this.core.decompressArrayBuffer(buffer);\r\n        return this.core.processArray(type, returnData);\r\n    },\r\n};\r\n","export * from \"./CrystalCompressor.js\";\r\n","export * from \"./CrystalCompressor/index.js\";\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"DSLIBS_divineBinaryObject_dist_index_js-DSLIBS_divineVoxelEngine_dist_Common_Threads_Contract-5324f4\"], () => (__webpack_require__(\"./compiled/environments/electron/client/dataloader.js\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && !queue.d) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = 1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && (queue.d = 0);\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".DVE.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"compiled_environments_electron_client_dataloader_js\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdve_testing\"] = self[\"webpackChunkdve_testing\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(\"DSLIBS_divineBinaryObject_dist_index_js-DSLIBS_divineVoxelEngine_dist_Common_Threads_Contract-5324f4\").then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":[],"sourceRoot":""}