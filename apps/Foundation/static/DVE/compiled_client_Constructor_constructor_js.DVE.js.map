{"version":3,"file":"compiled_client_Constructor_constructor_js.DVE.js","mappings":";;;;;;;;;;;;;;;AAA2G;AACpD;AACQ;AAC/D,oHAA0B,CAAC,iEAAI;AAC/B,sFAAyB,CAAC,oEAAc;AACxC,MAAM,uEAAU;;;;;;;;;;;;;;;;;;;;;;ACLuC;AACF;AACV;AACH;AAC8C;AAC/B;AACvD,mBAAmB,qDAAa;AAChC,oBAAoB,qDAAa;AACjC,uBAAuB,qDAAa;AACpC;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mFAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0EAAoB;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0BAA0B;AACxD,kCAAkC,0BAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+FAAuB;AACnD;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC7JsD;AAC/C;AACP;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvB6E;AACtE;AACP;AACA;AACA;AACA,uBAAuB,0GAA8B;AACrD;AACA;AACA,uBAAuB,0GAA8B;AACrD;AACA;AACA,uBAAuB,2GAA+B;AACtD;AACA;AACA,uBAAuB,2GAA+B;AACtD;AACA;AACA,uBAAuB,kHAAsC;AAC7D;AACA;AACA,uBAAuB,kHAAsC;AAC7D;AACA;AACA,uBAAuB,kHAAsC;AAC7D;AACA;AACA,uBAAuB,kHAAsC;AAC7D;AACA;AACA,uBAAuB,uGAA2B;AAClD;AACA;AACA,uBAAuB,uGAA2B;AAClD;AACA;AACA,uBAAuB,wGAA4B;AACnD;AACA;AACA,uBAAuB,wGAA4B;AACnD;AACA;AACA,uBAAuB,+GAAmC;AAC1D;AACA;AACA,uBAAuB,+GAAmC;AAC1D;AACA;AACA,uBAAuB,+GAAmC;AAC1D;AACA;AACA,uBAAuB,+GAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3D0E;AACnE;AACP;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC,iCAAiC,UAAU;AAC3C;AACA;AACA,wCAAwC,+GAAsC;AAC9E;AACA;AACA;AACA,wCAAwC,+GAAsC;AAC9E;AACA;AACA;AACA,wCAAwC,+GAAsC;AAC9E;AACA;AACA;AACA,wCAAwC,+GAAsC;AAC9E;AACA;AACA;AACA,wCAAwC,uGAA8B;AACtE;AACA;AACA;AACA,wCAAwC,uGAA8B;AACtE;AACA;AACA;AACA,wCAAwC,wGAA+B;AACvE;AACA;AACA;AACA,wCAAwC,wGAA+B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjDoD;AACP;AAC7C,gBAAgB;AAChB,cAAc;AACP;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAc;AACtB;AACA;AACA;;;;;;;;;;;;;;;;;AC9CqE;AACJ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC,yBAAyB,gBAAgB;AACzC,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC,yBAAyB,gBAAgB;AACzC,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8EAAmB;AACvB,IAAI,8EAAmB;AACvB,IAAI,8EAAmB;AACvB,IAAI,8EAAmB;AACvB,IAAI,0EAAiB;AACrB;;;;;;;;;;;;;;;;AC9EiE;AAC1D;AACP;AACA;AACA;AACA,YAAY,mFAAqB;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACbA;AACA;AAC2D;AACR;AACQ;AACpD;AACP,IAAI,uEAAgB;AACpB,IAAI,+DAAY;AAChB,IAAI,uEAAa;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpGgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA,mCAAmC,EAAE;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kFAAqB;AACrC;AACA;AACA;AACA;AACA;AACA,gBAAgB,qFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA,gBAAgB,mFAAsB;AACtC;AACA;AACA;AACA;AACA;AACA,gBAAgB,mFAAsB;AACtC;AACA;AACA;AACA;AACA;AACA,gBAAgB,oFAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,gBAAgB,oFAAuB;AACvC;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;AC9DoE;AACmC;AAChG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+HAA+B;AAC3C;AACA,aAAa;AACb,SAAS;AACT;AACA,YAAY,oIAAoC;AAChD,YAAY,mFAAsB;AAClC;AACA;AACA;AACA;AACA,oBAAoB,2HAA2B;AAC/C;AACA,gBAAgB,qFAAwB;AACxC;AACA;AACA;AACA;AACA,gBAAgB,wFAA2B;AAC3C;AACA;AACA;AACA,gBAAgB,sFAAyB;AACzC;AACA;AACA;AACA,gBAAgB,sFAAyB;AACzC;AACA;AACA;AACA,gBAAgB,uFAA0B;AAC1C;AACA;AACA;AACA,gBAAgB,uFAA0B;AAC1C;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;ACnDiE;AAC1D;AACP;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA,mCAAmC,EAAE;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,kFAAqB;AACrC;AACA;AACA;AACA,gBAAgB,qFAAwB;AACxC;AACA;AACA;AACA,gBAAgB,mFAAsB;AACtC;AACA;AACA;AACA,gBAAgB,mFAAsB;AACtC;AACA;AACA;AACA,gBAAgB,oFAAuB;AACvC;AACA;AACA;AACA,gBAAgB,oFAAuB;AACvC;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;AC3C6C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAG;AAC3B,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5BsC;AACJ;AACM;;;;;;;;;;;;;;;ACFxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;AC1BS;AAC7B;AACA;AACA;AACA;AACA,yBAAyB,gDAAI;AAC7B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;ACjCG;AAC7B;AACA;AACA;AACA;AACA,oBAAoB,gDAAI;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;ACjDQ;AAC7B;AACA;AACA;AACA;AACA,2BAA2B,gDAAI;AAC/B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;AC/CrB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACpBoD;AACV;AACc;AACP;AACjD;AACA;AACA;AACA,SAAS;AACT;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,YAAY,8DAAiB;AAC7B;AACA;AACA;AACA,2BAA2B,4DAAK;AAChC;AACA,2BAA2B,iEAAU;AACrC;AACA,2BAA2B,mEAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;ACnGpB;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;;;;;;;;;;;;;;;;;ACtBuC;AACvC,iEAAe,gDAAI,EAAC;AACJ;;;;;;;;;;;;;;;ACFT;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACyE;AACb;AAC5D;AACuE;AACE;AACd;AACJ;AACC;AACA;AACxD;AACA,mBAAmB,6DAAQ;AAC3B,wBAAwB,6DAAQ;AACzB;AACP,aAAa,gEAAe;AAC5B,eAAe,oEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oFAAsB;AACzC,kBAAkB,mFAAqB;AACvC;AACA;AACA;AACA,sBAAsB,uFAAmC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,+EAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB,qFAAU,CAAC,qFAAiC;AAC9D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8EAAI;AAC/C,SAAS;AACT;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACrF8D;AACgB;AACF;AACA;AACV;AAClE,uBAAuB,mFAAc;AACrC,0BAA0B,iFAAa;AACvC,sBAAsB,iFAAa;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,oFAA0B;AAClC;AACA,mBAAmB,mFAA2B;AAC9C,mBAAmB,mFAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC,iCAAiC,UAAU;AAC3C,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA,QAAQ,qFAA2B;AACnC,KAAK;AACL;;;;;;;;;;;;;;;ACnCO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACXgE;AACc;AACd;AACQ;AACL;AACL;AACK;AAC5D;AACP,kBAAkB,uFAAiB;AACnC,oBAAoB,uEAAc;AAClC,oBAAoB,yEAAc;AAClC,WAAW,4EAAkB;AAC7B,eAAe,iFAAe;AAC9B,wBAAwB,4EAAkB;AAC1C;AACA,QAAQ,oGAA4C;AACpD;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACzB6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAc;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC/G4E;AACZ;AACH;AACE;AACG;AAClE,WAAW,+DAAS;AACpB,uBAAuB,kEAAc;AACrC,qBAAqB,kEAAc;AACnC,qBAAqB,kEAAc;AACnC,oBAAoB,kEAAc;AAClC,oBAAoB,kEAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6FAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB;AACA,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB,mBAAmB;AACnB,mBAAmB;AACZ;AACP,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,uFAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6FAA2B;AAC3C;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uFAAiC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6FAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACrTO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxIkF;AACxB;AACnD,wCAAwC,kEAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yFAAqB;AACjC;AACA;AACA;AACA,YAAY,4FAAwB;AACpC;AACA;AACA;AACA,YAAY,0FAAsB;AAClC;AACA;AACA;AACA,YAAY,0FAAsB;AAClC;AACA;AACA;AACA,YAAY,2FAAuB;AACnC;AACA;AACA;AACA,YAAY,2FAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvEkF;AACxB;AACnD,wCAAwC,kEAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yFAAqB;AACjC;AACA;AACA;AACA,YAAY,4FAAwB;AACpC;AACA;AACA;AACA,YAAY,0FAAsB;AAClC;AACA;AACA;AACA,YAAY,0FAAsB;AAClC;AACA;AACA;AACA,YAAY,2FAAuB;AACnC;AACA;AACA;AACA,YAAY,2FAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtD0D;AACiC;AACpF,sCAAsC,kEAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gGAAsB;AAC9B;AACA;AACA;AACA,YAAY,kGAAwB;AACpC;AACA;AACA;AACA,YAAY,qGAA2B;AACvC;AACA;AACA;AACA,YAAY,mGAAyB;AACrC;AACA;AACA;AACA,YAAY,mGAAyB;AACrC;AACA;AACA;AACA,YAAY,oGAA0B;AACtC;AACA;AACA;AACA,YAAY,oGAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5C0D;AACoC;AACvF,iDAAiD,kEAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mGAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtB0D;AAC8B;AACjF,0CAA0C,kEAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6FAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtB0D;AAC+B;AAClF,0CAA0C,kEAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gGAAuB;AACnC;AACA;AACA;AACA,YAAY,mGAA0B;AACtC;AACA;AACA;AACA,YAAY,iGAAwB;AACpC;AACA;AACA;AACA,YAAY,iGAAwB;AACpC;AACA;AACA;AACA,YAAY,kGAAyB;AACrC;AACA;AACA;AACA,YAAY,kGAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3CO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;ACFA;AAC6D;AAC7D;AACmF;AACC;AACG;AACE;AACA;AACc;AAChG;AACP,sBAAsB,4DAAO;AAC7B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,2BAA2B,4FAAyB;AACpD,aAAa;AACb;AACA,2BAA2B,4FAAyB;AACpD,aAAa;AACb,SAAS;AACT;AACA;AACA,2BAA2B,kGAA2B;AACtD,aAAa;AACb,SAAS;AACT;AACA;AACA,2BAA2B,kGAA2B;AACtD,aAAa;AACb,SAAS;AACT;AACA;AACA,2BAA2B,gHAAkC;AAC7D,aAAa;AACb,SAAS;AACT;AACA;AACA,2BAA2B,gGAAuB;AAClD,aAAa;AACb,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;ACrDO;AACP;AACA,aAAa,kBAAkB;AAC/B,aAAa,kBAAkB;AAC/B,aAAa,kBAAkB;AAC/B,aAAa,kBAAkB;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACnRiE;AACD;AACR;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,sEAAe;AAClC,uBAAuB,qEAAc;AACrC;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kBAAkB;AAClB,gBAAgB;AAChB,gBAAgB;AAChB,KAAK;AACL;AACA;AACA,mBAAmB;AACnB,sBAAsB;AACtB,oBAAoB;AACpB,oBAAoB;AACpB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iCAAiC,EAAE,GAAG,EAAE;AACxC,KAAK;AACL;AACA,wCAAwC,EAAE,GAAG,EAAE;AAC/C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,gEAAW;AACxC;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;ACrTiD;AACS;AACM;AACjB;AACtD,+BAA+B,gEAAW;AAC1C;AACA,mBAAmB,sEAAe;AAClC;AACA;AACA;AACA,8BAA8B,sFAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA,uBAAuB,wFAA8B;AACrD;AACA;AACA,qDAAqD,sFAA+B;AACpF;AACA;AACA,qBAAqB,sFAA+B;AACpD,QAAQ,qEAAmB;AAC3B,QAAQ,8EAA4B;AACpC;AACA;AACA;AACA;AACA,qDAAqD,sFAA+B;AACpF;AACA;AACA,qBAAqB,sFAA+B;AACpD;AACA;AACA;AACO;;;;;;;;;;;;;;;ACpCA;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACL8D;AACJ;AACnD;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mCAAmC,uEAAc;AACjD,mCAAmC,mEAAY;;;;;;;;;;;;;;;;;;;;;;ACfqB;AACP;AAC7D;AACiE;AACI;AACrE;AAC+E;AACjB;AACX;AACnD,sBAAsB,sEAAe;AACrC,0BAA0B,iFAAa;AAChC;AACP,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wFAA8B;AACrD;AACA;AACA,yBAAyB,qFAA6B;AACtD;AACA;AACA,QAAQ,qEAAmB;AAC3B,QAAQ,8EACU;AAClB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,oFAA0B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mFAA2B;AACpD;AACA,oBAAoB,UAAU,EAAE,uFAA+B;AAC/D;AACA;AACA;AACA;AACA,6BAA6B,qFAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qFAA2B;AACnC;AACA;AACA,0CAA0C,yFAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sFAAwB;AAChC,KAAK;AACL;;;;;;;;;;;;;;;AC5FO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC/B0D;AACY;AAC/D;AACP,iBAAiB,4DAAO;AACxB;AACA,iCAAiC,8EAAmB;AACpD,KAAK;AACL;;;;;;;;;;;;;;;;;;ACPA;AACkF;AACL;AAChB;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,+EAAiB;AACnD,8BAA8B,4GACd;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kFAA8B;AAC/C,gBAAgB,0EAAsB;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AChD6D;AACG;AACpB;AAC5C,uBAAuB,kEAAc;AACrC,oBAAoB,kEAAc;AAClC;AACA;AACA;AACO;AACP;AACA,uBAAuB,oEAAyB;AAChD,0BAA0B,uEAA4B;AACtD;AACA;AACA,gBAAgB,4EAAiC;AACjD;AACA,YAAY,+EACkB;AAC9B;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAyB;AAC9C,oCAAoC,4EAAiC;AACrE;AACA;AACA,YAAY,wEAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAgC;AAC5C,YAAY,wEAA6B;AACzC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAc;AACrC;AACA;AACA;AACA,uBAAuB,oEAAc;AACrC;AACA;AACA;AACA,uBAAuB,oEAAc;AACrC;AACA;AACA;AACA,uBAAuB,oEAAc;AACrC;AACA;AACA;AACA,SAAS;AACT,iBAAiB,oEAAc;AAC/B,aAAa,oEAAc;AAC3B,aAAa,oEAAc;AAC3B,aAAa,oEAAc;AAC3B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACpE4D;AACrD;AACP;AACA,kBAAkB,oEAAc;AAChC;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;ACTwE;AAChC;AACiB;AAChE,2BAA2B,kEAAc;AAClC;AACP;AACA,8BAA8B,4EAAiC;AAC/D,QAAQ,+EACkB;AAC1B,wBAAwB,uEAA4B;AACpD,oBAAoB,oEAAyB;AAC7C,uBAAuB,uEAA4B;AACnD,0BAA0B,oEAAyB;AACnD,gCAAgC,4EAAiC;AACjE;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,8EAAmC;AAC/C;AACA,SAAS;AACT;AACA,YAAY,8EAAmC;AAC/C;AACA,SAAS;AACT;AACA,YAAY,8EAAmC;AAC/C;AACA,SAAS;AACT;AACA,YAAY,8EAAmC;AAC/C;AACA,SAAS;AACT;AACA,YAAY,8EAAmC;AAC/C;AACA,SAAS;AACT;AACA,YAAY,8EAAmC;AAC/C;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA,CAAC;AACD;AACA,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC5K+E;AAChC;AACiB;AAChE,2BAA2B,kEAAc;AAClC;AACP;AACA,8BAA8B,4EAAiC;AAC/D,QAAQ,4EACe,CAAC,uEAA4B;AACpD,oBAAoB,oEAAyB;AAC7C,uBAAuB,uEAA4B;AACnD,0BAA0B,oEAAyB;AACnD,gCAAgC,4EAAiC;AACjE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,8EACiB;AAC7B;AACA,qCAAqC,wEAA6B;AAClE;AACA,SAAS;AACT;AACA,YAAY,8EACiB;AAC7B;AACA,qCAAqC,wEAA6B;AAClE;AACA,SAAS;AACT;AACA,YAAY,8EACiB;AAC7B;AACA;AACA,0CAA0C,wEAA6B;AACvE;AACA,SAAS;AACT;AACA,YAAY,8EACiB;AAC7B;AACA;AACA,0CAA0C,wEAA6B;AACvE;AACA,SAAS;AACT;AACA,YAAY,8EACiB;AAC7B;AACA;AACA,wCAAwC,wEAA6B;AACrE;AACA,SAAS;AACT;AACA,YAAY,8EACiB;AAC7B;AACA;AACA,wCAAwC,wEAA6B;AACrE;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kGAAgC;AAChC;AACA,CAAC;AACD;AACA,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;ACxG8E;AAChC;AACiB;AAChE;AACA;AACA,WAAW,8EACU;AACrB,oBAAoB,uEAA4B;AAChD,mBAAmB,uEAA4B;AAC/C,sBAAsB,oEAAyB;AAC/C,4BAA4B,4EAAiC;AAC7D;AACA;AACA,+BAA+B,kEAAc;AAC7C,wBAAwB,kEAAc;AACtC,wBAAwB,kEAAc;AACtC;AACO;AACP;AACA;AACA;AACA,QAAQ,+EAAoC;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,uEAA4B;AACxC,wCAAwC,uEAA4B;AACpE;AACA,YAAY,8EACiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,8EACiB;AAC7B;AACA;AACA;AACA,2BAA2B,uEAA4B;AACvD,oCAAoC,4EAAiC;AACrE;AACA;AACA,gBAAgB,0FAA+C;AAC/D,gBAAgB,0FAA+C;AAC/D,gBAAgB,yFAA8C,CAAC,oEAAyB;AACxF;AACA;AACA,gBAAgB,8EAAmC,CAAC,oEAAyB;AAC7E;AACA,YAAY,wEAA6B;AACzC,SAAS;AACT;AACA;AACA,YAAY,8EACiB;AAC7B;AACA;AACA;AACA,2BAA2B,uEAA4B;AACvD,oCAAoC,4EAAiC;AACrE;AACA;AACA,gBAAgB,0FAA+C;AAC/D,gBAAgB,0FAA+C;AAC/D,gBAAgB,yFAA8C,CAAC,oEAAyB;AACxF;AACA;AACA,gBAAgB,8EAAmC,CAAC,oEAAyB;AAC7E;AACA,YAAY,wEAA6B;AACzC,SAAS;AACT;AACA;AACA,YAAY,8EACiB;AAC7B;AACA;AACA;AACA,2BAA2B,uEAA4B;AACvD,oCAAoC,4EAAiC;AACrE;AACA;AACA,gBAAgB,0FAA+C;AAC/D,gBAAgB,0FAA+C;AAC/D,gBAAgB,yFAA8C,CAAC,oEAAyB;AACxF;AACA;AACA,gBAAgB,8EAAmC,CAAC,oEAAyB;AAC7E;AACA,YAAY,wEAA6B;AACzC,SAAS;AACT;AACA;AACA,YAAY,8EACiB;AAC7B;AACA;AACA;AACA,2BAA2B,uEAA4B;AACvD,oCAAoC,4EAAiC;AACrE;AACA;AACA,gBAAgB,0FAA+C;AAC/D,gBAAgB,0FAA+C;AAC/D,gBAAgB,yFAA8C,CAAC,oEAAyB;AACxF;AACA;AACA,gBAAgB,8EAAmC,CAAC,oEAAyB;AAC7E;AACA,YAAY,wEAA6B;AACzC,SAAS;AACT,KAAK;AACL;AACA,kGAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpM+C;AACiB;AAChE,2BAA2B,kEAAc;AACzC;AACA,WAAW,2EACC,CAAC,uEAA4B;AACzC,gBAAgB,oEAAyB;AACzC,sBAAsB,oEAAyB;AAC/C,4BAA4B,4EAAiC;AAC7D;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,4EAAiC;AAC7C,gBAAgB,2EAAgC,CAAC,iEAAsB,EAAE,iEAAsB,MAAM,iEAAsB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAoC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC/DgE;AACe;AAChC;AAC/C,2BAA2B,kEAAc;AACzC;AACA,WAAW,+EACW;AACtB;AACA,mBAAmB,uEAA4B;AAC/C,gBAAgB,oEAAyB;AACzC,sBAAsB,oEAAyB;AAC/C,4BAA4B,4EAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,YAAY,4EAAiC;AAC7C;AACA;AACA,oBAAoB,6EAAkC;AACtD,KAAK;AACL;AACA,kGAAgC;AAChC;AACA;AACA;AACA;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;AC5D8E;AACP;AACJ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wFAA+B;AAC1C;AACA;AACA,SAAS,wFAA+B;AACxC,SAAS,wFAA+B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAU;AACjC;AACA,wBAAwB,gEAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAU;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,kGAAgC;AACpC;AACA,KAAK;AACL,IAAI,kGAAgC;AACpC;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;ACzEA;AAC2D;AAC3D;AACwE;AACX;AACd;AACqB;AAC7D;AACP;AACA;AACA;AACA,YAAY,wEAAkB,kBAAkB,6EAAkC,IAAI,oEAAiB;AACvG,SAAS;AACT;AACA,YAAY,wEAAkB,kBAAkB,6EAAkC,IAAI,uEAAoB;AAC1G,SAAS;AACT;AACA,YAAY,wEAAkB,kBAAkB,6EAAkC,IAAI,sEAAmB;AACzG,SAAS;AACT;AACA,YAAY,wEAAkB,kBAAkB,6EAAkC,IAAI,sEAAmB;AACzG,SAAS;AACT;AACA,YAAY,wEAAkB,kBAAkB,6EAAkC,IAAI,qEAAkB;AACxG,SAAS;AACT;AACA,YAAY,wEAAkB,kBAAkB,6EAAkC,IAAI,qEAAkB;AACxG,SAAS;AACT,KAAK;AACL;AACA,wEAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iBAAiB,wFAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wFAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uFAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uFAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qFAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qFAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oFAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oFAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+FAAsC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+FAAsC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+FAAsC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+FAAsC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4FAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4FAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4FAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4FAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACza8C;AACL;AACI;AACE;AACM;AACR;;;;;;;;;;;;;;;ACLtC;AACP;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,oBAAoB,UAAU,GAAG,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI,6BAA6B,QAAQ;AACzF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AChC2D;AACnB;AACjC,8BAA8B,6DAAQ;AAC7C;AACA,eAAe,iEAAwB;AACvC;AACA;;;;;;;;;;;;;;;;;;;ACNyD;AACR;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,iEAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,wBAAwB;AACxB,mBAAmB;AACnB;AACA,aAAa,kBAAkB;AAC/B,aAAa,kBAAkB;AAC/B,aAAa,kBAAkB;AAC/B,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,UAAU,yDAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAsD;AAC3E,sBAAsB,wDAAwD;AAC9E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClL0D;AACiB;AACpE;AACP;AACA,eAAe,4DAAO;AACtB,mBAAmB,4DAAO;AAC1B,yBAAyB,4DAAO;AAChC,qBAAqB,4DAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qFAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qFAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnG6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,QAAQ,oGAAsC;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;ACrMA;AAC+D;AACH;AACa;AACb;AAC5D;AACuD;AACD;AACtD;AAC+D;AACL;AACnD,kCAAkC,+DAAc;AACvD,gBAAgB,gEAAe;AAC/B,iBAAiB,gEAAe;AAChC;AACA;AACA;AACA,wBAAwB;AACxB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAc;AACxC,uBAAuB,kEAAc;AACrC,0BAA0B,kEAAc;AACxC,gCAAgC,kEAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAAuB;AAC/B;AACA;AACA,QAAQ,8EAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iEAAW,0BAA0B,iEAAW,0BAA0B,iEAAW;AACtI;AACA;AACA;AACA,kCAAkC,iFAA2B;AAC7D;AACA;AACA;AACA;AACA,sBAAsB,6FAA2B;AACjD;AACA,sBAAsB,6FAA2B;AACjD;AACA,sBAAsB,6FAA2B;AACjD;AACA;AACA;;;;;;;;;;;;;;;;;;AC9FmE;AACT;AACsB;AAChF,qBAAqB,kFAAmB;AACxC,8BAA8B,gEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAc;AACnC,kBAAkB,kEAAc;AAChC,yBAAyB,kEAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,2DAAU;AAC7B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;;;;;;;;;;;;AC7FU;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;ACA0B;AACA;AACI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFxC;AACoE;AACpB;AACD;AACY;AACY;AACrB;AAClD;AACqD;AACE;AAC+B;AACtF;AACwC;AAC+B;AACnB;AACpD;AACkD;AACa;AACF;AACN;AACF;AAC9C;AACP;AACA,UAAU,wDAAI;AACd,cAAc,4EAAc;AAC5B,iBAAiB,oEAAW;AAC5B,cAAc,gFAAe;AAC7B,aAAa,wDAAO;AACpB,cAAc,2DAAQ;AACtB,kBAAkB,+DAAY;AAC9B,UAAU,6DAAW;AACrB,kBAAkB,+FAAiB;AACnC,QAAQ,kDAAU;AAClB,gBAAgB,sEAAU;AAC1B,eAAe,qEAAS;AACxB,WAAW,8DAAK;AAChB,WAAW,yEAAgB;AAC3B,cAAc,iEAAY;AAC1B;AACA,cAAc,gEAAU;AACxB,KAAK;AACL;AACA,mBAAmB,8DAAQ;AAC3B,KAAK;AACL;AACA,mBAAmB,sEAAY;AAC/B,KAAK;AACL;AACA,mBAAmB,sEAAkB;;;;;;;;;;;;;;;;AChDA;AAC9B;AACP,wBAAwB,2DAAiB;AACzC;;;;;;;;;;;;;;;;;;;;ACHuE;AACO;AACtC;AACY;AACgB;AAC7D;AACP;AACA;AACA;AACA;AACA,UAAU,wDAAgB;AAC1B;AACA,IAAI,gEAAwB;AAC5B,QAAQ,yFAA2B;AACnC,QAAQ,sGAAsC;AAC9C,QAAQ,4EAA4B;AACpC,KAAK;AACL;AACA;AACA,mBAAmB,8FAA8B;AACjD,SAAS;AACT,qBAAqB;AACrB;AACA,KAAK;AACL,IAAI,gEAAwB;AAC5B,QAAQ,wFAA0B;AAClC,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACoF;AACpF;AAC2D;AACE;AAC7D;AACmE;AACW;AACA;AACzB;AACrD,qBAAqB,6DAAQ;AAC7B,sBAAsB,6DAAQ;AACvB;AACP;AACA;AACA;AACA,QAAQ,0EAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sFAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oEAAc;AAClD;AACA;AACA,oCAAoC,2EAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAS;AACjB,QAAQ,+EAAS;AACjB,QAAQ,+EAAS;AACjB,QAAQ,+EAAS;AACjB;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;ACvHoF;AACvB;AACF;AACD;AACoB;AACA;AACD;AACA;AACtE;AACP,eAAe,+DAAS;AACxB,gBAAgB,4DAAS;AACzB,oBAAoB,6DAAQ;AAC5B,oBAAoB,6DAAQ;AAC5B,wBAAwB,+EAAiB;AACzC;AACA;AACA,QAAQ,+EAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAS;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ,kGAAgC;AACxC,KAAK;AACL;AACA,wBAAwB,sFAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAS;AACjB,QAAQ,+EAAS;AACjB,QAAQ,+EAAS;AACjB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,sFAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvJsD;AACT;AACgC;AAC7E;AACA;AACA;AACA,eAAe,iEAAW;AAC1B;AACA,eAAe,iEAAW;AAC1B,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA,eAAe,iEAAW;AAC1B,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA,eAAe,iEAAW;AAC1B,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA,eAAe,iEAAW;AAC1B,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,iEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAe;AACvB;AACA;AACA,cAAc,0DAAU;AACxB;AACA;AACA,cAAc,6DAAO,CAAC,wGAA0C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA,kBAAkB,iEAAW;AAC7B,kBAAkB,sEAAgB;AAClC;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC,wBAAwB,sEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC,wBAAwB,sEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC,wBAAwB,sEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC,wBAAwB,sEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC;AACA;AACA,wBAAwB,sEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAW;AAC7B,sBAAsB,sEAAgB;AACtC;AACA;AACA,YAAY,oEAAc;AAC1B;AACA;AACA;AACA;AACA,YAAY,iEAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnKsD;AACuB;AACtE;AACP;AACA,gBAAgB,iEAAW;AAC3B;AACA;AACA;AACA,kBAAkB,iEAAW;AAC7B;AACA;AACA,uBAAuB,sEAAgB;AACvC;AACA;AACA,QAAQ,qEAAe;AACvB;AACA;AACA;AACA;AACA,kBAAkB,6DAAO,CAAC,wGAA0C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,kBAAkB,iEAAW;AAC7B,kBAAkB,sEAAgB;AAClC;AACA,YAAY,2EAAqB;AACjC,uBAAuB,iEAAW;AAClC;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9FsE;AAC/D;AACP,IAAI,qFAAe;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa,4FAAsB;AACnC;AACA,YAAY,6FAAuB;AACnC;AACA,mBAAmB,4FAAsB;AACzC;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,qFAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4FAAsB;AACnC;AACA,mBAAmB,4FAAsB;AACzC;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA,oBAAoB,iGAA2B;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA,oBAAoB,iGAA2B;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA,oBAAoB,iGAA2B;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA,oBAAoB,iGAA2B;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA,oBAAoB,iGAA2B;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAAsB,CAAC,iGAA2B;AAC1D;AACA;AACA;;;;;;;;;;;;;;;;;ACxKsE;AAC/D;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,4FAAsB;AACnC;AACA,mBAAmB,4FAAsB;AACzC;AACA;AACA,aAAa,uFAAiB;AAC9B;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,0GAAoC;AAC/D,oBAAoB,yFAAmB;AACvC;AACA,oBAAoB,4FACa,CAAC,2GAAqC;AACvE;AACA;AACA;AACA,sCAAsC,gGAA0B;AAChE;AACA;AACA,wBAAwB,4FAAsB,CAAC,oGAA8B;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4FAAsB;AACnC;AACA,mBAAmB,4FAAsB;AACzC;AACA;AACA,aAAa,uFAAiB;AAC9B;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,yGAAmC;AACvD;AACA;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,yGAAmC;AACvD;AACA;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,yGAAmC;AACvD;AACA;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,yGAAmC;AACvD;AACA;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,kHAA4C;AAChE;AACA;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,yGAAmC;AACvD;AACA;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAAsB,CAAC,iGAA2B;AAC1D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzLA;AACoE;AACI;AACe;AACnB;AACE;AACY;AAClF;AACA;AACA,kBAAkB,mFAA2B;AAC7C;AACA,kBAAkB,mFAA2B;AAC7C;AACA;AACA;AACA,0BAA0B,iFAAa;AAChC;AACP,IAAI,qFAAe;AACnB;AACA,SAAS,kFAAwB;AACjC;AACA;AACA;AACA,IAAI,gGAA0B;AAC9B;AACA;AACA;AACA,yBAAyB,KAAK,+EAAuB,EAAE;AACvD,0BAA0B,UAAU,mFAA2B,EAAE;AACjE,8BAA8B,UAAU,mFAA2B,EAAE;AACrE,qBAAqB,4FAAsB;AAC3C;AACA,0BAA0B,4FAAsB;AAChD;AACA;AACA,gBAAgB,4FAAsB,CAAC,uFAAiB;AACxD;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC,0BAA0B,UAAU,mFAA2B,EAAE;AACjE,8BAA8B,UAAU,mFAA2B,EAAE;AACrE,qBAAqB,4FAAsB;AAC3C;AACA,0BAA0B,4FAAsB;AAChD,6BAA6B,uFAAiB;AAC9C;AACA;AACA,gCAAgC,sFAAoB;AACpD;AACA;AACA;AACA,wBAAwB,4FAAsB;AAC9C,mCAAmC,4FAAsB;AACzD,uCAAuC,uFAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4FAAsB;AACnC;AACA,mBAAmB,4FAAsB;AACzC;AACA;AACA,qBAAqB,uFAAiB;AACtC;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,0GAAoC;AAC/D,oBAAoB,yFAAmB;AACvC;AACA,oBAAoB,4FACa,CAAC,2GAAqC;AACvE;AACA;AACA;AACA,sCAAsC,gGAA0B;AAChE;AACA;AACA,wBAAwB,4FAAsB,CAAC,oGAA8B;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvIA;AAC2D;AACE;AACtD;AACP,eAAe,+DAAS;AACxB;AACA,oBAAoB,6DAAQ;AAC5B,oBAAoB,6DAAQ;AAC5B;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;ACZ6E;AACA;AACV;AACP;AACA;AACO;AAC5D;AACP;AACA;AACA,YAAY,yFAA6B;AACzC,SAAS;AACT,KAAK;AACL;AACA;AACA,kBAAkB,yEAAU;AAC5B,SAAS;AACT;AACA,kBAAkB,yEAAU;AAC5B,SAAS;AACT,KAAK;AACL;AACA;AACA,YAAY,gFAAW;AACvB,SAAS;AACT,KAAK;AACL;AACA;AACA,YAAY,+EAAS;AACrB,SAAS;AACT;AACA,YAAY,+EAAS;AACrB,SAAS;AACT,KAAK;AACL;AACA;AACA,YAAY,+EAAS;AACrB,SAAS;AACT;AACA,YAAY,+EAAS;AACrB,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACzCsF;AAC5B;AAClB;AACmD;AACzB;AACU;AAC3B;AACjD,sBAAsB,iFAAa;AAC5B;AACP;AACA,sBAAsB,gEAAwB;AAC9C,YAAY,yGAA2C;AACvD,YAAY,+FAAiC,CAAC,yFAA2B;AACzE,SAAS;AACT,KAAK;AACL;AACA,kBAAkB,gEAAwB;AAC1C,6BAA6B,0FAA4B;AACzD;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,gEAAwB,CAAC,sGAA2B;AACvE;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA,aAAa;AACb,SAAS;AACT,gBAAgB,gEAAwB,CAAC,uGAA4B;AACrE,2BAA2B,kFAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qFAAuB;AACvC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,gBAAgB,gEAAwB,CAAC,uGAA4B;AACrE,kBAAkB,sEAAW;AAC7B;AACA;AACA,SAAS;AACT,eAAe,gEAAwB,CAAC,uGAA4B;AACpE,kBAAkB,0EAAe;AACjC;AACA;AACA,SAAS;AACT,eAAe,gEAAwB,CAAC,sGAA2B;AACnE,kBAAkB,yEAAc;AAChC;AACA;AACA,SAAS;AACT,KAAK;AACL,eAAe,gEAAwB,CAAC,qGAA0B;AAClE,cAAc,6FAA+B,CAAC,+EAAiC;AAC/E,KAAK;AACL,cAAc,gEAAwB,CAAC,oGAAyB;AAChE,QAAQ,2FAA6B,CAAC,8EAAgC;AACtE;AACA;AACA,KAAK;AACL;AACA,kBAAkB,gEAAwB,CAAC,oGAAyB;AACpE;AACA;AACA,YAAY,oFAAsB;AAClC,SAAS;AACT,kBAAkB,gEAAwB,CAAC,oGAAyB;AACpE;AACA;AACA,YAAY,oFAAsB;AAClC,SAAS;AACT,KAAK;AACL;AACA,qBAAqB,gEAAwB,CAAC,+GAAoC;AAClF,kBAAkB,0FAA4B;AAC9C;AACA;AACA,SAAS;AACT,gBAAgB,gEAAwB,CAAC,0GAA+B;AACxE,kBAAkB,qFAAuB;AACzC;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;ACpG+D;AACiB;AACrB;AACyB;AAC1B;AACR;AAClD,qBAAqB,6DAAQ;AAC7B,sBAAsB,6DAAQ;AAC9B,sBAAsB,4DAAS;AAC/B;AACA;AACA,gBAAgB,6FAAmB;AACnC,gBAAgB,6FAAmB;AACnC;AACA;AACA,oBAAoB,sFAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB,iFAAmC;AACrD;AACA;AACA,QAAQ,mFAAS;AACjB;AACA,kBAAkB,gFAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oFAAU;AAClB,YAAY,6FAAmB;AAC/B;AACA,YAAY,+EAAsB;AAClC;AACA;AACA,YAAY,6FAAmB;AAC/B,YAAY,+EAAsB;AAClC;AACA,YAAY,6FAAmB;AAC/B,YAAY,+EAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,iFAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6FAAmB;AACnC,gBAAgB,6FAAmB;AACnC,mBAAmB,oFAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAAsB;AACtC;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAAsB;AACtC;AACA;AACA;AACA;AACA,QAAQ,oFAAU;AAClB;AACA;AACA;AACA,YAAY,+EAAsB;AAClC;AACA;AACA,YAAY,+EAAsB;AAClC;AACA;AACA,QAAQ,mFAAS;AACjB;AACA,YAAY,gFAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB,iFAAmC;AACrD;AACA;AACA;AACA;AACA,gBAAgB,6FAAmB;AACnC,gBAAgB,6FAAmB;AACnC,QAAQ,oFAAU;AAClB;AACA;AACA;AACA,YAAY,+EAAsB;AAClC;AACA;AACA,YAAY,+EAAsB;AAClC;AACA;AACA,QAAQ,mFAAS;AACjB;AACA,YAAY,gFAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACvJ8G;AACvC;AAC/B;AACyC;AACnB;AACI;AACH;AACa;AACd;AAC9D,sBAAsB,iFAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,QAAQ,oFAA0B;AAClC;AACA;AACA;AACA,QAAQ,qFAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qFAAuB;AACnC;AACA;AACA;AACA;AACA;AACA,yBAAyB,wFAAgC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wFAAgC;AACzD;AACA,0BAA0B,mFAA2B;AACrD;AACA,0BAA0B,mFAA2B;AACrD;AACA,0BAA0B,mFAA2B;AACrD,oBAAoB,6FAA2B;AAC/C;AACA,2CAA2C,sFAAoB,YAAY,sFAAoB,YAAY,sFAAoB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8HAAuC;AACtE;AACA;AACA;AACA;AACA;AACA,YAAY,+EAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAU;AAC/B,SAAS;AACT;AACA;AACA;AACA,2BAA2B,mEAAU;AACrC,2BAA2B,mEAAU;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAU;AAC/B,SAAS;AACT;AACA;AACA,qBAAqB,mEAAU;AAC/B,6BAA6B,mEAAU;AACvC,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB,mEAAU;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACpMwC;AACjC,mBAAmB,yDAAiB;AACpC,sBAAsB,6DAAqB;AAC3C,kBAAkB,6DAAqB;;;;;;;;;;;;;;;;;ACHK;AACA;AAC5C;AACP;AACA,iBAAiB,sEAAkB;AACnC;AACA;AACA,mBAAmB,sEAAmB;AACtC;AACA;AACA,oBAAoB,sEAAmB;AACvC;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;ACdmF;AAC5B;AACS;AACR;AACE;AACE;AACA;AACI;AAC2B;AACpF,4BAA4B,4DAAS;AAC5C;AACA;AACA;AACA;AACA,YAAY,uFAAmC;AAC/C,mBAAmB,qEAAY;AAC/B;AACA;AACA,YAAY,wGAA6B;AACzC;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAqB;AACjC;AACA,YAAY,+EAAsB;AAClC;AACA,YAAY,2EAAqB;AACjC;AACA,YAAY,2FAAS;AACrB;AACA,QAAQ,iFAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAqB;AACjC;AACA,YAAY,+EAAsB;AAClC;AACA,YAAY,2EAAqB;AACjC;AACA,YAAY,2FAAS;AACrB;AACA,QAAQ,iFAAwB;AAChC;AACA;AACA,QAAQ,+EAAsB;AAC9B,QAAQ,2FAAS;AACjB;AACA;AACA;AACA;AACA,YAAY,oFAAyB;AACrC;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,YAAY,oFAAyB;AACrC;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;ACtE0D;AACO;AACc;AAChB;AAC/D,kBAAkB,4DAAS;AAC3B;AACA,sBAAsB,iFAAa;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB,6FAAqC;AAC9D,yBAAyB,wFAAgC;AACzD;AACA;AACA,gBAAgB,6EAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACjFA;AAC8D;AACI;AAClE;AAC0D;AACO;AAC1D;AACP;AACA,cAAc,2EAAgB;AAC9B,iBAAiB,mEAAW;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,2FAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAY;AACrC,gBAAgB,kGAAuC;AACvD;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,0BAA0B,kEAAa;AACvC;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzCkD;AACX;AACc;AACZ;AACA;AACS;AACuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNzE;AACwC;AACiB;AACgB;AACZ;AACiB;AACvB;AACqB;AAClB;AACT;AACqB;AACQ;AACL;AACZ;AACtD;AACP;AACA,iBAAiB,6DAAqB,CAAC,mGAA6B;AACpE,YAAY,+FAAkC;AAC9C,SAAS;AACT,iBAAiB,6DAAqB,CAAC,mGAA6B;AACpE,YAAY,+FAAkC;AAC9C,SAAS;AACT,KAAK;AACL;AACA,eAAe,6DAAqB,CAAC,8FAAwB;AAC7D,YAAY,sFAAkC;AAC9C,SAAS;AACT,mBAAmB,6DAAqB,CAAC,kGAA4B;AACrE,YAAY,8FAAiC;AAC7C,SAAS;AACT,KAAK;AACL;AACA,mBAAmB,6DAAqB,CAAC,2FAAqB;AAC9D,YAAY,yGAAoC;AAChD,SAAS;AACT,eAAe,6DAAqB,CAAC,uFAAiB;AACtD,YAAY,4EAAuB;AACnC,SAAS;AACT,YAAY,+EAA0B;AACtC,SAAS;AACT,gBAAgB,6DAAqB,CAAC,wFAAkB;AACxD,YAAY,6EAAwB;AACpC,SAAS;AACT,YAAY,gFAA2B;AACvC,SAAS;AACT,gBAAgB,6DAAqB,CAAC,wFAAkB;AACxD,YAAY,6EAAwB;AACpC,SAAS;AACT,YAAY,gFAA2B;AACvC,SAAS;AACT,sBAAsB,6DAAqB,CAAC,8FAAwB;AACpE,YAAY,4FAAwB;AACpC,SAAS;AACT,YAAY,+FAA2B;AACvC,SAAS;AACT,KAAK;AACL;AACA,eAAe,6DAAqB,CAAC,2FAAqB;AAC1D,YAAY,gEAAe;AAC3B,YAAY,+DAAc;AAC1B,SAAS;AACT,mBAAmB,6DAAqB,CAAC,+FAAyB;AAClE,YAAY,6EAAmB;AAC/B,SAAS;AACT,eAAe,6DAAqB,CAAC,2FAAqB;AAC1D,YAAY,sEAAe;AAC3B,SAAS;AACT,gBAAgB,6DAAqB,CAAC,4FAAsB;AAC5D,YAAY,yEAAgB;AAC5B,SAAS;AACT,gBAAgB,6DAAqB,CAAC,4FAAsB;AAC5D,YAAY,yEAAgB;AAC5B,YAAY,+EAAsB;AAClC,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;AC3EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;AC7BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvBO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,GAAG,EAAE,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3BwD;AACQ;AACE;AACI;AACF;AAC7D,wBAAwB,4EAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2FAAkC;AACzD;AACA;AACA,mBAAmB,2FAAkC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAAwB;AAChC;AACA;AACA;AACA,QAAQ,iFAAwB;AAChC;AACA;AACA;AACA,QAAQ,oFAA0B;AAClC;AACA;AACA;AACA,QAAQ,qFAA2B;AACnC;AACA;AACA;;;;;;;;;;;;;;;ACjHO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UClCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;WClCA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,aAAa;WACb;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;;;;;WCpCA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;UENA;UACA","sources":["webpack://dve-testing/./compiled/client/Constructor/constructor.js","webpack://dve-testing/./compiled/core/Gen/Dimensions/Main/MainWorldGen.js","webpack://dve-testing/./compiled/core/Gen/Functions/Circle.js","webpack://dve-testing/./compiled/core/Gen/Functions/StairPillar.js","webpack://dve-testing/./compiled/core/Gen/Functions/StairRoof.js","webpack://dve-testing/./compiled/core/Gen/Functions/Tree.js","webpack://dve-testing/./compiled/core/Gen/Structures/Temples/DimensoinTemple.js","webpack://dve-testing/./compiled/core/Gen/WorldGenerator.js","webpack://dve-testing/./compiled/core/data/client/Functions/RegisterVoxelConstructors.js","webpack://dve-testing/./compiled/core/data/client/Voxels/LightDebugBox.js","webpack://dve-testing/./compiled/core/data/client/Voxels/LiquidDreamEther.js","webpack://dve-testing/./compiled/core/data/client/Voxels/MarkerBox.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/IndexedRNG/index.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/index.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/perlin/index.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/seededRandom/Algorithms/Base.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/seededRandom/Algorithms/Mulberry32.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/seededRandom/Algorithms/Sfc32.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/seededRandom/Algorithms/Xoshiro128ss.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/seededRandom/LCG.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/seededRandom/Rand.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/seededRandom/helpers.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/seededRandom/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Common/Threads/Contracts/ConstructorRemoteThreadTasks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Common/Threads/Contracts/ConstructorTasks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Analyzer/Analyzer.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Analyzer/AnalyzerProcessor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Analyzer/AnalyzerUpdater.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Builder.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Calc/Flow/FlowGradient.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Calc/Light/LightGradient.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Classes/VertexData.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/Classes/Box/PillarBox.constructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/Classes/Box/SimpleBox.constructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/Classes/Liquid/SimpleLiquid.constructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/Classes/Panel/SimpleCrossedPanel.constructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/Classes/Panel/SimplePanel.constructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/Classes/Stair/SimpleStair.constructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/Classes/VoxelConstructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/VoxelConstructors.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Geometry/QuadBuilder.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Geometry/QuadUVs.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Nodes/Builders/TextureBuilder.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Nodes/Builders/VoxelBuilder.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Nodes/Classes/NodeBuilder.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Nodes/NodeBuilderManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Processors/ChunkProcessor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Rules/Overrides/OverridesManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Rules/RenderedSubstances.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Rules/SubstanceRules.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/Builder/ShapeBuilder.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/ShapeTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Box/Box.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Box/HalfBox.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Liquid/Liquid.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Panel/CrossedPanels.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Panel/Panel.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Stairs/Stair.overrides.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Stairs/Stair.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Textures/TextureManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Tools/BuilderDataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Tools/MeshBuilderTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Tools/MesherDataTools.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Tools/OutlinedVoxelTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Tools/VoxelMesherDataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Tools/VoxelShapeTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Types/Geometry.types.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Types/Override.types.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Types/ShapeBuilder.types.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Types/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/DivineVoxelEngineConstructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Hooks/ConstructorHooks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Init/InitWorker.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Explosion/ExplosionManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Flow/FlowManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Flow/Functions/FlowRemove.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Flow/Functions/FlowUpdate.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Illumanation/Functions/RGBUpdate.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Illumanation/Functions/SunUpdate.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Illumanation/Functions/WorldSun.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Illumanation/IlluminationManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Propagation.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Tasks/ConstructorTasks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Tasks/Functions/VoxelUpdate.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Tasks/TasksRequest.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Threads/ConstrcutorTheads.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Threads/ConstructorThreadState.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Tools/WorldGenBrush.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/WorldGeneration/Register/WorldGenRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/WorldGeneration/WorldGeneration.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataSyncNode.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Shapes/StairStates.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Global/Util/UtilMap.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Global/Util/VisistedMap.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Constants/Faces.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Brush/Brush.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Shaders/VoxelShaderData.js","webpack://dve-testing/webpack/bootstrap","webpack://dve-testing/webpack/runtime/async module","webpack://dve-testing/webpack/runtime/chunk loaded","webpack://dve-testing/webpack/runtime/define property getters","webpack://dve-testing/webpack/runtime/ensure chunk","webpack://dve-testing/webpack/runtime/get javascript chunk filename","webpack://dve-testing/webpack/runtime/global","webpack://dve-testing/webpack/runtime/hasOwnProperty shorthand","webpack://dve-testing/webpack/runtime/make namespace object","webpack://dve-testing/webpack/runtime/publicPath","webpack://dve-testing/webpack/runtime/importScripts chunk loading","webpack://dve-testing/webpack/runtime/startup chunk dependencies","webpack://dve-testing/webpack/before-startup","webpack://dve-testing/webpack/startup","webpack://dve-testing/webpack/after-startup"],"sourcesContent":["import { $RegisterVoxelConstructors } from \"../../core/data/client/Functions/RegisterVoxelConstructors.js\";\r\nimport { DVEC } from \"divine-voxel-engine/Constructor\";\r\nimport { WorldGenerator } from \"../../core/Gen/WorldGenerator\";\r\n$RegisterVoxelConstructors(DVEC);\r\nDVEC.worldGen.setWorldGen(WorldGenerator);\r\nawait DVEC.$INIT();\r\n","import { DVEC } from \"divine-voxel-engine/Constructor\";\r\nimport { VoxelMath } from \"divine-voxel-engine/Math\";\r\nimport { PerlinNoise3d } from \"divine-rng\";\r\nimport { IndexedRNG } from \"divine-rng\";\r\nimport { GenerateDimensionTemple } from \"../../Structures/Temples/DimensoinTemple.js\";\r\nimport { GenerateTree } from \"../../Functions/Tree.js\";\r\nconst perlin = new PerlinNoise3d();\r\nconst perlin2 = new PerlinNoise3d();\r\nconst bioneNoise = new PerlinNoise3d();\r\n/*\r\nperlin.noiseSeed(12341234);\r\nperlin2.noiseSeed(989989989);\r\nbioneNoise.noiseSeed(59695022384);\r\n*/\r\nconst indexRNG = new IndexedRNG(2934782394782372);\r\nperlin.noiseSeed(2934782394782372);\r\nperlin2.noiseSeed(89898778990878798);\r\nbioneNoise.noiseSeed(7890878787788789987);\r\nconst waveLength = 100;\r\nconst xOffSet = 1_000;\r\nconst zOffSet = 1_000;\r\nconst brush = DVEC.worldGen.getBrush();\r\nconst dataTool = brush._dt;\r\nconst elysianDimensionVoxels = {\r\n    stone: \"ecd_elysian_stone\",\r\n    grass: \"ecd_elysian_grass\",\r\n    water: \"ecd_elysian_ether\",\r\n    vine: \"ecd_elysian_hangingvine\",\r\n};\r\nconst inNoiseRange = (x, y, z) => {\r\n    if (y > 128)\r\n        return false;\r\n    const r = perlin2.get((x + xOffSet) / 14, y / 20, (z + zOffSet) / 14) * 0.2;\r\n    if (y > 30) {\r\n        const n = perlin2.get((x + xOffSet) / 100, y / 100, (z + zOffSet) / 100) *\r\n            (MainWorldGen.height + 50);\r\n        return r > 0.1 && r < 0.8 && y <= n;\r\n    }\r\n    const n = perlin2.get((x + xOffSet) / 50, y / 100, (z + zOffSet) / 200) * 50;\r\n    return y <= n || (r > 0.1 && r < 0.8);\r\n};\r\nexport const MainWorldGen = {\r\n    depth: 16,\r\n    width: 16,\r\n    height: 128,\r\n    generateCircle(vox, x, y, z, radius, skipCenter = false, noDestory = false) {\r\n        let rx = x - radius;\r\n        let rz = z - radius;\r\n        brush.setId(vox);\r\n        for (let ix = rx; ix <= x + radius; ix++) {\r\n            for (let iz = rz; iz <= z + radius; iz++) {\r\n                if (skipCenter) {\r\n                    if (ix == x && iz == z)\r\n                        continue;\r\n                }\r\n                if (noDestory) {\r\n                    if (dataTool.loadInAt(ix, y, iz)) {\r\n                        if (dataTool.isRenderable())\r\n                            continue;\r\n                    }\r\n                }\r\n                if (VoxelMath.distance2D(ix, x, iz, z) < radius) {\r\n                    brush.setXYZ(ix, y, iz).paint();\r\n                }\r\n            }\r\n        }\r\n    },\r\n    generate([dimension, columnX, columnY, columnZ], data) {\r\n        brush.setDimension(dimension).start();\r\n        let makeTeple = false;\r\n        let madeTemple = false;\r\n        let makeVine = false;\r\n        let makeWaterFall = false;\r\n        let templeFlip = indexRNG.get(columnX * (columnY + 3) * columnZ);\r\n        if (templeFlip > 0.98 && !madeTemple) {\r\n            makeTeple = true;\r\n            madeTemple = true;\r\n        }\r\n        const dataTool = brush._dt;\r\n        let totalTrees = 0;\r\n        for (let x = columnX; x < this.width + columnX; x++) {\r\n            for (let z = columnZ; z < this.depth + columnZ; z++) {\r\n                let voxels = elysianDimensionVoxels;\r\n                let flip = indexRNG.get(x * (columnY + 1) * z);\r\n                let vineHeight = 0;\r\n                makeVine = false;\r\n                makeWaterFall = false;\r\n                if (flip > 0.97 && inNoiseRange(x, this.height - 10, z)) {\r\n                    vineHeight = (50 * Math.random()) >> 0;\r\n                    makeVine = true;\r\n                }\r\n                flip = indexRNG.get(x * (columnY + 2) * z);\r\n                if (flip > 0.99 && !makeVine && inNoiseRange(x, this.height - 10, z)) {\r\n                    makeWaterFall = true;\r\n                }\r\n                for (let y = 0; y < this.height + 10; y++) {\r\n                    if (dataTool.loadInAt(x, y, z)) {\r\n                        if (dataTool.isRenderable())\r\n                            continue;\r\n                    }\r\n                    if (y == 0) {\r\n                        brush.setId(\"ecd_immutable\").setXYZ(x, y, z).paint();\r\n                        continue;\r\n                    }\r\n                    if (inNoiseRange(x, y, z)) {\r\n                        if (y > 50 + vineHeight)\r\n                            makeVine = false;\r\n                        brush.setId(voxels.stone);\r\n                        brush.setXYZ(x, y, z).paint();\r\n                    }\r\n                    else {\r\n                        if (makeTeple &&\r\n                            y > 40 &&\r\n                            inNoiseRange(x, y - 1, z) &&\r\n                            !inNoiseRange(x + 7, y + 1, z + 7)) {\r\n                            GenerateDimensionTemple(brush, x, y, z, \"crimson\");\r\n                            makeTeple = false;\r\n                            continue;\r\n                        }\r\n                        if (y > 70 && inNoiseRange(x, y - 1, z) && totalTrees < 3) {\r\n                            if (indexRNG.get(x * y * z) > 0.98) {\r\n                                GenerateTree(brush, x, y, z, \"ecd_elysian_log\", \"ecd_elysian_leafs\");\r\n                                totalTrees++;\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (y > 40 && inNoiseRange(x, y - 1, z)) {\r\n                            if (indexRNG.get(x * y * z) > 0.93) {\r\n                                brush.setId(voxels.grass).setXYZ(x, y, z).paint();\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (makeWaterFall) {\r\n                            if (y > 40 && y < this.height - 10) {\r\n                                if (inNoiseRange(x, y + 1, z)) {\r\n                                    brush.setId(voxels.water).setXYZ(x, y, z).paint();\r\n                                    makeWaterFall = false;\r\n                                    continue;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (makeVine) {\r\n                            if (y > 50 + vineHeight) {\r\n                                brush.setId(voxels.vine).setXYZ(x, y, z).paint();\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (y <= 40) {\r\n                            brush.setId(voxels.water).setXYZ(x, y, z).paint();\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        brush.stop();\r\n    },\r\n};\r\n","import { Distance2D } from \"divine-voxel-engine/Math\";\r\nexport function GenerateCircle(brush, voxel, sx, sy, sz, radius, skipCenter = false, noDestory = false) {\r\n    let rx = sx - radius;\r\n    let rz = sz - radius;\r\n    brush.setId(voxel);\r\n    const dataTool = brush._dt;\r\n    for (let ix = rx; ix <= sx + radius; ix++) {\r\n        for (let iz = rz; iz <= sz + radius; iz++) {\r\n            if (skipCenter) {\r\n                if (ix == sx && iz == sz)\r\n                    continue;\r\n            }\r\n            if (noDestory) {\r\n                if (dataTool.loadInAt(ix, sy, iz)) {\r\n                    if (dataTool.isRenderable())\r\n                        continue;\r\n                }\r\n            }\r\n            if (Distance2D(ix, sx, iz, sz) < radius) {\r\n                brush.setXYZ(ix, sy, iz).paint();\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { StairStates } from \"divine-voxel-engine/Data/Shapes/StairStates.js\";\r\nexport function GenerateStairPillar(brush, sx, sy, sz, height, stairId, pillarId) {\r\n    brush\r\n        .setId(stairId)\r\n        .setXYZ(sx - 1, sy, sz)\r\n        .setShapeState(StairStates.normal.bottom.east)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy, sz)\r\n        .setShapeState(StairStates.normal.bottom.west)\r\n        .paint()\r\n        .setXYZ(sx, sy, sz - 1)\r\n        .setShapeState(StairStates.normal.bottom.north)\r\n        .paint()\r\n        .setXYZ(sx, sy, sz + 1)\r\n        .setShapeState(StairStates.normal.bottom.south)\r\n        .paint()\r\n        .setXYZ(sx - 1, sy, sz - 1)\r\n        .setShapeState(StairStates.connected.bottom.northEast)\r\n        .paint()\r\n        .setXYZ(sx - 1, sy, sz + 1)\r\n        .setShapeState(StairStates.connected.bottom.southEast)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy, sz - 1)\r\n        .setShapeState(StairStates.connected.bottom.northWest)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy, sz + 1)\r\n        .setShapeState(StairStates.connected.bottom.southWest)\r\n        .paint()\r\n        .setXYZ(sx - 1, sy + height, sz)\r\n        .setShapeState(StairStates.normal.top.east)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy + height, sz)\r\n        .setShapeState(StairStates.normal.top.west)\r\n        .paint()\r\n        .setXYZ(sx, sy + height, sz - 1)\r\n        .setShapeState(StairStates.normal.top.north)\r\n        .paint()\r\n        .setXYZ(sx, sy + height, sz + 1)\r\n        .setShapeState(StairStates.normal.top.south)\r\n        .paint()\r\n        .setXYZ(sx - 1, sy + height, sz - 1)\r\n        .setShapeState(StairStates.connected.top.northEast)\r\n        .paint()\r\n        .setXYZ(sx - 1, sy + height, sz + 1)\r\n        .setShapeState(StairStates.connected.top.southEast)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy + height, sz - 1)\r\n        .setShapeState(StairStates.connected.top.northWest)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy + height, sz + 1)\r\n        .setShapeState(StairStates.connected.top.southWest)\r\n        .paint();\r\n    brush.setId(pillarId).setShapeState(0);\r\n    let i = sy + height;\r\n    while (i > sy) {\r\n        brush.setXYZ(sx, i, sz).paint();\r\n        i--;\r\n    }\r\n    brush.setShapeState(0);\r\n}\r\n","import { StairStates } from \"divine-voxel-engine/Data/Shapes/StairStates\";\r\nexport function GenerateStairRoof(brush, sx, sy, sz, width, depth, height, stairId) {\r\n    brush.setId(stairId);\r\n    let c = 0;\r\n    for (let y = sy; y < sy + height; y++) {\r\n        let startX = sx + c;\r\n        let endX = sx + width - c;\r\n        let startZ = sz + c;\r\n        let endZ = sz + depth - c;\r\n        for (let x = startX; x < endX; x++) {\r\n            for (let z = startZ; z < endZ; z++) {\r\n                brush.setXYZ(x, y, z);\r\n                if (x == startX && z == startZ) {\r\n                    brush.setShapeState(StairStates.connected.bottom.northEast).paint();\r\n                    continue;\r\n                }\r\n                if (x == startX && z == endZ - 1) {\r\n                    brush.setShapeState(StairStates.connected.bottom.southEast).paint();\r\n                    continue;\r\n                }\r\n                if (x == endX - 1 && z == startZ) {\r\n                    brush.setShapeState(StairStates.connected.bottom.northWest).paint();\r\n                    continue;\r\n                }\r\n                if (x == endX - 1 && z == endZ - 1) {\r\n                    brush.setShapeState(StairStates.connected.bottom.southWest).paint();\r\n                    continue;\r\n                }\r\n                if (x == startX) {\r\n                    brush.setShapeState(StairStates.normal.bottom.east).paint();\r\n                    continue;\r\n                }\r\n                if (x == endX - 1) {\r\n                    brush.setShapeState(StairStates.normal.bottom.west).paint();\r\n                    continue;\r\n                }\r\n                if (z == startZ) {\r\n                    brush.setShapeState(StairStates.normal.bottom.north).paint();\r\n                    continue;\r\n                }\r\n                if (z == endZ - 1) {\r\n                    brush.setShapeState(StairStates.normal.bottom.south).paint();\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        c++;\r\n    }\r\n    brush.setShapeState(0);\r\n}\r\n","import { VisitAll } from \"divine-voxel-engine/Math\";\r\nimport { GenerateCircle } from \"./Circle.js\";\r\nconst start = { x: 0, y: 0, z: 0 };\r\nconst end = { x: 0, y: 0, z: 0 };\r\nexport function GenerateTree(brush, sx, sy, sz, logId, leafId) {\r\n    const height = ((Math.random() * 15) >> 0) + 5;\r\n    const rx = ((sx - 5 + Math.random() * 10) >> 0) + 1;\r\n    const rz = ((sz - 5 + Math.random() * 10) >> 0) + 1;\r\n    start.x = sx;\r\n    start.y = sy;\r\n    start.z = sz;\r\n    end.x = rx;\r\n    end.y = sy + height;\r\n    end.z = rz;\r\n    brush.setId(logId);\r\n    let c = 0;\r\n    const voxels = VisitAll(start, end, (x, y, z) => {\r\n        c++;\r\n        if (c > 50) {\r\n            end.x = x;\r\n            end.y = y;\r\n            end.z = z;\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n    for (let i = 0; i < voxels.length; i += 3) {\r\n        const x = voxels[i];\r\n        const y = voxels[i + 1];\r\n        const z = voxels[i + 2];\r\n        brush.setXYZ(x, y, z).paint();\r\n    }\r\n    let capHeight = ((Math.random() * 10) >> 0) + 1;\r\n    if (capHeight < 4)\r\n        capHeight = 4;\r\n    let i = capHeight;\r\n    let radius = 1;\r\n    while (i--) {\r\n        brush.setId(logId);\r\n        if (i == capHeight - 1) {\r\n            brush.setId(leafId);\r\n        }\r\n        brush.setXYZ(end.x, end.y + i, end.z).paint();\r\n        GenerateCircle(brush, leafId, end.x, end.y + i, end.z, radius, true, true);\r\n        radius++;\r\n    }\r\n}\r\n","import { GenerateStairPillar } from \"../../Functions/StairPillar.js\";\r\nimport { GenerateStairRoof } from \"../../Functions/StairRoof.js\";\r\nconst DimensionTempleVoxels = {\r\n    crimson: {\r\n        stone: \"ecd_crimson_star_stone\",\r\n        stair: \"ecd_crimson_star_stone_stair\",\r\n        lamp: \"ecd_crimson_lamp\",\r\n        ether: \"ecd_crimson_ether\",\r\n    },\r\n};\r\n/*\r\necd_crimson_star_stone\r\necd_crimson_lamp\r\necd_crimson_ether\r\n*/\r\nexport function GenerateDimensionTemple(brush, sx, sy, sz, templeDimension) {\r\n    const dimensionData = DimensionTempleVoxels[templeDimension];\r\n    if (!dimensionData)\r\n        return false;\r\n    const dataTool = brush._dt;\r\n    const width = 16;\r\n    const depth = 16;\r\n    for (let x = sx; x < sx + width; x++) {\r\n        for (let z = sz; z < sz + depth; z++) {\r\n            for (let y = sy; y > 0; y--) {\r\n                if (dataTool.loadInAt(x, y, z)) {\r\n                    if (dataTool.isOpaque())\r\n                        continue;\r\n                }\r\n                brush.setXYZ(x, y, z);\r\n                if (y > sy - 5) {\r\n                    if ((x == sx + 7 && z == sz + 7) ||\r\n                        (x == sx + 8 && z == sz + 8) ||\r\n                        (x == sx + 7 && z == sz + 8) ||\r\n                        (x == sx + 8 && z == sz + 7)) {\r\n                        brush.setId(dimensionData.stone).paint();\r\n                        continue;\r\n                    }\r\n                    if (x >= sx + 4 && z >= sz + 4 && x <= sx + 11 && z <= sz + 11) {\r\n                        brush.setId(dimensionData.ether).paint();\r\n                        continue;\r\n                    }\r\n                }\r\n                brush.setId(dimensionData.stone).paint();\r\n            }\r\n        }\r\n    }\r\n    for (let x = sx; x < sx + width; x++) {\r\n        for (let z = sz; z < sz + depth; z++) {\r\n            for (let y = sy; y < sy + 10; y++) {\r\n                if (dataTool.loadInAt(x, y, z)) {\r\n                    if (dataTool.isOpaque())\r\n                        continue;\r\n                }\r\n                brush.setXYZ(x, y, z);\r\n                if ((x == sx + 7 && z == sz + 7) ||\r\n                    (x == sx + 8 && z == sz + 8) ||\r\n                    (x == sx + 7 && z == sz + 8) ||\r\n                    (x == sx + 8 && z == sz + 7)) {\r\n                    if (y == sy + 9) {\r\n                        brush.setId(dimensionData.lamp).paint();\r\n                        brush\r\n                            .setXYZ(x, y + 1, z)\r\n                            .setId(dimensionData.ether)\r\n                            .paint();\r\n                        continue;\r\n                    }\r\n                    brush.setId(dimensionData.stone).paint();\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    GenerateStairPillar(brush, sx + 1, sy + 1, sz + 1, 10, dimensionData.stair, dimensionData.stone);\r\n    GenerateStairPillar(brush, sx + 14, sy + 1, sz + 1, 10, dimensionData.stair, dimensionData.stone);\r\n    GenerateStairPillar(brush, sx + 1, sy + 1, sz + 14, 10, dimensionData.stair, dimensionData.stone);\r\n    GenerateStairPillar(brush, sx + 14, sy + 1, sz + 14, 10, dimensionData.stair, dimensionData.stone);\r\n    GenerateStairRoof(brush, sx, sy + 12, sz, 16, 16, 10, dimensionData.stair);\r\n}\r\n","import { MainWorldGen } from \"./Dimensions/Main/MainWorldGen.js\";\r\nexport const WorldGenerator = {\r\n    async generate([location, data]) {\r\n        if (location[0] == \"main\") {\r\n            //  TestWorldGen.generate(dimension, x, y, z, data);\r\n            MainWorldGen.generate(location, data);\r\n        }\r\n    },\r\n    async decorate([location, data]) {\r\n        if (location[0] == \"main\") {\r\n            //  TestWorldGen.generate(dimension, x, y, z, data);\r\n        }\r\n    },\r\n};\r\n","//types\r\n//voxels\r\nimport { GetLightDebugBox } from \"../Voxels/LightDebugBox\";\r\nimport { GetMarkerBox } from \"../Voxels/MarkerBox\";\r\nimport { GetDreamEther } from \"../Voxels/LiquidDreamEther\";\r\nexport function $RegisterVoxelConstructors(DVEC) {\r\n    GetLightDebugBox(DVEC);\r\n    GetMarkerBox(DVEC);\r\n    GetDreamEther(DVEC);\r\n    const vm = DVEC.voxelManager;\r\n    vm.registerVoxel([\r\n        //debug\r\n        vm.defaults.box.simple(\"dve_debug_box\", {\r\n            top: [\"#dve_solid\", \"dve_debug_box\", \"top\"],\r\n            bottom: [\"#dve_solid\", \"dve_debug_box\", \"bottom\"],\r\n            north: [\"#dve_solid\", \"dve_debug_box\", \"north\"],\r\n            south: [\"#dve_solid\", \"dve_debug_box\", \"south\"],\r\n            east: [\"#dve_solid\", \"dve_debug_box\", \"east\"],\r\n            west: [\"#dve_solid\", \"dve_debug_box\", \"west\"],\r\n        }),\r\n        vm.defaults.box.simple(\"dve_data_holder\", [\r\n            \"#dve_solid\",\r\n            \"dve_data_holder\",\r\n            \"front\",\r\n        ]),\r\n        //dream\r\n        vm.defaults.box.simple(\"dve_dream_grass_block\", [\r\n            \"#dve_flora\",\r\n            \"dve_dream_grass_block\",\r\n            \"grassy-top\",\r\n        ]),\r\n        vm.defaults.box.pillar(\"dve_dream_stone_pillar\", {\r\n            top: [\"#dve_solid\", \"dve_dream_stone_pillar\", \"top\"],\r\n            bottom: [\"#dve_solid\", \"dve_dream_stone_pillar\", \"top\"],\r\n            sideBottom: [\"#dve_solid\", \"dve_dream_stone_pillar\", \"side-bottom\"],\r\n            sideMiddle: [\"#dve_solid\", \"dve_dream_stone_pillar\"],\r\n            sideTop: [\"#dve_solid\", \"dve_dream_stone_pillar\", \"side-top\"],\r\n            sideFloat: [\"#dve_solid\", \"dve_dream_stone_pillar\", \"top\"],\r\n        }),\r\n        vm.defaults.box.pillar(\"dve_dream_stone\", {\r\n            top: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-top\"],\r\n            bottom: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideBottom: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideMiddle: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideTop: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-side\"],\r\n            sideFloat: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-side\"],\r\n        }),\r\n        vm.defaults.box.simple(\"dve_dream_lamp\", [\"#dve_solid\", \"dve_dream_lamp\"]),\r\n        vm.defaults.box.pillar(\"dve_dream_stone_slab\", {\r\n            top: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-top\"],\r\n            bottom: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideBottom: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideMiddle: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideTop: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-side\"],\r\n            sideFloat: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-side\"],\r\n        }),\r\n        vm.defaults.box.simple(\"dve_dream_log\", [\"#dve_solid\", \"dve_dream_log\"]),\r\n        vm.defaults.box.simple(\"dve_dream_stone_stair\", [\r\n            \"#dve_solid\",\r\n            \"dve_dream_stone\",\r\n        ]),\r\n        vm.defaults.crossedPanel.simple(\"dve_dream_grass\", [\r\n            \"#dve_flora\",\r\n            \"dve_dream_grass\",\r\n        ]),\r\n        vm.defaults.panel.simple(\"dve_dream_vine\", [\r\n            \"#dve_flora\",\r\n            \"dve_dream_vine\",\r\n        ]),\r\n        vm.defaults.box.simple(\"dve_dream_leaves\", [\r\n            \"#dve_flora\",\r\n            \"dve_dream_leaves\",\r\n        ]),\r\n        //dread\r\n        vm.defaults.box.pillar(\"dve_dread_stone_pillar\", {\r\n            top: [\"#dve_solid\", \"dve_dread_stone_pillar\", \"top\"],\r\n            bottom: [\"#dve_solid\", \"dve_dread_stone_pillar\", \"top\"],\r\n            sideBottom: [\"#dve_solid\", \"dve_dread_stone_pillar\", \"side-bottom\"],\r\n            sideMiddle: [\"#dve_solid\", \"dve_dread_stone_pillar\"],\r\n            sideTop: [\"#dve_solid\", \"dve_dread_stone_pillar\", \"side-top\"],\r\n            sideFloat: [\"#dve_solid\", \"dve_dread_stone_pillar\", \"top\"],\r\n        }),\r\n        vm.defaults.box.pillar(\"dve_dread_stone\", {\r\n            top: [\"#dve_solid\", \"dve_dread_stone\", \"grassy-top\"],\r\n            bottom: [\"#dve_solid\", \"dve_dread_stone\"],\r\n            sideBottom: [\"#dve_solid\", \"dve_dread_stone\"],\r\n            sideMiddle: [\"#dve_solid\", \"dve_dread_stone\"],\r\n            sideTop: [\"#dve_solid\", \"dve_dread_stone\", \"grassy-side\"],\r\n            sideFloat: [\"#dve_solid\", \"dve_dread_stone\", \"grassy-side\"],\r\n        }),\r\n        vm.defaults.box.simple(\"dve_dread_lamp\", [\"#dve_solid\", \"dve_dread_lamp\"]),\r\n        vm.defaults.liquid.simple(\"dve_liquid_dread_ether\", [\r\n            [\"#dve_liquid\", \"dve_liquid_dread_ether\", \"still-1\"],\r\n            [\"#dve_liquid\", \"dve_liquid_dread_ether\", \"still-1\"],\r\n        ]),\r\n        vm.defaults.crossedPanel.simple(\"dve_dread_grass\", [\r\n            \"#dve_solid\",\r\n            \"dve_dread_grass\",\r\n        ]),\r\n    ]);\r\n}\r\n","import { BoxVoxelShape } from \"divine-voxel-engine/Constructor\";\r\nconst getData = (dataTool, x, y, z) => {\r\n    let data = 0;\r\n    if (dataTool.loadInAt(x, y, z)) {\r\n        data = dataTool.getLight();\r\n    }\r\n    return data;\r\n};\r\nexport function GetLightDebugBox(DVEC) {\r\n    const textures = [];\r\n    return DVEC.voxelManager.registerVoxel({\r\n        id: \"dve_light_debug\",\r\n        onTexturesRegistered(textureMangager) {\r\n            for (let i = 0; i < 16; i++) {\r\n                textures.push(textureMangager.getTextureUV([\r\n                    \"#dve_solid\",\r\n                    \"dve_light_debug\",\r\n                    `light-level-${i}`,\r\n                ]));\r\n            }\r\n        },\r\n        process(tool) {\r\n            const [dimension, x, y, z] = tool.voxel.getLocation();\r\n            const dt = tool.nVoxel;\r\n            if (tool.isFaceExposed(\"top\")) {\r\n                tool\r\n                    .setTexture(textures[getData(dt, x, y + 1, z) || 0])\r\n                    .calculateLight(\"top\");\r\n                BoxVoxelShape.add.top();\r\n            }\r\n            if (tool.isFaceExposed(\"bottom\")) {\r\n                tool\r\n                    .setTexture(textures[getData(dt, x, y - 1, z) || 0])\r\n                    .calculateLight(\"bottom\");\r\n                BoxVoxelShape.add.bottom();\r\n            }\r\n            if (tool.isFaceExposed(\"east\")) {\r\n                tool\r\n                    .setTexture(textures[getData(dt, x + 1, y, z) || 0])\r\n                    .calculateLight(\"east\");\r\n                BoxVoxelShape.add.east();\r\n            }\r\n            if (tool.isFaceExposed(\"west\")) {\r\n                tool\r\n                    .setTexture(textures[getData(dt, x - 1, y, z) || 0])\r\n                    .calculateLight(\"west\");\r\n                BoxVoxelShape.add.west();\r\n            }\r\n            if (tool.isFaceExposed(\"south\")) {\r\n                tool\r\n                    .setTexture(textures[getData(dt, x, y, z - 1) || 0])\r\n                    .calculateLight(\"south\");\r\n                BoxVoxelShape.add.south();\r\n            }\r\n            if (tool.isFaceExposed(\"north\")) {\r\n                tool\r\n                    .setTexture(textures[getData(dt, x, y, z + 1) || 0])\r\n                    .calculateLight(\"north\");\r\n                BoxVoxelShape.add.north();\r\n            }\r\n        },\r\n    });\r\n}\r\n","import { LiquidVoxelShape, } from \"divine-voxel-engine/Constructor\";\r\nimport { OutlinedVoxelTool } from \"divine-voxel-engine/Constructor/Builder/Tools/OutlinedVoxelTool.js\";\r\nexport function GetDreamEther(DVEC) {\r\n    let uv = 0;\r\n    let overlayTextures = [];\r\n    DVEC.voxelManager.registerVoxel({\r\n        id: \"dve_liquid_dream_ether\",\r\n        onTexturesRegistered(textureMangager) {\r\n            uv = textureMangager.getTextureUV([\r\n                \"#dve_liquid\",\r\n                \"dve_liquid_dream_ether\",\r\n                \"still-1\",\r\n            ]);\r\n            OutlinedVoxelTool.getOutlineUVs([\"#dve_liquid\", \"foam\", \"top\"], (textures) => {\r\n                overlayTextures = textures;\r\n            });\r\n        },\r\n        process(tool) {\r\n            OutlinedVoxelTool.setCurrentTextures(overlayTextures);\r\n            LiquidVoxelShape.start();\r\n            tool.getOverlayTextures().setAll(0);\r\n            if (tool.isFaceExposed(\"top\")) {\r\n                tool.setTexture(uv).calculateLight(\"top\");\r\n                if (tool.voxel.getLevel() == 15 && tool.voxel.getLevelState() != 1) {\r\n                    OutlinedVoxelTool.addTo.top(tool);\r\n                }\r\n                LiquidVoxelShape.add.top();\r\n            }\r\n            tool.getOverlayTextures().setAll(0);\r\n            if (tool.isFaceExposed(\"bottom\")) {\r\n                tool.setTexture(uv).calculateLight(\"bottom\");\r\n                LiquidVoxelShape.add.bottom();\r\n            }\r\n            if (tool.isFaceExposed(\"east\")) {\r\n                tool.setTexture(uv).calculateLight(\"east\");\r\n                LiquidVoxelShape.add.east();\r\n            }\r\n            if (tool.isFaceExposed(\"west\")) {\r\n                tool.setTexture(uv).calculateLight(\"west\");\r\n                LiquidVoxelShape.add.west();\r\n            }\r\n            if (tool.isFaceExposed(\"south\")) {\r\n                tool.setTexture(uv).calculateLight(\"south\");\r\n                LiquidVoxelShape.add.south();\r\n            }\r\n            if (tool.isFaceExposed(\"north\")) {\r\n                tool.setTexture(uv).calculateLight(\"north\");\r\n                LiquidVoxelShape.add.north();\r\n            }\r\n        },\r\n    });\r\n}\r\n","import { BoxVoxelShape, } from \"divine-voxel-engine/Constructor\";\r\nexport function GetMarkerBox(DVEC) {\r\n    const textures = [];\r\n    return DVEC.voxelManager.registerVoxel({\r\n        id: \"dve_marker_box\",\r\n        onTexturesRegistered(textureMangager) {\r\n            for (let i = 0; i < 16; i++) {\r\n                textures.push(textureMangager.getTextureUV([\r\n                    \"#dve_solid\",\r\n                    \"dve_light_debug\",\r\n                    `light-level-${i}`,\r\n                ]));\r\n            }\r\n        },\r\n        process(tool) {\r\n            const uv = textures[tool.voxel.getState()];\r\n            tool.getOverlayTextures().setAll(0);\r\n            if (tool.isFaceExposed(\"top\")) {\r\n                tool.setTexture(uv).calculateLight(\"top\");\r\n                BoxVoxelShape.add.top();\r\n            }\r\n            if (tool.isFaceExposed(\"bottom\")) {\r\n                tool.setTexture(uv).calculateLight(\"bottom\");\r\n                BoxVoxelShape.add.bottom();\r\n            }\r\n            if (tool.isFaceExposed(\"east\")) {\r\n                tool.setTexture(uv).calculateLight(\"east\");\r\n                BoxVoxelShape.add.east();\r\n            }\r\n            if (tool.isFaceExposed(\"west\")) {\r\n                tool.setTexture(uv).calculateLight(\"west\");\r\n                BoxVoxelShape.add.west();\r\n            }\r\n            if (tool.isFaceExposed(\"south\")) {\r\n                tool.setTexture(uv).calculateLight(\"south\");\r\n                BoxVoxelShape.add.south();\r\n            }\r\n            if (tool.isFaceExposed(\"north\")) {\r\n                tool.setTexture(uv).calculateLight(\"north\");\r\n                BoxVoxelShape.add.north();\r\n            }\r\n        },\r\n    });\r\n}\r\n","import { LCG } from \"../seededRandom/LCG.js\";\nexport class IndexedRNG {\n    seed;\n    MAX_VERTICES = 256_000;\n    MAX_VERTICES_MASK = this.MAX_VERTICES - 1;\n    amplitude = 1;\n    scale = 1;\n    r = [];\n    constructor(seed) {\n        this.seed = seed;\n        const lcg = new LCG(seed);\n        for (let i = 0; i < this.MAX_VERTICES; ++i) {\n            this.r.push(lcg.rand());\n        }\n    }\n    get(x) {\n        const scaledX = x * this.scale;\n        const xFloor = Math.floor(scaledX);\n        const t = scaledX - xFloor;\n        const tRemapSmoothstep = t * t * (3 - 2 * t);\n        const xMin = xFloor & this.MAX_VERTICES_MASK;\n        const xMax = (xMin + 1) & this.MAX_VERTICES_MASK;\n        const y = this._lerp(this.r[xMin], this.r[xMax], tRemapSmoothstep);\n        return y * this.amplitude;\n    }\n    _lerp(a, b, t) {\n        return a * (1 - t) + b * t;\n    }\n}\n","export * from \"./IndexedRNG/index.js\";\nexport * from \"./perlin/index.js\";\nexport * from \"./seededRandom/index.js\";\n","/**# Perlin Noise 3d\n * ---\n * TypeScript version of the library found here:\n * https://github.com/alterebro/perlin-noise-3d\n */\nexport class PerlinNoise3d {\n    // Based on http://mrl.nyu.edu/~perlin/noise/\n    // Adapting from runemadsen/rune.noise.js\n    // Which was adapted from P5.js\n    // Which was adapted from PApplet.java\n    // which was adapted from toxi\n    // which was adapted from the german demo group farbrausch as used in their demo \"art\": http://www.farb-rausch.de/fr010src.zip\n    PERLIN_YWRAPB = 4;\n    PERLIN_YWRAP = 1 << this.PERLIN_YWRAPB;\n    PERLIN_ZWRAPB = 8;\n    PERLIN_ZWRAP = 1 << this.PERLIN_ZWRAPB;\n    PERLIN_SIZE = 4095;\n    SINCOS_PRECISION = 0.5;\n    SINCOS_LENGTH = Math.floor(360 / this.SINCOS_PRECISION);\n    sinLUT = new Array(this.SINCOS_LENGTH);\n    cosLUT = new Array(this.SINCOS_LENGTH);\n    DEG_TO_RAD = Math.PI / 180.0;\n    perlin_octaves = 4; // default to medium smooth\n    perlin_amp_falloff = 0.5; // 50% reduction/octave\n    perlin = null;\n    perlin_PI = this.SINCOS_LENGTH;\n    constructor() {\n        this.perlin_PI >>= 1;\n        for (let i = 0; i < this.SINCOS_LENGTH; i++) {\n            this.sinLUT[i] = Math.sin(i * this.DEG_TO_RAD * this.SINCOS_PRECISION);\n            this.cosLUT[i] = Math.cos(i * this.DEG_TO_RAD * this.SINCOS_PRECISION);\n        }\n    }\n    lcg() {\n        // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes\n        // m is basically chosen to be large (as it is the max period)\n        // and for its relationships to a and c\n        let m = 4294967296, \n        // a - 1 should be divisible by m's prime factors\n        a = 1664525, \n        // c and m should be co-prime\n        c = 1013904223, seed, z;\n        return {\n            setSeed: function (val) {\n                // pick a random seed if val is undefined or null\n                // the >>> 0 casts the seed to an unsigned 32-bit integer\n                z = seed = (val == null ? Math.random() * m : val) >>> 0;\n            },\n            getSeed: function () {\n                return seed;\n            },\n            rand: function () {\n                // define the recurrence relationship\n                z = (a * z + c) % m;\n                // return a float in [0, 1)\n                // if z = m then z / m = 0 therefore (z % m) / m < 1 always\n                return z / m;\n            },\n        };\n    }\n    noiseSeed(seed) {\n        // Linear Congruential Generator\n        // Variant of a Lehman Generator\n        const lcg = this.lcg();\n        lcg.setSeed(seed);\n        this.perlin = new Array(this.PERLIN_SIZE + 1);\n        for (let i = 0; i < this.PERLIN_SIZE + 1; i++) {\n            this.perlin[i] = lcg.rand();\n        }\n        return this;\n    }\n    noise_fsc(i) {\n        // using cosine lookup table\n        return (0.5 *\n            (1.0 - this.cosLUT[Math.floor(i * this.perlin_PI) % this.SINCOS_LENGTH]));\n    }\n    get(x, y, z) {\n        y = y || 0;\n        z = z || 0;\n        if (this.perlin == null) {\n            this.perlin = new Array(this.PERLIN_SIZE + 1);\n            for (let i = 0; i < this.PERLIN_SIZE + 1; i++) {\n                this.perlin[i] = Math.random();\n            }\n        }\n        if (x < 0) {\n            x = -x;\n        }\n        if (y < 0) {\n            y = -y;\n        }\n        if (z < 0) {\n            z = -z;\n        }\n        let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);\n        let xf = x - xi;\n        let yf = y - yi;\n        let zf = z - zi;\n        let rxf, ryf;\n        let r = 0;\n        let ampl = 0.5;\n        let n1, n2, n3;\n        for (let o = 0; o < this.perlin_octaves; o++) {\n            let of = xi + (yi << this.PERLIN_YWRAPB) + (zi << this.PERLIN_ZWRAPB);\n            rxf = this.noise_fsc(xf);\n            ryf = this.noise_fsc(yf);\n            n1 = this.perlin[of & this.PERLIN_SIZE];\n            n1 += rxf * (this.perlin[(of + 1) & this.PERLIN_SIZE] - n1);\n            n2 = this.perlin[(of + this.PERLIN_YWRAP) & this.PERLIN_SIZE];\n            n2 +=\n                rxf *\n                    (this.perlin[(of + this.PERLIN_YWRAP + 1) & this.PERLIN_SIZE] - n2);\n            n1 += ryf * (n2 - n1);\n            of += this.PERLIN_ZWRAP;\n            n2 = this.perlin[of & this.PERLIN_SIZE];\n            n2 += rxf * (this.perlin[(of + 1) & this.PERLIN_SIZE] - n2);\n            n3 = this.perlin[(of + this.PERLIN_YWRAP) & this.PERLIN_SIZE];\n            n3 +=\n                rxf *\n                    (this.perlin[(of + this.PERLIN_YWRAP + 1) & this.PERLIN_SIZE] - n3);\n            n2 += ryf * (n3 - n2);\n            n1 += this.noise_fsc(zf) * (n2 - n1);\n            r += n1 * ampl;\n            ampl *= this.perlin_amp_falloff;\n            xi <<= 1;\n            xf *= 2;\n            yi <<= 1;\n            yf *= 2;\n            zi <<= 1;\n            zf *= 2;\n            if (xf >= 1.0) {\n                xi++;\n                xf--;\n            }\n            if (yf >= 1.0) {\n                yi++;\n                yf--;\n            }\n            if (zf >= 1.0) {\n                zi++;\n                zf--;\n            }\n        }\n        return r;\n    }\n}\n","/**\n * @class\n * @classdesc Base class all algorithm implementations should inherit from.\n */\nclass Base {\n    /**\n     * Generate a hash from a string that is suitable to use as a seed for any\n     * of the PRNG's that inherit from this.\n     *\n     * @param {string} str\n     * @returns {Function}\n     */\n    static _xfnv1a(str) {\n        let h = 2166136261 >>> 0;\n        for (let i = 0; i < str.length; i++) {\n            h = Math.imul(h ^ str.charCodeAt(i), 16777619);\n        }\n        return () => {\n            h += h << 13;\n            h ^= h >>> 7;\n            h += h << 3;\n            h ^= h >>> 17;\n            return (h += h << 5) >>> 0;\n        };\n    }\n}\nexport default Base;\n","import Base from './Base.js';\n/**\n * @class\n * @classdesc Concrete mulberry32 implementation.\n */\nclass Mulberry32 extends Base {\n    /**\n     * Seed parameter.\n     *\n     * @var {number}\n     */\n    a;\n    /**\n     * Create a new mulberry32 instance.\n     *\n     * @param {string} str\n     */\n    constructor(str) {\n        super();\n        this.a = Mulberry32._xfnv1a(str)();\n    }\n    /**\n     * Generate a random number using the mulberry32 algorithm.\n     *\n     * @returns {number}\n     */\n    next() {\n        let t = (this.a += 0x6d2b79f5);\n        t = Math.imul(t ^ (t >>> 15), t | 1);\n        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n    }\n}\nexport default Mulberry32;\n","import Base from './Base.js';\n/**\n * @class\n * @classdesc Concrete sfc32 implementation.\n */\nclass Sfc32 extends Base {\n    /**\n     * Seed parameters.\n     *\n     * @var {number}\n     */\n    a;\n    b;\n    c;\n    d;\n    /**\n     * Create a new sfc32 instance.\n     *\n     * @param {string} str\n     */\n    constructor(str) {\n        super();\n        // Create the seed for the random number algorithm\n        const seed = Sfc32._xfnv1a(str);\n        this.a = seed();\n        this.b = seed();\n        this.c = seed();\n        this.d = seed();\n    }\n    /**\n     * Generate a random number using the sfc32 algorithm.\n     *\n     * @returns {number}\n     */\n    next() {\n        this.a >>>= 0;\n        this.b >>>= 0;\n        this.c >>>= 0;\n        this.d >>>= 0;\n        let t = (this.a + this.b) | 0;\n        this.a = this.b ^ (this.b >>> 9);\n        this.b = (this.c + (this.c << 3)) | 0;\n        this.c = (this.c << 21) | (this.c >>> 11);\n        this.d = (this.d + 1) | 0;\n        t = (t + this.d) | 0;\n        this.c = (this.c + t) | 0;\n        return (t >>> 0) / 4294967296;\n    }\n}\nexport default Sfc32;\n","import Base from './Base.js';\n/**\n * @class\n * @classdesc Concrete xoshiro128** implementation.\n */\nclass Xoshiro128ss extends Base {\n    /**\n     * Seed parameters.\n     *\n     * @var {number}\n     */\n    a;\n    b;\n    c;\n    d;\n    /**\n     * Create a new xoshiro128** instance.\n     *\n     * @param {string} str\n     */\n    constructor(str) {\n        super();\n        // Create the seed for the random number algorithm\n        const seed = Xoshiro128ss._xfnv1a(str);\n        this.a = seed();\n        this.b = seed();\n        this.c = seed();\n        this.d = seed();\n    }\n    /**\n     * Generate a random number using the xoshiro128** algorithm.\n     *\n     * @returns {number}\n     */\n    next() {\n        const t = this.b << 9;\n        let r = this.a * 5;\n        r = (r << 7) | ((r >>> 25) * 9);\n        this.c ^= this.a;\n        this.d ^= this.b;\n        this.b ^= this.c;\n        this.a ^= this.d;\n        this.c ^= t;\n        this.d = (this.d << 11) | (this.d >>> 21);\n        return (r >>> 0) / 4294967296;\n    }\n}\nexport default Xoshiro128ss;\n","export class LCG {\n    seed;\n    m = 4294967296;\n    a = 1664525;\n    c = 1013904223;\n    z = 0;\n    constructor(seed) {\n        this.seed = seed;\n        this.setSeed(seed);\n    }\n    setSeed(val) {\n        this.z = this.seed = (val == null ? Math.random() * this.m : val) >>> 0;\n    }\n    getSeed() {\n        return this.seed;\n    }\n    rand() {\n        this.z = (this.a * this.z + this.c) % this.m;\n        return this.z / this.m;\n    }\n}\n","import Mulberry32 from './Algorithms/Mulberry32.js';\nimport Sfc32 from './Algorithms/Sfc32.js';\nimport Xoshiro128ss from './Algorithms/Xoshiro128ss.js';\nimport { isNullOrUndefined } from './helpers.js';\n/**\n * Available seedable random number generator algorithms.\n *\n * @var {PRNG}\n */\nexport var PRNG;\n(function (PRNG) {\n    PRNG[\"sfc32\"] = \"sfc32\";\n    PRNG[\"mulberry32\"] = \"mulberry32\";\n    PRNG[\"xoshiro128ss\"] = \"xoshiro128ss\";\n})(PRNG || (PRNG = {}));\n/**\n * A class for generating random numbers. Several different (seedable) random\n * number generator algorithms are configurable.\n *\n * See https://stackoverflow.com/a/47593316/7024747 for more info.\n * @class\n * @classdesc A class for generating random numbers.\n */\nclass Rand {\n    /**\n     * The string that will be used for generating a suitable hash for any of\n     * the provided PRNG algorithms.\n     *\n     * @var {string}\n     */\n    str;\n    /**\n     * The PRNG algorithm that should be used for random number generation.\n     *\n     * @var {PRNG}\n     */\n    prng;\n    /**\n     * The generator that should be used for generating random numbers.\n     *\n     * @var {Function}\n     */\n    generator;\n    /**\n     * Create a new rand instance.\n     *\n     * @param {string} str\n     * @param {PRNG} prng\n     */\n    constructor(str, prng = PRNG.sfc32) {\n        this.str = str;\n        this.prng = prng;\n        this.generator = this._initializeGenerator();\n    }\n    /**\n     * Generate a new random number using the selected generator.\n     *\n     * @returns {number}\n     */\n    next() {\n        return this.generator.next();\n    }\n    /**\n     * Initialize the chosen random number generator.\n     *\n     * @returns {Algorithm|Function}\n     */\n    _initializeGenerator() {\n        if (isNullOrUndefined(this.str))\n            return this.wrap();\n        switch (this.prng) {\n            case 'sfc32':\n                return new Sfc32(this.str);\n            case 'mulberry32':\n                return new Mulberry32(this.str);\n            case 'xoshiro128ss':\n                return new Xoshiro128ss(this.str);\n            default:\n                return this.wrap();\n        }\n    }\n    /**\n     * Wrap the standard random function in an object.\n     *\n     * @returns {Algorithm}\n     */\n    wrap() {\n        return {\n            /**\n             * Generate a random number.\n             *\n             * @return {number}\n             */\n            next() {\n                return Math.random();\n            },\n        };\n    }\n}\nexport default Rand;\n","/**\n * Determine if the given value is undefined.\n *\n * @param {mixed} value\n * @returns {boolean}\n */\nexport const isUndefined = (value) => typeof value === 'undefined';\n/**\n * Determine if the given value is null.\n *\n * @param {mixed} value\n * @returns {boolean}\n */\nexport const isNull = (value) => value === null;\n/**\n * Determine if the given value is null or undefined.\n *\n * @param {mixed} value\n * @returns {boolean}\n */\nexport const isNullOrUndefined = (value) => {\n    return isNull(value) || isUndefined(value);\n};\n","import Rand, { PRNG } from './Rand.js';\nexport default Rand;\nexport { PRNG };\n","export const ConstructorRemoteThreadTasks = {\n    syncShapeMap: -1,\n    addToRebuildQue: 0,\n    runRebuildQue: 1,\n    addToRGBLightUpdateQue: 2,\n    buildChunk: 3\n};\n","export const ConstructorTasks = {\n    buildChunk: 0,\n    buildColumn: 0,\n    generate: 0,\n    decorate: 0,\n    RGBlightUpdate: 0,\n    RGBlightRemove: 0,\n    worldSun: 0,\n    sunLightUpdate: 0,\n    sunLightRemove: 0,\n    analyzerPropagation: 0,\n    analyzerUpdate: 0,\n    flowUpdate: 0,\n    flowRemove: 0,\n    constructEntity: 0,\n    constructItem: 0,\n    explosion: 0,\n    voxelErease: 0,\n    voxelPaint: 0,\n    voxelUpdate: 0,\n};\nlet index = 0;\nfor (const key of Object.keys(ConstructorTasks)) {\n    ConstructorTasks[key] = index;\n    index++;\n}\n","//propagation\nimport { FlowUpdate } from \"../Propagation/Flow/Functions/FlowUpdate.js\";\nimport { Propagation } from \"../Propagation/Propagation.js\";\n//objects\nimport { EngineSettings } from \"../../Data/Settings/EngineSettings.js\";\nimport { DVEC } from \"../../Constructor/DivineVoxelEngineConstructor.js\";\nimport { AnalyzerProcessor } from \"./AnalyzerProcessor.js\";\nimport { AnalyzerUpdater } from \"./AnalyzerUpdater.js\";\nimport { TasksRequest } from \"../Tasks/TasksRequest.js\";\nimport { DataTool } from \"../../Tools/Data/DataTool.js\";\n//tools\nconst mainDT = new DataTool();\nconst secondaryDT = new DataTool();\nexport const Analyzer = {\n    updater: AnalyzerUpdater,\n    processor: AnalyzerProcessor,\n    _flowChecks: [\n        [0, -1, 0],\n        [1, 0, 0],\n        [-1, 0, 0],\n        [0, 0, 1],\n        [0, 0, -1],\n    ],\n    async runPropagation(data) {\n        const options = {\n            light: EngineSettings.doLight(),\n            flow: EngineSettings.doFlow(),\n        };\n        mainDT.setDimension(data[0][0]);\n        secondaryDT.setDimension(data[0][0]);\n        const tasks = TasksRequest.getVoxelUpdateRequests(data[0], \"none\", \"self\");\n        tasks.start();\n        this.processor.goThroughColumn(data[0], (x, y, z) => {\n            if (!mainDT.loadInAt(x, y, z))\n                return;\n            if (options.light) {\n                if (mainDT.isLightSource()) {\n                    tasks.queues.rgb.update.push(x, y, z);\n                }\n            }\n            if (options.flow) {\n                if (mainDT.getSubstnaceData().isLiquid()) {\n                    let add = false;\n                    for (const check of this._flowChecks) {\n                        if (secondaryDT.loadInAt(x + check[0], y + check[1], z + check[2])) {\n                            if (secondaryDT.isAir()) {\n                                add = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (add) {\n                        tasks.queues.flow.update.queue.push([x, y, z]);\n                    }\n                }\n            }\n        });\n        Propagation.rgb.update(tasks);\n        const dimension = data[0][0];\n        for (const flowUpdate of tasks.queues.flow.update.queue) {\n            const [x, y, z] = flowUpdate;\n            if (!mainDT.loadInAt(x, y, z))\n                continue;\n            await FlowUpdate(TasksRequest.getFlowUpdateRequest([dimension, x, y, z], \"none\", \"self\"), false);\n        }\n        tasks.stop();\n    },\n    async runUpdate(data) {\n        if (!this.processor.columnTool.setLocation(data[0]).loadIn())\n            return;\n        const deltaTime = Date.now() - this.processor.columnTool.getLastAnalyzerUpdateTimestamp();\n        const location = [...data[0]];\n        this.processor.goThroughColumn(data[0], (x, y, z) => {\n            if (!mainDT.loadInAt(x, y, z))\n                return;\n            location[1] = x;\n            location[2] = y;\n            location[3] = z;\n            const run = this.updater.getVoxel(mainDT.getStringId());\n            if (!run)\n                return;\n            run(location, deltaTime, this, DVEC);\n        });\n        this.processor.columnTool.setLastAnalyzerUpdateTimestamp();\n    },\n};\n","import { WorldSpaces } from \"../../Data/World/WorldSpaces.js\";\nimport { ColumnDataTool } from \"../../Tools/Data/WorldData/ColumnDataTool.js\";\nimport { HeightMapTool } from \"../../Tools/Data/WorldData/HeightMapTool.js\";\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\nimport { WorldRegister } from \"../../Data/World/WorldRegister.js\";\nconst columnTool = new ColumnDataTool();\nconst heightMapTool = new HeightMapTool();\nconst chunkTool = new ChunkDataTool();\nexport const AnalyzerProcessor = {\n    columnTool: columnTool,\n    chunkTool: chunkTool,\n    goThroughColumn(location, run) {\n        if (!columnTool.setLocation(location).loadIn())\n            return;\n        WorldRegister.cache.enable();\n        const column = columnTool.getColumn();\n        let maxX = WorldSpaces.chunk._bounds.x + location[1];\n        let maxZ = WorldSpaces.chunk._bounds.z + location[3];\n        for (const [index, chunk] of column.chunks) {\n            heightMapTool.chunk.setChunk(chunk);\n            chunkTool.setChunk(chunk);\n            const [dimension, cx, cy, cz] = chunkTool.getLocationData();\n            let [minY, maxY] = heightMapTool.chunk.getMinMax();\n            minY += cy;\n            maxY += cy + 1;\n            for (let y = minY; y < maxY; y += 1) {\n                for (let z = cz; z < maxZ; z += 1) {\n                    for (let x = cx; x < maxX; x += 1) {\n                        run(x, y, z, columnTool);\n                    }\n                }\n            }\n        }\n        WorldRegister.cache.disable();\n    },\n};\n","export const AnalyzerUpdater = {\n    _voxels: new Map(),\n    registerVoxel(id, run) {\n        this._voxels.set(id, run);\n    },\n    getVoxel(id) {\n        const run = this._voxels.get(id);\n        if (!run)\n            return false;\n        return run;\n    },\n};\n","import { ConstructorHooks } from \"../Hooks/ConstructorHooks.js\";\nimport { VoxelConstructors } from \"./Constructors/Voxel/VoxelConstructors.js\";\nimport { ChunkProcessor } from \"./Processors/ChunkProcessor.js\";\nimport { OverrideManager } from \"./Rules/Overrides/OverridesManager.js\";\nimport { RenderedSubstances } from \"./Rules/RenderedSubstances.js\";\nimport { TextureManager } from \"./Textures/TextureManager.js\";\nimport { NodeBuilderManager } from \"./Nodes/NodeBuilderManager.js\";\nexport const Builder = {\n    constructors: VoxelConstructors,\n    textureManager: TextureManager,\n    chunkProcessor: ChunkProcessor,\n    nodes: NodeBuilderManager,\n    overrides: OverrideManager,\n    renderedSubstances: RenderedSubstances,\n    $INIT() {\n        ConstructorHooks.texturesRegistered.addToRun((manager) => {\n            this.constructors.constructors._map.forEach((_) => {\n                _.onTexturesRegistered(manager);\n            });\n        });\n    },\n    buildChunk(location, LOD = 1) {\n        this.chunkProcessor.build(location);\n        return true;\n    },\n};\n","import { QuadVertexData } from \"../../Classes/VertexData.js\";\nconst checkSets = {\n    1: [\n        -1, 0, 0, -1,\n        //corner\n        -1, -1,\n    ],\n    2: [\n        -1, 0, 0, 1,\n        //corner\n        -1, 1,\n    ],\n    3: [\n        1, 0, 0, 1,\n        //corner\n        1, 1,\n    ],\n    4: [\n        1, 0, 0, -1,\n        //corner\n        1, -1,\n    ],\n};\nconst flowStates = new QuadVertexData();\nexport const FlowGradient = {\n    getLevel(tool) {\n        if (!tool.nVoxel.isRenderable())\n            return -1;\n        if (!tool.voxel.isSameVoxel(tool.nVoxel.x, tool.nVoxel.y, tool.nVoxel.z))\n            return -1;\n        const level = tool.nVoxel.getLevel();\n        return level;\n    },\n    calculate(tool) {\n        const cl = tool.voxel.getLevel();\n        const cs = tool.voxel.getLevelState();\n        if (cl == 15 && cs == 1) {\n            if (tool.voxel.isSameVoxel(tool.voxel.x, tool.voxel.y + 1, tool.voxel.z)) {\n                flowStates.setAll(15);\n                return tool.getWorldLevel().setFromQuadData(flowStates);\n            }\n        }\n        for (let vertex = 1; vertex <= 4; vertex++) {\n            const checkSet = checkSets[vertex];\n            if (cl == 15 && cs != 1) {\n                flowStates.vetexes[vertex] = 15;\n                continue;\n            }\n            let finalLevel = cl;\n            let voxelCount = 0;\n            let zeroCount = 0;\n            let totalZero = true;\n            let ovveride = false;\n            let totalLevel = 0;\n            for (let iy = 0; iy < 2; iy++) {\n                for (let i = 0; i < 6; i += 2) {\n                    const cx = checkSet[i] + tool.voxel.x;\n                    const cz = checkSet[i + 1] + tool.voxel.z;\n                    const loadedIn = tool.nVoxel.loadInAt(cx, tool.voxel.y + iy, cz);\n                    if (!loadedIn)\n                        continue;\n                    const level = this.getLevel(tool);\n                    const hasVoxel = tool.nVoxel.isRenderable();\n                    if (hasVoxel && !tool.nVoxel.getSubstnaceData().isLiquid()) {\n                        voxelCount++;\n                    }\n                    if (iy == 1) {\n                        if (level > 0) {\n                            finalLevel = 15;\n                            totalZero = false;\n                            ovveride = true;\n                            totalLevel += level;\n                        }\n                    }\n                    if (level <= 0 && !hasVoxel) {\n                        if (iy == 0) {\n                            zeroCount++;\n                        }\n                        continue;\n                    }\n                    if (level == 15) {\n                        finalLevel = 15;\n                        totalZero = false;\n                        zeroCount = 0;\n                        break;\n                    }\n                    if (level > 0 && !hasVoxel) {\n                        totalZero = false;\n                    }\n                    if (finalLevel < level) {\n                        finalLevel += level - finalLevel;\n                    }\n                }\n            }\n            if (ovveride && totalLevel == 1 && voxelCount == 3) {\n                finalLevel = cl;\n            }\n            if (zeroCount >= 1 && cs == 0 && !ovveride) {\n                finalLevel = 0;\n            }\n            if (totalZero && cs == 1 && cl == 15) {\n                finalLevel = 7;\n            }\n            if (finalLevel > 15)\n                finalLevel = 15;\n            if (finalLevel < 1)\n                finalLevel = 1;\n            flowStates.vetexes[vertex] = finalLevel;\n        }\n        tool.getWorldLevel().setFromQuadData(flowStates);\n    },\n};\n","import { OverrideManager } from \"../../Rules/Overrides/OverridesManager.js\";\nimport { LightData } from \"../../../../Data/Light/LightByte.js\";\nimport { QuadVertexData } from \"../../Classes/VertexData.js\";\nimport { SubstanceRules } from \"../../Rules/SubstanceRules.js\";\nimport { FaceNormals } from \"../../../../Math/Constants/Faces.js\";\nconst LD = LightData;\nconst LightValue = new QuadVertexData();\nconst RGBState = new QuadVertexData();\nconst SunState = new QuadVertexData();\nconst AOValue = new QuadVertexData();\nconst AOState = new QuadVertexData();\nconst swapSun = () => {\n    LightValue.set(LD.setS(LD.getS(LightValue.vetexes[4]), LightValue.vetexes[1]), LD.setS(LD.getS(LightValue.vetexes[1]), LightValue.vetexes[2]), LD.setS(LD.getS(LightValue.vetexes[2]), LightValue.vetexes[3]), LD.setS(LD.getS(LightValue.vetexes[3]), LightValue.vetexes[4]));\n};\nconst swapRGB = () => {\n    LightValue.set(LD.setRGB(LD.getRGB(LightValue.vetexes[4]), LightValue.vetexes[1]), LD.setRGB(LD.getRGB(LightValue.vetexes[1]), LightValue.vetexes[2]), LD.setRGB(LD.getRGB(LightValue.vetexes[2]), LightValue.vetexes[3]), LD.setRGB(LD.getRGB(LightValue.vetexes[3]), LightValue.vetexes[4]));\n};\nconst swapAO = () => {\n    AOValue.set(AOValue.vetexes[1], AOValue.vetexes[2], AOValue.vetexes[3], AOValue.vetexes[4]);\n};\nconst shouldAOFlip = (face) => {\n    if (states.ignoreAO)\n        return false;\n    LightGradient.tool.faceDataOverride.face = face;\n    LightGradient.tool.faceDataOverride.default = false;\n    if (OverrideManager.runOverride(\"AOFlipFace\", LightGradient.tool.voxel.getShapeId(), \"Any\", LightGradient.tool.faceDataOverride)) {\n        return false;\n    }\n    let check = false;\n    if (!states.ignoreAO) {\n        check = AOState.isEqualTo(0, 1, 1, 1);\n        AOState.isEqualTo(1, 1, 0, 1) || AOState.isEqualTo(0, 1, 0, 1);\n    }\n    return check;\n};\nconst flipCheck = (face) => {\n    const rgbFlip = RGBState.isEqualTo(0, 1, 1, 1) ||\n        RGBState.isEqualTo(1, 1, 0, 1) ||\n        RGBState.isEqualTo(0, 1, 0, 1);\n    const sunFlip = SunState.isEqualTo(0, 1, 1, 1) ||\n        SunState.isEqualTo(1, 1, 0, 1) ||\n        SunState.isEqualTo(0, 1, 0, 1);\n    const aoFlip = shouldAOFlip(face);\n    if (rgbFlip && !sunFlip) {\n        swapSun();\n    }\n    if (!rgbFlip && sunFlip) {\n        swapRGB();\n    }\n    if ((sunFlip || rgbFlip) && !aoFlip) {\n        swapAO();\n    }\n    if (!sunFlip && aoFlip) {\n        swapSun();\n    }\n    if (!rgbFlip && aoFlip) {\n        swapRGB();\n    }\n    return rgbFlip || sunFlip || aoFlip;\n};\nconst checkSets = {\n    top: {\n        1: [-1, 1, 0, 0, 1, -1, -1, 1, -1],\n        2: [-1, 1, 0, 0, 1, 1, -1, 1, 1],\n        3: [1, 1, 0, 0, 1, 1, 1, 1, 1],\n        4: [1, 1, 0, 0, 1, -1, 1, 1, -1],\n    },\n    bottom: {\n        1: [0, -1, -1, -1, -1, 0, -1, -1, -1],\n        2: [0, -1, -1, 1, -1, 0, 1, -1, -1],\n        3: [0, -1, 1, 1, -1, 0, 1, -1, 1],\n        4: [0, -1, 1, -1, -1, 0, -1, -1, 1],\n    },\n    east: {\n        1: [1, 0, -1, 1, 1, 0, 1, 1, -1],\n        2: [1, 0, 1, 1, 1, 0, 1, 1, 1],\n        3: [1, 0, 1, 1, -1, 0, 1, -1, 1],\n        4: [1, 0, -1, 1, -1, 0, 1, -1, -1],\n    },\n    west: {\n        1: [-1, 0, 1, -1, 1, 0, -1, 1, 1],\n        2: [-1, 0, -1, -1, 1, 0, -1, 1, -1],\n        3: [-1, 0, -1, -1, -1, 0, -1, -1, -1],\n        4: [-1, 0, 1, -1, -1, 0, -1, -1, 1],\n    },\n    south: {\n        1: [-1, 0, -1, 0, 1, -1, -1, 1, -1],\n        2: [1, 0, -1, 0, 1, -1, 1, 1, -1],\n        3: [1, 0, -1, 0, -1, -1, 1, -1, -1],\n        4: [-1, 0, -1, 0, -1, -1, -1, -1, -1],\n    },\n    north: {\n        1: [1, 0, 1, 0, 1, 1, 1, 1, 1],\n        2: [-1, 0, 1, 0, 1, 1, -1, 1, 1],\n        3: [-1, 0, 1, 0, -1, 1, -1, -1, 1],\n        4: [1, 0, 1, 0, -1, 1, 1, -1, 1],\n    },\n};\nconst states = { ignoreAO: false };\nconst newRGBValues = [];\nconst zeroCheck = { s: 0, r: 0, g: 0, b: 0 };\nconst RGBValues = { r: 0, g: 0, b: 0 };\nconst sunValues = { s: 0 };\nconst nlValues = { s: 0, r: 0, g: 0, b: 0 };\nconst AOValues = { a: 0 };\nexport const LightGradient = {\n    tool: {},\n    settings: {\n        doAO: true,\n        doRGB: true,\n        doSun: true,\n    },\n    calculate(face, tool, ignoreAO) {\n        this.tool = tool;\n        const voxelSubstance = SubstanceRules.getSubstanceParent(tool.voxel.getSubstance());\n        const isLightSource = tool.voxel.isLightSource();\n        let light = tool.voxel.getLight();\n        let aoOverRide = -1;\n        if (this.settings.doAO && !ignoreAO) {\n            AOValue.setAll(1);\n            AOState.setAll(1);\n            states.ignoreAO = false;\n        }\n        else {\n            states.ignoreAO = true;\n        }\n        const faceNormal = FaceNormals[face];\n        tool.nVoxel.loadInAt(tool.voxel.x + faceNormal[0], tool.voxel.y + faceNormal[1], tool.voxel.z + faceNormal[2]);\n        light = tool.nVoxel.getLight();\n        if (light < 0) {\n            if (tool.voxel.getLight() >= 0) {\n                light = tool.voxel.getLight();\n            }\n            else {\n                light = 0;\n            }\n        }\n        if (tool.nVoxel.isRenderable() && !tool.nVoxel.isLightSource()) {\n            tool.faceDataOverride.face = face;\n            tool.faceDataOverride.default = false;\n            if (OverrideManager.runOverride(\"DarkenFaceUnderneath\", tool.nVoxel.getShapeId(), \"All\", tool.faceDataOverride)) {\n                aoOverRide = 2;\n            }\n        }\n        for (let vertex = 1; vertex <= 4; vertex++) {\n            const checkSet = checkSets[face][vertex];\n            if (this.settings.doRGB || this.settings.doSun) {\n                const values = LD.getLightValues(light);\n                if (this.settings.doSun) {\n                    sunValues.s = values[0];\n                    if (sunValues.s == 0)\n                        zeroCheck.s++;\n                }\n                if (this.settings.doRGB) {\n                    RGBValues.r = values[1];\n                    if (RGBValues.r == 0)\n                        zeroCheck.r++;\n                    RGBValues.g = values[2];\n                    if (RGBValues.g == 0)\n                        zeroCheck.g++;\n                    RGBValues.b = values[3];\n                    if (RGBValues.b == 0)\n                        zeroCheck.b++;\n                }\n            }\n            if (!states.ignoreAO) {\n                AOValues.a = 1;\n            }\n            for (let i = 0; i < 9; i += 3) {\n                if (this.settings.doRGB || this.settings.doSun) {\n                    if (!tool.nVoxel.loadInAt(checkSet[i] + tool.voxel.x, checkSet[i + 1] + tool.voxel.y, checkSet[i + 2] + tool.voxel.z))\n                        continue;\n                    const nl = tool.nVoxel.getLight();\n                    if (nl >= 0) {\n                        const values = LD.getLightValues(nl);\n                        nlValues.s = values[0];\n                        nlValues.r = values[1];\n                        nlValues.g = values[2];\n                        nlValues.b = values[3];\n                        doRGB: if (this.settings.doRGB) {\n                            if (nlValues.r == 0)\n                                zeroCheck.r++;\n                            if (nlValues.g == 0)\n                                zeroCheck.g++;\n                            if (nlValues.b == 0)\n                                zeroCheck.b++;\n                            if (!LD.removeS(nl))\n                                break doRGB;\n                            if (nlValues.r > RGBValues.r && RGBValues.r < 15) {\n                                RGBValues.r++;\n                            }\n                            if (nlValues.g > RGBValues.g && RGBValues.g < 15) {\n                                RGBValues.g++;\n                            }\n                            if (nlValues.b > RGBValues.b && RGBValues.b < 15) {\n                                RGBValues.b++;\n                            }\n                        }\n                        doSun: if (this.settings.doSun) {\n                            if (nlValues.s == 0)\n                                zeroCheck.s++;\n                            if (!LD.getS(nl))\n                                break doSun;\n                            if (sunValues.s < nlValues.s && sunValues.s < 15) {\n                                sunValues.s += LD.SRS;\n                            }\n                        }\n                    }\n                }\n                /*\n                Do AO\n                */\n                doAO: if (!states.ignoreAO) {\n                    if (aoOverRide > 0) {\n                        AOState.setVertex(vertex, 0);\n                        AOValues.a = aoOverRide;\n                        break doAO;\n                    }\n                    if (!tool.nVoxel.isRenderable())\n                        break doAO;\n                    const neighborVoxelSubstance = SubstanceRules.getSubstanceParent(tool.nVoxel.getSubstance());\n                    const neightLightSource = tool.nVoxel.isLightSource();\n                    let finalResult = true;\n                    if (neighborVoxelSubstance != voxelSubstance) {\n                        finalResult = false;\n                    }\n                    if (isLightSource || neightLightSource) {\n                        finalResult = false;\n                    }\n                    tool.faceDataOverride.face = face;\n                    tool.faceDataOverride.default = finalResult;\n                    finalResult = OverrideManager.runOverride(\"AO\", tool.voxel.getShapeId(), tool.nVoxel.getShapeId(), tool.faceDataOverride);\n                    if (!finalResult)\n                        break doAO;\n                    AOState.setVertex(vertex, 0);\n                    AOValues.a++;\n                }\n            }\n            /*\n            Light End\n            */\n            if (this.settings.doSun || this.settings.doRGB) {\n                let zeroTolerance = 2;\n                let totalZero = true;\n                if (zeroCheck.s >= zeroTolerance) {\n                    SunState.setVertex(vertex, 1);\n                    newRGBValues[0] = 0;\n                }\n                else {\n                    SunState.setVertex(vertex, 0);\n                    newRGBValues[0] = sunValues.s;\n                }\n                if (zeroCheck.r >= zeroTolerance) {\n                    newRGBValues[1] = 0;\n                }\n                else {\n                    totalZero = false;\n                    newRGBValues[1] = RGBValues.r;\n                }\n                if (zeroCheck.g >= zeroTolerance) {\n                    newRGBValues[2] = 0;\n                }\n                else {\n                    totalZero = false;\n                    newRGBValues[2] = RGBValues.g;\n                }\n                if (zeroCheck.b >= zeroTolerance) {\n                    newRGBValues[3] = 0;\n                }\n                else {\n                    totalZero = false;\n                    newRGBValues[3] = RGBValues.b;\n                }\n                RGBState.setVertex(vertex, totalZero ? 0 : 1);\n                LightValue.setVertex(vertex, LD.setLightValues(newRGBValues));\n                zeroCheck.s = 0;\n                zeroCheck.r = 0;\n                zeroCheck.b = 0;\n                zeroCheck.g = 0;\n            }\n            /*\n            AO End\n            */\n            if (this.settings.doAO) {\n                AOValue.setVertex(vertex, AOValues.a);\n            }\n        }\n        if (flipCheck(face)) {\n            tool\n                .setFaceFlipped(true)\n                .getWorldLight()\n                .set(LightValue.vetexes[2], LightValue.vetexes[1], LightValue.vetexes[4], LightValue.vetexes[3]);\n            if (!states.ignoreAO) {\n                tool\n                    .getWorldAO()\n                    .set(AOValue.vetexes[4], AOValue.vetexes[1], AOValue.vetexes[2], AOValue.vetexes[3]);\n            }\n            return;\n        }\n        tool\n            .setFaceFlipped(false)\n            .getWorldLight()\n            .set(LightValue.vetexes[1], LightValue.vetexes[2], LightValue.vetexes[3], LightValue.vetexes[4]);\n        if (!states.ignoreAO) {\n            tool\n                .getWorldAO()\n                .set(AOValue.vetexes[1], AOValue.vetexes[2], AOValue.vetexes[3], AOValue.vetexes[4]);\n        }\n    },\n};\n","export class QuadVertexData {\n    vetexes = {\n        1: 0,\n        2: 0,\n        3: 0,\n        4: 0,\n    };\n    getAsArray() {\n        return [this.vetexes[1], this.vetexes[2], this.vetexes[3], this.vetexes[4]];\n    }\n    setVertex(vertex, value) {\n        this.vetexes[vertex] = value;\n    }\n    addToVertex(vertex, value) {\n        this.vetexes[vertex] += value;\n    }\n    subtractFromVertex(vertex, value) {\n        this.vetexes[vertex] -= value;\n    }\n    getVertex(vertex) {\n        return this.vetexes[vertex];\n    }\n    setAll(value) {\n        this.vetexes[1] = value;\n        this.vetexes[2] = value;\n        this.vetexes[3] = value;\n        this.vetexes[4] = value;\n    }\n    set(v1, v2, v3, v4) {\n        this.vetexes[1] = v1;\n        this.vetexes[2] = v2;\n        this.vetexes[3] = v3;\n        this.vetexes[4] = v4;\n    }\n    setFromQuadData(vertexData) {\n        this.vetexes[1] = vertexData.vetexes[1];\n        this.vetexes[2] = vertexData.vetexes[2];\n        this.vetexes[3] = vertexData.vetexes[3];\n        this.vetexes[4] = vertexData.vetexes[4];\n    }\n    addAll(value) {\n        this.vetexes[1] += value;\n        this.vetexes[2] += value;\n        this.vetexes[3] += value;\n        this.vetexes[4] += value;\n    }\n    add(v1, v2, v3, v4) {\n        this.vetexes[1] += v1;\n        this.vetexes[2] += v2;\n        this.vetexes[3] += v3;\n        this.vetexes[4] += v4;\n    }\n    subtractAll(value) {\n        this.vetexes[1] -= value;\n        this.vetexes[2] -= value;\n        this.vetexes[3] -= value;\n        this.vetexes[4] -= value;\n    }\n    subtract(v1, v2, v3, v4) {\n        this.vetexes[1] += v1;\n        this.vetexes[2] += v2;\n        this.vetexes[3] += v3;\n        this.vetexes[4] += v4;\n    }\n    isEqualTo(v1, v2, v3, v4) {\n        if (this.vetexes[1] != v1)\n            return false;\n        if (this.vetexes[2] != v2)\n            return false;\n        if (this.vetexes[3] != v3)\n            return false;\n        if (this.vetexes[4] != v4)\n            return false;\n        return true;\n    }\n    isAllEqualTo(value) {\n        if (this.vetexes[1] != value)\n            return false;\n        if (this.vetexes[2] != value)\n            return false;\n        if (this.vetexes[3] != value)\n            return false;\n        if (this.vetexes[4] != value)\n            return false;\n        return true;\n    }\n    isGreaterThan(v1, v2, v3, v4) {\n        if (this.vetexes[1] < v1)\n            return false;\n        if (this.vetexes[2] < v2)\n            return false;\n        if (this.vetexes[3] < v3)\n            return false;\n        if (this.vetexes[4] < v4)\n            return false;\n        return true;\n    }\n    isAllGreaterThan(value) {\n        if (this.vetexes[1] < value)\n            return false;\n        if (this.vetexes[2] < value)\n            return false;\n        if (this.vetexes[3] < value)\n            return false;\n        if (this.vetexes[4] < value)\n            return false;\n        return true;\n    }\n    isLessThan(v1, v2, v3, v4) {\n        if (this.vetexes[1] > v1)\n            return false;\n        if (this.vetexes[2] > v2)\n            return false;\n        if (this.vetexes[3] > v3)\n            return false;\n        if (this.vetexes[4] > v4)\n            return false;\n        return true;\n    }\n    isAllLessThan(value) {\n        if (this.vetexes[1] > value)\n            return false;\n        if (this.vetexes[2] > value)\n            return false;\n        if (this.vetexes[3] > value)\n            return false;\n        if (this.vetexes[4] > value)\n            return false;\n        return true;\n    }\n    forEach(run) {\n        run(1, this.vetexes[1]);\n        run(2, this.vetexes[2]);\n        run(3, this.vetexes[3]);\n        run(4, this.vetexes[4]);\n    }\n}\n","import { BoxVoxelShape } from \"../../../../Shapes/default/Box/Box.voxel.shape.js\";\nimport { VoxelConstructor } from \"../VoxelConstructor.js\";\nexport class PillarBoxVoxelConstructor extends VoxelConstructor {\n    id;\n    textureData;\n    textures;\n    constructor(id, textureData) {\n        super();\n        this.id = id;\n        this.textureData = textureData;\n    }\n    process(tool) {\n        const topCheck = tool.voxel.isSameVoxel(tool.voxel.x, tool.voxel.y + 1, tool.voxel.z);\n        const bottomCheck = tool.voxel.isSameVoxel(tool.voxel.x, tool.voxel.y, tool.voxel.z);\n        let side = -1;\n        determineText: if (side) {\n            if (topCheck && bottomCheck) {\n                side = this.textures[2];\n                break determineText;\n            }\n            if (topCheck && !bottomCheck) {\n                side = this.textures[3];\n                break determineText;\n            }\n            if (!topCheck && bottomCheck) {\n                side = this.textures[4];\n                break determineText;\n            }\n            if (!topCheck && !bottomCheck) {\n                side = this.textures[5];\n                break determineText;\n            }\n            side = 0;\n        }\n        tool.getOverlayTextures().setAll(0);\n        if (tool.isFaceExposed(\"top\")) {\n            tool.setTexture(this.textures[0]).calculateLight(\"top\");\n            BoxVoxelShape.add.top();\n        }\n        if (tool.isFaceExposed(\"bottom\")) {\n            tool.setTexture(this.textures[1]).calculateLight(\"bottom\");\n            BoxVoxelShape.add.bottom();\n        }\n        if (tool.isFaceExposed(\"east\")) {\n            tool.setTexture(side).calculateLight(\"east\");\n            BoxVoxelShape.add.east();\n        }\n        if (tool.isFaceExposed(\"west\")) {\n            tool.setTexture(side).calculateLight(\"west\");\n            BoxVoxelShape.add.west();\n        }\n        if (tool.isFaceExposed(\"south\")) {\n            tool.setTexture(side).calculateLight(\"south\");\n            BoxVoxelShape.add.south();\n        }\n        if (tool.isFaceExposed(\"north\")) {\n            tool.setTexture(side).calculateLight(\"north\");\n            BoxVoxelShape.add.north();\n        }\n    }\n    onTexturesRegistered(textureManager) {\n        this.textures = [\n            textureManager.getTextureUV(this.textureData.top),\n            textureManager.getTextureUV(this.textureData.bottom),\n            textureManager.getTextureUV(this.textureData.sideMiddle),\n            textureManager.getTextureUV(this.textureData.sideBottom),\n            textureManager.getTextureUV(this.textureData.sideTop),\n            textureManager.getTextureUV(this.textureData.sideFloat),\n        ];\n        this.textureData = null;\n    }\n}\n","import { BoxVoxelShape } from \"../../../../Shapes/default/Box/Box.voxel.shape.js\";\nimport { VoxelConstructor } from \"../VoxelConstructor.js\";\nexport class SimpleBoxVoxelConstructor extends VoxelConstructor {\n    id;\n    textureData;\n    textures = [];\n    constructor(id, textureData) {\n        super();\n        this.id = id;\n        this.textureData = textureData;\n    }\n    process(tool) {\n        tool.getOverlayTextures().setAll(0);\n        if (tool.isFaceExposed(\"top\")) {\n            tool.setTexture(this.textures[0]).calculateLight(\"top\");\n            BoxVoxelShape.add.top();\n        }\n        if (tool.isFaceExposed(\"bottom\")) {\n            tool.setTexture(this.textures[1]).calculateLight(\"bottom\");\n            BoxVoxelShape.add.bottom();\n        }\n        if (tool.isFaceExposed(\"east\")) {\n            tool.setTexture(this.textures[2]).calculateLight(\"east\");\n            BoxVoxelShape.add.east();\n        }\n        if (tool.isFaceExposed(\"west\")) {\n            tool.setTexture(this.textures[3]).calculateLight(\"west\");\n            BoxVoxelShape.add.west();\n        }\n        if (tool.isFaceExposed(\"south\")) {\n            tool.setTexture(this.textures[4]).calculateLight(\"south\");\n            BoxVoxelShape.add.south();\n        }\n        if (tool.isFaceExposed(\"north\")) {\n            tool.setTexture(this.textures[5]).calculateLight(\"north\");\n            BoxVoxelShape.add.north();\n        }\n    }\n    onTexturesRegistered(textureManager) {\n        const textures = this.textureData;\n        if (Array.isArray(textures)) {\n            let i = 6;\n            while (i--) {\n                this.textures.push(textureManager.getTextureUV(textures));\n            }\n            return;\n        }\n        this.textures.push(textureManager.getTextureUV(textures.top));\n        this.textures.push(textureManager.getTextureUV(textures.bottom));\n        this.textures.push(textureManager.getTextureUV(textures.east));\n        this.textures.push(textureManager.getTextureUV(textures.west));\n        this.textures.push(textureManager.getTextureUV(textures.south));\n        this.textures.push(textureManager.getTextureUV(textures.north));\n    }\n}\n","import { VoxelConstructor } from \"../VoxelConstructor.js\";\nimport { LiquidVoxelShape } from \"../../../../Shapes/default/Liquid/Liquid.voxel.shape.js\";\nexport class SimpleLiquidConstructor extends VoxelConstructor {\n    id;\n    textureData;\n    textures = [];\n    constructor(id, textureData) {\n        super();\n        this.id = id;\n        this.textureData = textureData;\n    }\n    process(tool) {\n        LiquidVoxelShape.start();\n        tool.getOverlayTextures().setAll(0);\n        if (tool.isFaceExposed(\"top\")) {\n            tool.setTexture(this.textures[0]).calculateLight(\"top\", true);\n            LiquidVoxelShape.add.top();\n        }\n        if (tool.isFaceExposed(\"bottom\")) {\n            tool.setTexture(this.textures[0]).calculateLight(\"bottom\", true);\n            LiquidVoxelShape.add.bottom();\n        }\n        if (tool.isFaceExposed(\"east\")) {\n            tool.setTexture(this.textures[0]).calculateLight(\"east\", true);\n            LiquidVoxelShape.add.east();\n        }\n        if (tool.isFaceExposed(\"west\")) {\n            tool.setTexture(this.textures[0]).calculateLight(\"west\", true);\n            LiquidVoxelShape.add.west();\n        }\n        if (tool.isFaceExposed(\"south\")) {\n            tool.setTexture(this.textures[0]).calculateLight(\"south\", true);\n            LiquidVoxelShape.add.south();\n        }\n        if (tool.isFaceExposed(\"north\")) {\n            tool.setTexture(this.textures[0]).calculateLight(\"north\", true);\n            LiquidVoxelShape.add.north();\n        }\n    }\n    onTexturesRegistered(textureManager) {\n        for (const text of this.textureData) {\n            this.textures.push(textureManager.getTextureUV(text));\n        }\n    }\n}\n","import { VoxelConstructor } from \"../VoxelConstructor.js\";\nimport { CrossedPanels } from \"../../../../Shapes/default/Panel/CrossedPanels.voxel.shape.js\";\nexport class SimpleCrossedPanelVoxelConstructor extends VoxelConstructor {\n    id;\n    textuerData;\n    texture = 0;\n    constructor(id, textuerData) {\n        super();\n        this.id = id;\n        this.textuerData = textuerData;\n    }\n    process(tool) {\n        tool.setTexture(this.texture);\n        tool.getOverlayTextures().setAll(0);\n        tool.getWorldAO().setAll(1);\n        tool.getWorldLight().setAll(tool.voxel.getLight());\n        CrossedPanels.build();\n    }\n    onTexturesRegistered(textureManager) {\n        this.texture = textureManager.getTextureUV(this.textuerData);\n        this.textuerData = null;\n    }\n}\n","import { VoxelConstructor } from \"../VoxelConstructor.js\";\nimport { PanelVoxelShape } from \"../../../../Shapes/default/Panel/Panel.voxel.shape.js\";\nexport class SimplePanelVoxelConstructor extends VoxelConstructor {\n    id;\n    textuerData;\n    texture = 0;\n    constructor(id, textuerData) {\n        super();\n        this.id = id;\n        this.textuerData = textuerData;\n    }\n    process(tool) {\n        tool.setTexture(this.texture);\n        tool.getOverlayTextures().setAll(0);\n        tool.getWorldAO().setAll(1);\n        tool.getWorldLight().setAll(tool.voxel.getLight());\n        PanelVoxelShape.build();\n    }\n    onTexturesRegistered(textureManager) {\n        this.texture = textureManager.getTextureUV(this.textuerData);\n        this.textuerData = null;\n    }\n}\n","import { VoxelConstructor } from \"../VoxelConstructor.js\";\nimport { StairVoxelShape } from \"../../../../Shapes/default/Stairs/Stair.voxel.shape.js\";\nexport class SimpleStairVoxelConstructor extends VoxelConstructor {\n    id;\n    textureData;\n    texture = 0;\n    constructor(id, textureData) {\n        super();\n        this.id = id;\n        this.textureData = textureData;\n    }\n    process(tool) {\n        tool.setTexture(this.texture);\n        tool.getOverlayTextures().setAll(0);\n        if (tool.isFaceExposed(\"top\")) {\n            tool.calculateLight(\"top\");\n            StairVoxelShape.add.top();\n        }\n        if (tool.isFaceExposed(\"bottom\")) {\n            tool.calculateLight(\"bottom\");\n            StairVoxelShape.add.bottom();\n        }\n        if (tool.isFaceExposed(\"east\")) {\n            tool.calculateLight(\"east\");\n            StairVoxelShape.add.east();\n        }\n        if (tool.isFaceExposed(\"west\")) {\n            tool.calculateLight(\"west\");\n            StairVoxelShape.add.west();\n        }\n        if (tool.isFaceExposed(\"south\")) {\n            tool.calculateLight(\"south\");\n            StairVoxelShape.add.south();\n        }\n        if (tool.isFaceExposed(\"north\")) {\n            tool.calculateLight(\"north\");\n            StairVoxelShape.add.north();\n        }\n    }\n    onTexturesRegistered(textureManager) {\n        this.texture = textureManager.getTextureUV(this.textureData);\n        this.textuerData = null;\n    }\n}\n","export class VoxelConstructor {\n    id;\n}\n","//utils\nimport { UtilMap } from \"../../../../Global/Util/UtilMap.js\";\n//constructors\nimport { SimpleBoxVoxelConstructor } from \"./Classes/Box/SimpleBox.constructor.js\";\nimport { PillarBoxVoxelConstructor, } from \"./Classes/Box/PillarBox.constructor.js\";\nimport { SimpleLiquidConstructor } from \"./Classes/Liquid/SimpleLiquid.constructor.js\";\nimport { SimplePanelVoxelConstructor } from \"./Classes/Panel/SimplePanel.constructor.js\";\nimport { SimpleStairVoxelConstructor } from \"./Classes/Stair/SimpleStair.constructor.js\";\nimport { SimpleCrossedPanelVoxelConstructor } from \"./Classes/Panel/SimpleCrossedPanel.constructor.js\";\nexport const VoxelConstructors = {\n    constructors: new UtilMap(),\n    get(id) {\n        return this.constructors.get(id);\n    },\n    registerVoxel(voxel) {\n        if (Array.isArray(voxel)) {\n            for (const vox of voxel) {\n                this.constructors.set(vox.id, vox);\n            }\n            return;\n        }\n        this.constructors.set(voxel.id, voxel);\n    },\n    defaults: {\n        box: {\n            simple(id, textures) {\n                return new SimpleBoxVoxelConstructor(id, textures);\n            },\n            pillar(id, textures) {\n                return new PillarBoxVoxelConstructor(id, textures);\n            },\n        },\n        stair: {\n            simple(id, texture) {\n                return new SimpleStairVoxelConstructor(id, texture);\n            },\n        },\n        panel: {\n            simple(id, texture) {\n                return new SimplePanelVoxelConstructor(id, texture);\n            },\n        },\n        crossedPanel: {\n            simple(id, texture) {\n                return new SimpleCrossedPanelVoxelConstructor(id, texture);\n            },\n        },\n        liquid: {\n            simple(id, textures) {\n                return new SimpleLiquidConstructor(id, textures);\n            },\n        },\n    },\n};\n","export const QuadBuilder = {\n    defaultTransform: {\n        1: { x: 0, y: 0, z: 0 },\n        2: { x: 0, y: 0, z: 0 },\n        3: { x: 0, y: 0, z: 0 },\n        4: { x: 0, y: 0, z: 0 },\n    },\n    width: 0,\n    height: 0,\n    faceFunctions: {\n        top: (origin, tool, transform, flip) => {\n            if (!flip) {\n                tool.addPositions(\n                //v1\n                origin.x - QuadBuilder.width + transform[1].x, origin.y + transform[1].y, origin.z - QuadBuilder.height + transform[1].z, \n                //v2\n                origin.x - QuadBuilder.width + transform[2].x, origin.y + transform[2].y, origin.z + QuadBuilder.height + transform[2].z, \n                //v3\n                origin.x + QuadBuilder.width + transform[3].x, origin.y + transform[3].y, origin.z + QuadBuilder.height + transform[3].z, \n                //v4\n                origin.x + QuadBuilder.width + transform[4].x, origin.y + transform[4].y, origin.z - QuadBuilder.height + transform[4].z);\n            }\n            else {\n                tool.addPositions(\n                //v1\n                origin.x + QuadBuilder.width + transform[4].x, origin.y + transform[4].y, origin.z - QuadBuilder.height + transform[4].z, \n                //v2\n                origin.x - QuadBuilder.width + transform[1].x, origin.y + transform[1].y, origin.z - QuadBuilder.height + transform[1].z, \n                //v3\n                origin.x - QuadBuilder.width + transform[2].x, origin.y + transform[2].y, origin.z + QuadBuilder.height + transform[2].z, \n                //v4\n                origin.x + QuadBuilder.width + transform[3].x, origin.y + transform[3].y, origin.z + QuadBuilder.height + transform[3].z);\n            }\n            tool.addIndices(tool.indicieIndex + 3, tool.indicieIndex + 2, tool.indicieIndex, tool.indicieIndex + 2, tool.indicieIndex + 1, tool.indicieIndex);\n            tool.addNormals(0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0);\n            tool.indicieIndex += 4;\n        },\n        bottom: (origin, tool, transform, flip) => {\n            if (!flip) {\n                tool.addPositions(\n                //v1\n                origin.x - QuadBuilder.width + transform[1].x, origin.y + transform[1].y, origin.z - QuadBuilder.height + transform[1].z, \n                //v2\n                origin.x + QuadBuilder.width + transform[2].x, origin.y + transform[2].y, origin.z - QuadBuilder.height + transform[2].z, \n                //v3\n                origin.x + QuadBuilder.width + transform[3].x, origin.y + transform[3].y, origin.z + QuadBuilder.height + transform[3].z, \n                //v4\n                origin.x - QuadBuilder.width + transform[4].x, origin.y + transform[4].y, origin.z + QuadBuilder.height + transform[4].z);\n            }\n            else {\n                tool.addPositions(\n                //v1\n                origin.x - QuadBuilder.width + transform[4].x, origin.y + transform[4].y, origin.z + QuadBuilder.height + transform[4].z, \n                //v2\n                origin.x - QuadBuilder.width + transform[1].x, origin.y + transform[1].y, origin.z - QuadBuilder.height + transform[1].z, \n                //v3\n                origin.x + QuadBuilder.width + transform[2].x, origin.y + transform[2].y, origin.z - QuadBuilder.height + transform[2].z, \n                //v4\n                origin.x + QuadBuilder.width + transform[3].x, origin.y + transform[3].y, origin.z + QuadBuilder.height + transform[3].z);\n            }\n            tool.addIndices(tool.indicieIndex + 2, tool.indicieIndex + 1, tool.indicieIndex, tool.indicieIndex + 3, tool.indicieIndex + 2, tool.indicieIndex);\n            tool.addNormals(0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0);\n            tool.indicieIndex += 4;\n        },\n        //front\n        south: (origin, tool, transform, flip) => {\n            if (!flip) {\n                tool.addPositions(\n                //v1\n                origin.x - QuadBuilder.width + transform[1].x, origin.y + QuadBuilder.height + transform[1].y, origin.z + transform[1].z, \n                //v2\n                origin.x + QuadBuilder.width + transform[2].x, origin.y + QuadBuilder.height + transform[2].y, origin.z + transform[2].z, \n                //v3\n                origin.x + QuadBuilder.width + transform[3].x, origin.y - QuadBuilder.height + transform[3].y, origin.z + transform[3].z, \n                //v4\n                origin.x - QuadBuilder.width + transform[4].x, origin.y - QuadBuilder.height + transform[4].y, origin.z + transform[4].z);\n            }\n            else {\n                tool.addPositions(\n                //v1\n                origin.x - QuadBuilder.width + transform[4].x, origin.y - QuadBuilder.height + transform[4].y, origin.z + transform[4].z, \n                //v2\n                origin.x - QuadBuilder.width + transform[1].x, origin.y + QuadBuilder.height + transform[1].y, origin.z + transform[1].z, \n                //v3\n                origin.x + QuadBuilder.width + transform[2].x, origin.y + QuadBuilder.height + transform[2].y, origin.z + transform[2].z, \n                //v4\n                origin.x + QuadBuilder.width + transform[3].x, origin.y - QuadBuilder.height + transform[3].y, origin.z + transform[3].z);\n            }\n            tool.addIndices(tool.indicieIndex + 2, tool.indicieIndex + 1, tool.indicieIndex, tool.indicieIndex + 3, tool.indicieIndex + 2, tool.indicieIndex);\n            tool.addNormals(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            tool.indicieIndex += 4;\n        },\n        //back\n        north: (origin, tool, transform, flip) => {\n            if (!flip) {\n                tool.addPositions(\n                //v1\n                origin.x + QuadBuilder.width + transform[1].x, origin.y + QuadBuilder.height + transform[1].y, origin.z + transform[1].z, \n                //v2\n                origin.x - QuadBuilder.width + transform[2].x, origin.y + QuadBuilder.height + transform[2].y, origin.z + transform[2].z, \n                //v3\n                origin.x - QuadBuilder.width + transform[3].x, origin.y - QuadBuilder.height + transform[3].y, origin.z + transform[3].z, \n                //v4\n                origin.x + QuadBuilder.width + transform[4].x, origin.y - QuadBuilder.height + transform[4].y, origin.z + transform[4].z);\n            }\n            else {\n                tool.addPositions(\n                //v1\n                origin.x + QuadBuilder.width + transform[4].x, origin.y - QuadBuilder.height + transform[4].y, origin.z + transform[4].z, \n                //v2\n                origin.x + QuadBuilder.width + transform[1].x, origin.y + QuadBuilder.height + transform[1].y, origin.z + transform[1].z, \n                //v3\n                origin.x - QuadBuilder.width + transform[2].x, origin.y + QuadBuilder.height + transform[2].y, origin.z + transform[2].z, \n                //v4\n                origin.x - QuadBuilder.width + transform[3].x, origin.y - QuadBuilder.height + transform[3].y, origin.z + transform[3].z);\n            }\n            tool.addIndices(tool.indicieIndex + 2, tool.indicieIndex + 1, tool.indicieIndex, tool.indicieIndex + 3, tool.indicieIndex + 2, tool.indicieIndex);\n            tool.addNormals(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1);\n            tool.indicieIndex += 4;\n        },\n        //left\n        west: (origin, tool, transform, flip) => {\n            if (!flip) {\n                tool.addPositions(\n                //v1\n                origin.x + transform[1].x, origin.y + QuadBuilder.height + transform[1].y, origin.z + QuadBuilder.width + transform[1].z, \n                //v2\n                origin.x + transform[2].x, origin.y + QuadBuilder.height + transform[2].y, origin.z - QuadBuilder.width + transform[2].z, \n                //v3\n                origin.x + transform[3].x, origin.y - QuadBuilder.height + transform[3].y, origin.z - QuadBuilder.width + +transform[3].z, \n                //v4\n                origin.x + transform[4].x, origin.y - QuadBuilder.height + transform[4].y, origin.z + QuadBuilder.width + transform[4].z);\n            }\n            else {\n                tool.addPositions(\n                //v1\n                origin.x + transform[4].x, origin.y - QuadBuilder.height + transform[4].y, origin.z + QuadBuilder.width + transform[4].z, \n                //v2\n                origin.x + transform[1].x, origin.y + QuadBuilder.height + transform[1].y, origin.z + QuadBuilder.width + transform[1].z, \n                //v3\n                origin.x + transform[2].x, origin.y + QuadBuilder.height + transform[2].y, origin.z - QuadBuilder.width + transform[2].z, \n                //v4\n                origin.x + transform[3].x, origin.y - QuadBuilder.height + transform[3].y, origin.z - QuadBuilder.width + transform[3].z);\n            }\n            tool.addIndices(tool.indicieIndex + 2, tool.indicieIndex + 1, tool.indicieIndex, tool.indicieIndex + 3, tool.indicieIndex + 2, tool.indicieIndex);\n            tool.addNormals(-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0);\n            tool.indicieIndex += 4;\n        },\n        //right\n        east: (origin, tool, transform, flip) => {\n            if (!flip) {\n                tool.addPositions(\n                //v1\n                origin.x + transform[1].x, origin.y + QuadBuilder.height + transform[1].y, origin.z - QuadBuilder.width + transform[1].z, \n                //v2\n                origin.x + transform[2].x, origin.y + QuadBuilder.height + transform[2].y, origin.z + QuadBuilder.width + transform[2].z, \n                //v3\n                origin.x + transform[3].x, origin.y - QuadBuilder.height + transform[3].y, origin.z + QuadBuilder.width + transform[3].z, \n                //v4\n                origin.x + transform[4].x, origin.y - QuadBuilder.height + transform[4].y, origin.z - QuadBuilder.width + transform[4].z);\n            }\n            else {\n                tool.addPositions(\n                //v1\n                origin.x + transform[4].x, origin.y - QuadBuilder.height + transform[4].y, origin.z - QuadBuilder.width + transform[4].z, \n                //v2\n                origin.x + transform[1].x, origin.y + QuadBuilder.height + transform[1].y, origin.z - QuadBuilder.width + transform[1].z, \n                //v3\n                origin.x + transform[2].x, origin.y + QuadBuilder.height + transform[2].y, origin.z + QuadBuilder.width + transform[2].z, \n                //v4\n                origin.x + transform[3].x, origin.y - QuadBuilder.height + transform[3].y, origin.z + QuadBuilder.width + transform[3].z);\n            }\n            tool.addIndices(tool.indicieIndex + 2, tool.indicieIndex + 1, tool.indicieIndex, tool.indicieIndex + 3, tool.indicieIndex + 2, tool.indicieIndex);\n            tool.addNormals(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0);\n            tool.indicieIndex += 4;\n        },\n    },\n    create(tool, direction, origin, dimensions, flip, transform) {\n        this.width = dimensions.width / 2;\n        this.height = dimensions.height / 2;\n        this.faceFunctions[direction](origin, tool, transform ? transform : this.defaultTransform, flip);\n    },\n};\n","/**\n * |||||||||||||||||||||||||||||||||||||\n * [TOP & BOTTOM]\n * Not Flipped\n *\n * 2: w 0,h 0        3: w 1, h 0\n *          |--------|\n *          |      / |\n *          |   /    |\n *          |/       |\n *          |--------|\n * 1: w 0,h 1        4: w 1,h 1\n *\n * ===============================\n * Flipped\n *\n * 4: w 1,h 0        3: w 0, h 0\n *          |--------|\n *          |\\       |\n *          |   \\    |\n *          |      \\ |\n *          |--------|\n * 1: w 1,h 1        2: w 0, h 1\n *\n *||||||||||||||||||||||||||||||||||||||||\n * [Sides]\n * Not Flipped\n * 4: w 1,h 0        3: w 0, h 0\n *          |--------|\n *          |\\       |\n *          |   \\    |\n *          |      \\ |\n *          |--------|\n * 1: w 1,h 1        2: w 0, h 1\n *\n * ===============================\n * Flipped\n * 2: w 0,h 0        3: w 1, h 0\n *          |--------|\n *          |      / |\n *          |   /    |\n *          |/       |\n *          |--------|\n * 1: w 0,h 1        4: w 1,h 1\n *\n */\nexport const QuadUVs = {\n    uvRotations: {\n        top: {\n            0: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\n                }\n                else {\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\n                }\n            },\n            45: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\n                }\n                else {\n                    uvs.push(0, 0.5, uv, 0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv);\n                }\n            },\n            //-45\n            315: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv, 0.5, 1, uv);\n                }\n                else {\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\n                }\n            },\n            90: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\n                }\n                else {\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\n                }\n            },\n            180: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\n                }\n                else {\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\n                }\n            },\n            270: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\n                }\n                else {\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\n                }\n            },\n            360: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(he, we, uv, he, ws, uv, hs, ws, uv, hs, we, uv);\n                }\n                else {\n                    uvs.push(hs, we, uv, he, we, uv, he, ws, uv, hs, ws, uv);\n                }\n            },\n        },\n        bottom: {\n            0: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\n                }\n                else {\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\n                }\n            },\n            90: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\n                }\n                else {\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\n                }\n            },\n            45: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\n                }\n                else {\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\n                }\n            },\n            //-45\n            315: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv, 0.5, 1, uv);\n                }\n                else {\n                    uvs.push(1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv, 0.5, 1, uv);\n                }\n            },\n            180: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\n                }\n                else {\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\n                }\n            },\n            270: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\n                }\n                else {\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\n                }\n            },\n            360: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(he, ws, uv, hs, hs, uv, hs, we, uv, he, we, uv);\n                }\n                else {\n                    uvs.push(he, we, uv, he, ws, uv, hs, ws, uv, hs, we, uv);\n                }\n            },\n        },\n        side: {\n            0: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\n                }\n                else {\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\n                }\n            },\n            90: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\n                }\n                else {\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\n                }\n            },\n            45: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\n                }\n                else {\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\n                }\n            },\n            //-45\n            315: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv, 0.5, 1, uv);\n                }\n                else {\n                    uvs.push(1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv, 0.5, 1, uv);\n                }\n            },\n            180: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\n                }\n                else {\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\n                }\n            },\n            270: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\n                }\n                else {\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\n                }\n            },\n            360: (uv, ws, we, hs, he, flipped, uvs) => {\n                if (!flipped) {\n                    uvs.push(he, ws, uv, hs, ws, uv, hs, we, uv, he, we, uv);\n                }\n                else {\n                    uvs.push(he, we, uv, he, ws, uv, hs, ws, uv, hs, we, uv);\n                }\n            },\n        },\n    },\n    advancedUVs: {\n        top: (uv, data, uvs, flipped = false) => {\n            if (!flipped) {\n                uvs.push(data.ws1, data.he1, uv, data.ws2, data.hs1, uv, data.we1, data.hs2, uv, data.we2, data.he2, uv);\n            }\n            else {\n                uvs.push(data.ws1, data.he1, uv, data.ws2, data.hs1, uv, data.we1, data.hs2, uv, data.we2, data.he2, uv);\n            }\n        },\n        side: (uv, data, uvs, flipped = false) => {\n            if (!flipped) {\n                uvs.push(data.ws1, data.hs1, uv, data.we1, data.hs2, uv, data.we2, data.he1, uv, data.ws2, data.he2, uv);\n                return;\n            }\n            else {\n                uvs.push(data.ws2, data.he2, uv, data.ws1, data.hs1, uv, data.we1, data.hs2, uv, data.we2, data.he1, uv);\n            }\n        },\n    },\n    uvFunctions: {\n        top: (data) => {\n            QuadUVs.uvRotations.top[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\n        },\n        bottom: (data) => {\n            QuadUVs.uvRotations.bottom[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\n        },\n        north: (data) => {\n            QuadUVs.uvRotations.side[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\n        },\n        south: (data) => {\n            QuadUVs.uvRotations.side[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\n        },\n        east: (data) => {\n            QuadUVs.uvRotations.side[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\n        },\n        west: (data) => {\n            QuadUVs.uvRotations.side[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\n        },\n    },\n    addUVs(data) {\n        this.uvFunctions[data.direction](data);\n    },\n    addAdvancedUVs(direction, uv, uvs, data, flipped) {\n        let d = \"top\";\n        if (direction != \"top\") {\n            d = \"side\";\n        }\n        this.advancedUVs[d](uv, data, uvs, flipped);\n    },\n};\n","import { MeshBuilderTool } from \"../../Tools/MeshBuilderTool.js\";\nimport { MesherDataTool } from \"../../Tools/MesherDataTools.js\";\nimport { NodeBuilder } from \"../Classes/NodeBuilder.js\";\nconst POSFunction = {\n    top: (face) => {\n        const yStart = Math.abs(face.yEnd - (TextureProcessor.height - 1));\n        let y = (yStart + 1) / TextureProcessor.height;\n        let x = (face.xStart + (face.xEnd - face.xStart + 1) / 2) / TextureProcessor.width;\n        return [x, y, 0];\n    },\n    bottom: (face) => {\n        const yStart = Math.abs(face.yEnd - (TextureProcessor.height - 1));\n        let y = yStart / TextureProcessor.height;\n        let x = (face.xStart + (face.xEnd - face.xStart + 1) / 2) / TextureProcessor.width;\n        return [x, y, 0];\n    },\n    east: (face) => {\n        const yStart = Math.abs(face.yEnd - (TextureProcessor.height - 1));\n        let y = (yStart + (face.yEnd - face.yStart + 1) / 2) / TextureProcessor.height;\n        let x = (face.xStart + 1) / TextureProcessor.width;\n        return [x, y, 0];\n    },\n    west: (face) => {\n        const yStart = Math.abs(face.yEnd - (TextureProcessor.height - 1));\n        let y = (yStart + (face.yEnd - face.yStart + 1) / 2) / TextureProcessor.height;\n        let x = face.xEnd / TextureProcessor.width;\n        return [x, y, 0];\n    },\n};\nconst DIMFunction = {\n    top: (face) => {\n        const width = (face.xEnd + 1 - face.xStart) / TextureProcessor.width;\n        return [width, TextureProcessor.depth];\n    },\n    bottom: (face) => {\n        const width = (face.xEnd + 1 - face.xStart) / TextureProcessor.width;\n        return [width, TextureProcessor.depth];\n    },\n    east: (face) => {\n        const height = (face.yEnd - face.yStart + 1) / TextureProcessor.height;\n        return [TextureProcessor.depth, height];\n    },\n    west: (face) => {\n        const height = (face.yEnd - face.yStart + 1) / TextureProcessor.height;\n        return [TextureProcessor.depth, height];\n    },\n};\nconst mesher = new MeshBuilderTool();\nconst mesherData = new MesherDataTool();\nmesherData.attributes.add([[\"cuv3\", [[], 3, \"32f\"]]]);\nmesherData.vars.add([[\"texture\", 0]]);\nmesher.setMesherTool(mesherData);\nconst TextureProcessor = {\n    visitedMap: {\n        top: {},\n        bottom: {},\n        east: {},\n        west: {},\n    },\n    _resetVisitedMap() {\n        this.visitedMap = {\n            top: {},\n            bottom: {},\n            east: {},\n            west: {},\n        };\n    },\n    faceMap: {\n        top: 0,\n        bottom: 1,\n        east: 2,\n        west: 3,\n        south: 4,\n        north: 5,\n    },\n    height: 16,\n    width: 16,\n    depth: 1 / 16,\n    getPosition: POSFunction,\n    getDimensions: DIMFunction,\n    getTruePosition(face) {\n        return {\n            xStart: face.xStart / (this.width - 1),\n            xEnd: face.xEnd / (this.width - 1),\n            yStart: Math.abs(face.yEnd - (this.height - 1)) / (this.height - 1),\n            yEnd: Math.abs(face.yStart - (this.height - 1)) / (this.height - 1),\n        };\n    },\n    processTexture(buildTask) {\n        const [location, type, data] = buildTask;\n        const textureId = data.textureId;\n        const textureData = data.textureData;\n        mesherData.setVar(\"texture\", textureId);\n        const processed = [];\n        this.width = Math.sqrt(textureData.length / 4);\n        this.height = Math.sqrt(textureData.length / 4);\n        let x = 0;\n        let y = 0;\n        for (let i = 0; i < textureData.length; i += 4) {\n            if (!processed[y]) {\n                processed[y] = [];\n            }\n            if (textureData[i + 3]) {\n                processed[y].push(1);\n            }\n            else {\n                processed[y].push(0);\n            }\n            x++;\n            if (x == this.width) {\n                y++;\n                x = 0;\n            }\n        }\n        mesher.quad\n            .setDirection(\"south\")\n            .setDimensions(1, 1)\n            .setPosition(0.5, 0.5, -this.depth / 2)\n            .uvs.setWidth(0, 1)\n            .setHeight(0, 1)\n            .add(mesherData.getVar(\"texture\"))\n            .create()\n            .setDirection(\"north\")\n            .setPosition(0.5, 0.5, this.depth / 2)\n            .uvs.add(mesherData.getVar(\"texture\"))\n            .create();\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                if (!processed[y][x])\n                    continue;\n                const result = this._process(processed, x, y);\n                if (result.t && !this.visited(x, y, \"top\")) {\n                    this.visit(x, y, \"top\");\n                    mesher.quad.setDirection(\"top\");\n                    this.buildFace(this.getTopFace(processed, x, y));\n                }\n                if (result.b && !this.visited(x, y, \"bottom\")) {\n                    this.visit(x, y, \"bottom\");\n                    mesher.quad.setDirection(\"bottom\");\n                    this.buildFace(this.getBottomFace(processed, x, y));\n                }\n                if (result.w && !this.visited(x, y, \"west\")) {\n                    this.visit(x, y, \"west\");\n                    mesher.quad.setDirection(\"west\");\n                    this.buildFace(this.getWestFace(processed, x, y));\n                }\n                if (result.e && !this.visited(x, y, \"east\")) {\n                    this.visit(x, y, \"east\");\n                    mesher.quad.setDirection(\"east\");\n                    this.buildFace(this.getEastFace(processed, x, y));\n                }\n            }\n        }\n        this._resetVisitedMap();\n        const [attributes, transfers] = mesherData.getAllAttributes();\n        mesher.quad.clear();\n        mesherData.resetAll();\n        return [[location, attributes], transfers];\n    },\n    _process(data, x, y) {\n        let addwest = false;\n        let addeast = false;\n        let addbottom = false;\n        let addtop = false;\n        if (!data[y - 1]) {\n            addtop = true;\n        }\n        if (data[y - 1]) {\n            if (!data[y - 1][x]) {\n                addtop = true;\n            }\n        }\n        if (!data[y + 1]) {\n            addbottom = true;\n        }\n        if (data[y + 1]) {\n            if (!data[y + 1][x]) {\n                addbottom = true;\n            }\n        }\n        if (!data[y][x - 1]) {\n            addwest = true;\n        }\n        if (!data[y][x + 1]) {\n            addeast = true;\n        }\n        return {\n            w: addwest,\n            e: addeast,\n            t: addtop,\n            b: addbottom,\n        };\n    },\n    getTopFace(data, sx, y) {\n        const face = this.getBlankFace(sx, y, \"top\");\n        let endX = sx;\n        for (let x = sx; x < this.width; x++) {\n            const result = this._process(data, x, y);\n            this.visit(x, y, \"top\");\n            if (!result.t || !data[y][x] || x == this.width - 1) {\n                if (x == this.width - 1) {\n                    endX = x;\n                }\n                else {\n                    endX = x - 1;\n                }\n                break;\n            }\n        }\n        face.xEnd = endX;\n        return face;\n    },\n    getBottomFace(data, sx, y) {\n        const face = this.getBlankFace(sx, y, \"bottom\");\n        let endX = sx;\n        for (let x = sx; x < this.width; x++) {\n            const result = this._process(data, x, y);\n            this.visit(x, y, \"bottom\");\n            if (!result.b || !data[y][x] || x == this.width - 1) {\n                if (x == this.width - 1) {\n                    endX = x;\n                }\n                else {\n                    endX = x - 1;\n                }\n                break;\n            }\n        }\n        face.xEnd = endX;\n        return face;\n    },\n    getWestFace(data, x, sy) {\n        const face = this.getBlankFace(x, sy, \"west\");\n        let endY = sy;\n        for (let y = sy; y < this.height; y++) {\n            const result = this._process(data, x, y);\n            this.visit(x, y, \"west\");\n            if (!result.w || !data[y][x] || y == this.height - 1) {\n                if (y == this.height - 1) {\n                    endY = y;\n                }\n                else {\n                    endY = y - 1;\n                }\n                break;\n            }\n        }\n        face.yEnd = endY;\n        return face;\n    },\n    getEastFace(data, x, sy) {\n        const face = this.getBlankFace(x, sy, \"east\");\n        let endY = sy;\n        for (let y = sy; y < this.height; y++) {\n            const result = this._process(data, x, y);\n            this.visit(x, y, \"east\");\n            if (!result.e || !data[y][x] || y == this.height - 1) {\n                if (y == this.height - 1) {\n                    endY = y;\n                }\n                else {\n                    endY = y - 1;\n                }\n                break;\n            }\n        }\n        face.yEnd = endY;\n        return face;\n    },\n    getBlankFace(x, y, face) {\n        return {\n            xStart: x,\n            xEnd: x,\n            yStart: y,\n            yEnd: y,\n            type: face,\n        };\n    },\n    visit(x, y, face) {\n        this.visitedMap[face][`${x}-${y}`] = true;\n    },\n    visited(x, y, face) {\n        return this.visitedMap[face][`${x}-${y}`];\n    },\n    calculateUV(face) {\n        const ws = face.xStart / this.width;\n        const we = (face.xEnd + 1) / this.width;\n        const hs = face.yStart / this.height;\n        const he = (face.yEnd + 1) / this.height;\n        return [ws, we, hs, he];\n    },\n    buildFace(face) {\n        const uv = this.calculateUV(face);\n        const dim = this.getDimensions[face.type](face);\n        const pos = this.getPosition[face.type](face);\n        mesher.quad\n            .setDimensions(dim[0], dim[1])\n            .setPosition(pos[0], pos[1], pos[2])\n            .uvs.setWidth(uv[0], uv[1])\n            .setHeight(uv[2], uv[3])\n            .add(mesherData.getVar(\"texture\"))\n            .create();\n    },\n};\nclass TXTBuilderBase extends NodeBuilder {\n    build(data) {\n        return TextureProcessor.processTexture(data);\n    }\n}\nexport const TextureBuilder = new TXTBuilderBase(\"#dve_node_texture\");\n","import { NodeBuilder } from \"../Classes/NodeBuilder.js\";\nimport { BuilderDataTool } from \"../../Tools/BuilderDataTool.js\";\nimport { RenderedSubstances } from \"../../Rules/RenderedSubstances.js\";\nimport { ShapeTool } from \"../../Shapes/ShapeTool.js\";\nclass VoxelBuilderBase extends NodeBuilder {\n    id;\n    dataTool = new BuilderDataTool();\n    constructor(id) {\n        super(id);\n        this.id = id;\n        this.dataTool.setMode(BuilderDataTool.VOXEL_DATA_MODE);\n    }\n    build([location, type, rawVoxelData]) {\n        if (!this.dataTool.loadInRaw(rawVoxelData).isRenderable())\n            return false;\n        const constructor = this.dataTool.getConstructor();\n        const mesher = RenderedSubstances.meshers.get(this.dataTool.getSubstnaceData().getRendered());\n        if (!mesher || !constructor)\n            return false;\n        mesher.voxel.loadInRaw(rawVoxelData).setMode(BuilderDataTool.VOXEL_DATA_MODE);\n        mesher.nVoxel\n            .loadInRaw(rawVoxelData)\n            .setMode(BuilderDataTool.VOXEL_DATA_MODE);\n        ShapeTool.setMesher(mesher);\n        ShapeTool.builder.quad.clear().setPosition(0, 0, 0);\n        constructor.process(mesher);\n        mesher.resetSegments();\n        mesher.resetVars();\n        const [attributes, buffers] = mesher.getAllAttributes();\n        mesher.voxel.loadInRaw(rawVoxelData).setMode(BuilderDataTool.WORLD_DATA_MODE);\n        mesher.nVoxel\n            .loadInRaw(rawVoxelData)\n            .setMode(BuilderDataTool.WORLD_DATA_MODE);\n        return [[location, attributes], buffers];\n    }\n}\nexport const VoxelBuilder = new VoxelBuilderBase(\"#dve_node_voxel\");\n","export class NodeBuilder {\n    id;\n    constructor(id) {\n        this.id = id;\n    }\n}\n","import { TextureBuilder } from \"./Builders/TextureBuilder.js\";\nimport { VoxelBuilder } from \"./Builders/VoxelBuilder.js\";\nexport const NodeBuilderManager = {\n    builders: new Map(),\n    registerBuilder(builder) {\n        this.builders.set(builder.id, builder);\n    },\n    buildNode(data) {\n        const builder = this.builders.get(data[1]);\n        if (!builder)\n            return false;\n        return builder.build(data);\n    },\n};\nNodeBuilderManager.registerBuilder(TextureBuilder);\nNodeBuilderManager.registerBuilder(VoxelBuilder);\n","import { RenderedSubstances } from \"../Rules/RenderedSubstances.js\";\nimport { DVEC } from \"../../DivineVoxelEngineConstructor.js\";\n//data\nimport { WorldSpaces } from \"../../../Data/World/WorldSpaces.js\";\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\n//tools\nimport { HeightMapTool } from \"../../../Tools/Data/WorldData/HeightMapTool.js\";\nimport { BuilderDataTool } from \"../Tools/BuilderDataTool.js\";\nimport { ShapeTool } from \"../Shapes/ShapeTool.js\";\nconst mDataTool = new BuilderDataTool();\nconst heightMapTool = new HeightMapTool();\nexport const ChunkProcessor = {\n    relative: { x: 0, y: 0, z: 0 },\n    nLocation: [\"main\", 0, 0, 0],\n    _states: {\n        foundVoxel: false,\n    },\n    _process(doSecondCheck = false) {\n        if (!mDataTool.loadInAtLocation(this.nLocation))\n            return;\n        if (!mDataTool.isRenderable())\n            return;\n        this._states.foundVoxel = true;\n        if (!doSecondCheck) {\n            if (mDataTool.hasSecondaryVoxel()) {\n                this._process(true);\n            }\n        }\n        const constructor = mDataTool.getConstructor();\n        const mesher = RenderedSubstances.meshers.get(mDataTool.getSubstnaceData().getRendered());\n        if (!mesher || !constructor)\n            return;\n        const voxelPOS = WorldSpaces.voxel.setLocation(this.nLocation).getPosition();\n        mesher.voxel.loadInAtLocation(this.nLocation);\n        mesher.nVoxel.loadInAtLocation(this.nLocation);\n        ShapeTool.setMesher(mesher);\n        ShapeTool.builder.quad\n            .clear()\n            .setPosition(voxelPOS.x, voxelPOS.y, voxelPOS.z);\n        constructor.process(mesher);\n        mesher.resetSegments();\n        mesher.resetVars();\n    },\n    build(location) {\n        WorldRegister.cache.enable();\n        heightMapTool.chunk.loadInAtLocation(location);\n        mDataTool.setDimension(location[0]);\n        const [dimension, cx, cy, cz] = location;\n        this.nLocation[0] = dimension;\n        let index = 0;\n        let lastY = -Infinity;\n        const maxIndex = WorldSpaces.chunk.getVolume();\n        while (index < maxIndex) {\n            const { x, y, z } = WorldSpaces.voxel.getIndexToXYZ(index);\n            if (y != lastY) {\n                this._states.foundVoxel = false;\n                heightMapTool.chunk.setY(y);\n                if (!heightMapTool.chunk.hasVoxels() && !heightMapTool.chunk.isDirty()) {\n                    index += WorldSpaces.chunk.getIndexXYZ(0, 1, 0);\n                    lastY = y;\n                    continue;\n                }\n            }\n            this.nLocation[1] = x + cx;\n            this.nLocation[2] = y + cy;\n            this.nLocation[3] = z + cz;\n            this._process();\n            if (y != lastY) {\n                if (heightMapTool.chunk.isDirty()) {\n                    heightMapTool.chunk.setHasVoxels(this._states.foundVoxel);\n                    heightMapTool.chunk.setDirty(false);\n                }\n            }\n            lastY = y;\n            index++;\n        }\n        WorldRegister.cache.disable();\n        const chunks = [location, []];\n        const trasnfers = [];\n        for (const [substance, mesher] of RenderedSubstances.meshers._map) {\n            if (mesher.getAttribute(\"position\").length == 0) {\n                chunks[1].push([substance, false]);\n                mesher.resetAll();\n                continue;\n            }\n            const [attributes, buffers] = mesher.getAllAttributes();\n            trasnfers.push(...buffers);\n            chunks[1].push([substance, [location, attributes]]);\n            mesher.resetAll();\n        }\n        DVEC.parentComm.runTasks(\"set-chunk\", chunks, trasnfers);\n    },\n};\n","export const OverrideManager = {\n    overrides: {\n        AO: new Map(),\n        AOFlipFace: new Map(),\n        CullFace: new Map(),\n        FlipFace: new Map(),\n        DarkenFaceUnderneath: new Map(),\n    },\n    registerOverride(type, subjectId, neighborShapeId, run) {\n        let map = this.overrides[type].get(subjectId);\n        if (!map) {\n            map = new Map();\n            this.overrides[type].set(subjectId, map);\n        }\n        map.set(neighborShapeId, run);\n    },\n    hasOverride(type, shapeId, neighborShapeId) {\n        let map = this.overrides[type].get(shapeId);\n        if (!map)\n            return false;\n        return map.has(neighborShapeId);\n    },\n    runOverride(type, firstId, secondOverride, data) {\n        let map = this.overrides[type].get(firstId);\n        if (!map)\n            return data.default;\n        const run = map.get(secondOverride);\n        if (!run)\n            return data.default;\n        return run(data);\n    },\n};\n","import { UtilMap } from \"../../../Global/Util/UtilMap.js\";\nimport { VoxelMesherDataTool } from \"../Tools/VoxelMesherDataTool.js\";\nexport const RenderedSubstances = {\n    meshers: new UtilMap(),\n    add(id) {\n        this.meshers.set(id, new VoxelMesherDataTool());\n    },\n};\n","//types\nimport { MappedDataRegister } from \"../../../Data/Register/MappedDataRegister.js\";\nimport { SubstanceDataTool } from \"../../../Tools/Data/SubstanceDataTool.js\";\nimport { RenderedSubstances } from \"./RenderedSubstances.js\";\nexport const SubstanceRules = {\n    rules: new Map(),\n    parents: new Map(),\n    registerSubstance(id, substanceCulls, parentId) {\n        const map = new Map();\n        this.rules.set(id, map);\n        if (substanceCulls) {\n            for (const culls of substanceCulls) {\n                map.set(culls, true);\n            }\n        }\n        if (parentId) {\n            this.parents.set(id, parentId);\n            return;\n        }\n        this.parents.set(id, id);\n    },\n    $BuildRules() {\n        const substanceTool = new SubstanceDataTool();\n        const allSubstances = MappedDataRegister.stringMaps.segments\n            .get(\"voxel\")\n            .get(\"#dve_substance\");\n        for (const substnace of allSubstances) {\n            substanceTool.setSubstance(substnace);\n            const parent = substanceTool.getParent();\n            const rendered = substanceTool.getRendered();\n            const culled = substanceTool.getCulled();\n            SubstanceRules.registerSubstance(substnace, culled, parent);\n            if (!RenderedSubstances.meshers.has(rendered)) {\n                RenderedSubstances.add(rendered);\n            }\n        }\n    },\n    exposedCheck(subject, neightborVoxel) {\n        const rules = this.rules.get(subject);\n        if (!rules)\n            return true;\n        if (rules.has(neightborVoxel))\n            return false;\n        return true;\n    },\n    getSubstanceParent(id) {\n        return this.parents.get(id);\n    },\n};\n","import { QuadVertexData } from \"../../Classes/VertexData.js\";\nimport { LightData } from \"../../../../Data/Light/LightByte.js\";\nimport { ShapeTool } from \"../ShapeTool.js\";\nconst LightValue = new QuadVertexData();\nconst AOValue = new QuadVertexData();\nconst getIndex = (v) => {\n    return Math.abs(v);\n};\nexport const ShapeBuilder = {\n    build(quads) {\n        const aoData = ShapeTool.data.getWorldAO();\n        const lightData = ShapeTool.data.getWorldLight();\n        for (const quad of quads) {\n            if (quad[6] >= 0) {\n                ShapeTool.builder.quad.setFlipped(quad[6] == 1);\n            }\n            ShapeTool.builder.quad\n                .setDimensions(quad[1][0], quad[1][1])\n                .setDirection(quad[0])\n                .updatePosition(quad[2][0], quad[2][1], quad[2][2])\n                .textures.setRoation(quad[5][0])\n                .setWidth(quad[5][1], quad[5][2])\n                .setHeight(quad[5][3], quad[5][4])\n                .add(ShapeTool.data.getTexture())\n                .overlayTexture.add(ShapeTool.data.getOverlayTextures());\n            AOValue.setAll(0);\n            AOValue.set(quad[3][0] < 0 ? aoData.vetexes[getIndex(quad[3][0])] : quad[3][0], quad[3][1] < 0 ? aoData.vetexes[getIndex(quad[3][1])] : quad[3][1], quad[3][2] < 0 ? aoData.vetexes[getIndex(quad[3][2])] : quad[3][2], quad[3][3] < 0 ? aoData.vetexes[getIndex(quad[3][3])] : quad[3][3]);\n            ShapeTool.builder.quad.AO.add(AOValue);\n            LightValue.setAll(0);\n            if (quad[4][0] == -5) {\n                this._getBrightestLight(lightData);\n            }\n            else {\n                LightValue.set(quad[4][0] < 0 ? lightData.vetexes[getIndex(quad[4][0])] : quad[4][0], quad[4][1] < 0 ? lightData.vetexes[getIndex(quad[4][1])] : quad[4][1], quad[4][2] < 0 ? lightData.vetexes[getIndex(quad[4][2])] : quad[4][2], quad[4][3] < 0 ? lightData.vetexes[getIndex(quad[4][3])] : quad[4][3]);\n            }\n            ShapeTool.builder.quad.light.add(LightValue);\n            ShapeTool.builder.quad.create().textures.clear().clearTransform();\n        }\n    },\n    _getBrightestLight(data) {\n        let s = 0;\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        data.forEach((v, nl) => {\n            const sl = LightData.getS(nl);\n            if (sl > s) {\n                s = sl;\n            }\n            const rl = LightData.getR(nl);\n            if (rl > r) {\n                r = rl;\n            }\n            const gl = LightData.getG(nl);\n            if (gl > g) {\n                g = gl;\n            }\n            const bl = LightData.getB(nl);\n            if (bl > b) {\n                b = bl;\n            }\n        });\n        let rl = LightData.setS(s, 0);\n        rl = LightData.setR(r, rl);\n        rl = LightData.setG(g, rl);\n        rl = LightData.setB(b, rl);\n        LightValue.setAll(rl);\n    },\n};\n","import { VoxelShapeTool } from \"../Tools/VoxelShapeTool.js\";\nexport class ShapeToolType {\n    data = {};\n    builder = new VoxelShapeTool();\n    setMesher(dataTool) {\n        this.data = dataTool;\n        this.builder.quad.setMesherTool(dataTool);\n    }\n}\nexport const ShapeTool = new ShapeToolType();\n","import { OverrideManager } from \"../../../Rules/Overrides/OverridesManager.js\";\nimport { ShapeTool } from \"../../ShapeTool.js\";\nimport { QuadVertexData } from \"../../../Classes/VertexData.js\";\nconst animationState = new QuadVertexData();\nexport const BoxVoxelShape = {\n    _createFace() {\n        animationState.setAll(ShapeTool.data.voxel.getSubstance() == \"#dve_flora\" ? 3 : 0);\n        ShapeTool.builder.quad\n            .setDimensions(1, 1)\n            .setFlipped(ShapeTool.data.isFaceFlipped())\n            .AO.add(ShapeTool.data.getWorldAO())\n            .light.add(ShapeTool.data.getWorldLight())\n            .textures.add(ShapeTool.data.getTexture())\n            .overlayTexture.add(ShapeTool.data.getOverlayTextures())\n            .animationState.add(animationState)\n            .create();\n    },\n    add: {\n        top() {\n            ShapeTool.builder.quad.setDirection(\"top\").updatePosition(0.5, 1, 0.5);\n            BoxVoxelShape._createFace();\n        },\n        bottom() {\n            ShapeTool.builder.quad.setDirection(\"bottom\").updatePosition(0.5, 0, 0.5);\n            BoxVoxelShape._createFace();\n        },\n        north() {\n            ShapeTool.builder.quad.setDirection(\"north\").updatePosition(0.5, 0.5, 1);\n            BoxVoxelShape._createFace();\n        },\n        south() {\n            ShapeTool.builder.quad.setDirection(\"south\").updatePosition(0.5, 0.5, 0);\n            BoxVoxelShape._createFace();\n        },\n        east() {\n            ShapeTool.builder.quad.setDirection(\"east\").updatePosition(1, 0.5, 0.5);\n            BoxVoxelShape._createFace();\n        },\n        west() {\n            ShapeTool.builder.quad.setDirection(\"west\").updatePosition(0, 0.5, 0.5);\n            BoxVoxelShape._createFace();\n        },\n    },\n};\n//cullface\nOverrideManager.registerOverride(\"CullFace\", \"#dve_box\", \"#dve_box\", (data) => {\n    return BoxCullFunctions[data.face](data);\n});\nOverrideManager.registerOverride(\"CullFace\", \"#dve_box\", \"Panel\", (data) => {\n    return true;\n});\nOverrideManager.registerOverride(\"DarkenFaceUnderneath\", \"#dve_box\", \"All\", (data) => {\n    return true;\n});\nOverrideManager.registerOverride(\"CullFace\", \"#dve_box\", \"#dve_halfbox\", (data) => {\n    if (data.face == \"top\") {\n        if (data.neighborVoxel.getShapeState() == 0) {\n            return true;\n        }\n        return false;\n    }\n    return true;\n});\nOverrideManager.registerOverride(\"CullFace\", \"#dve_box\", \"#dve_stair\", (data) => {\n    StairCullFunctions[data.face](data);\n    return true;\n});\n//ao\nOverrideManager.registerOverride(\"AO\", \"#dve_box\", \"Panel\", (data) => {\n    return false;\n});\nOverrideManager.registerOverride(\"AO\", \"#dve_box\", \"#dve_half_box\", (data) => {\n    if (data.face == \"top\") {\n        if (data.neighborVoxel.getShapeState() == 0) {\n            return true;\n        }\n        return false;\n    }\n    return true;\n});\nconst StairCullFunctions = {\n    top: (data) => {\n        const nVoxelShapeState = data.neighborVoxel.getShapeState();\n        if ((nVoxelShapeState >= 0 && nVoxelShapeState <= 3) ||\n            (nVoxelShapeState >= 8 && nVoxelShapeState <= 11)) {\n            return false;\n        }\n        return true;\n    },\n    bottom: (data) => {\n        const nVoxelShapeState = data.neighborVoxel.getShapeState();\n        if ((nVoxelShapeState >= 4 && nVoxelShapeState <= 7) ||\n            (nVoxelShapeState >= 12 && nVoxelShapeState <= 15)) {\n            return false;\n        }\n        return true;\n    },\n    east: (data) => {\n        const nVoxelShapeState = data.neighborVoxel.getShapeState();\n        if (nVoxelShapeState == 1 || nVoxelShapeState == 5)\n            return false;\n        return true;\n    },\n    west: (data) => {\n        const nVoxelShapeState = data.neighborVoxel.getShapeState();\n        if (nVoxelShapeState == 3 || nVoxelShapeState == 7)\n            return false;\n        return true;\n    },\n    north: (data) => {\n        const nVoxelShapeState = data.neighborVoxel.getShapeState();\n        if (nVoxelShapeState == 0 || nVoxelShapeState == 4)\n            return false;\n        return true;\n    },\n    south: (data) => {\n        const nVoxelShapeState = data.neighborVoxel.getShapeState();\n        if (nVoxelShapeState == 2 || nVoxelShapeState == 6)\n            return false;\n        return true;\n    },\n};\n//cull leaf faces\nconst BoxCullFunctions = {\n    top: (data) => {\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2] + 1, data.currentVoxel.location[3]) &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2] + 2, data.currentVoxel.location[3])) {\n            return false;\n        }\n        return data.default;\n    },\n    bottom: (data) => {\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2] - 1, data.currentVoxel.location[3]) &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2] - 2, data.currentVoxel.location[3])) {\n            return false;\n        }\n        return data.default;\n    },\n    east: (data) => {\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1] + 1, data.currentVoxel.location[2], data.currentVoxel.location[3]) &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1] + 2, data.currentVoxel.location[2], data.currentVoxel.location[3])) {\n            return false;\n        }\n        return data.default;\n    },\n    west: (data) => {\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1] - 1, data.currentVoxel.location[2], data.currentVoxel.location[3]) &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1] - 2, data.currentVoxel.location[2], data.currentVoxel.location[3])) {\n            return false;\n        }\n        return data.default;\n    },\n    north: (data) => {\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2], data.currentVoxel.location[3] + 1) &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2], data.currentVoxel.location[3] + 2)) {\n            return false;\n        }\n        return data.default;\n    },\n    south: (data) => {\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2], data.currentVoxel.location[3] - 1) &&\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2], data.currentVoxel.location[3] - 2)) {\n            return false;\n        }\n        return data.default;\n    },\n};\n","import { OverrideManager } from \"../../../Rules/Overrides/OverridesManager.js\";\nimport { ShapeTool } from \"../../ShapeTool.js\";\nimport { QuadVertexData } from \"../../../Classes/VertexData.js\";\nconst animationState = new QuadVertexData();\nexport const HalfBoxVoxelShape = {\n    _createFace() {\n        animationState.setAll(ShapeTool.data.voxel.getSubstance() == \"#dve_flora\" ? 3 : 0);\n        ShapeTool.builder.quad\n            .setFlipped(ShapeTool.data.isFaceFlipped())\n            .AO.add(ShapeTool.data.getWorldAO())\n            .light.add(ShapeTool.data.getWorldLight())\n            .textures.add(ShapeTool.data.getTexture())\n            .overlayTexture.add(ShapeTool.data.getOverlayTextures())\n            .animationState.add(animationState)\n            .create()\n            .clear();\n    },\n    add: {\n        top() {\n            ShapeTool.builder.quad\n                .setDirection(\"top\")\n                .setDimensions(1, 1)\n                .updatePosition(0.5, ShapeTool.data.voxel.getState() == 0 ? 0.5 : 1, 0.5);\n            HalfBoxVoxelShape._createFace();\n        },\n        bottom() {\n            ShapeTool.builder.quad\n                .setDirection(\"bottom\")\n                .setDimensions(1, 1)\n                .updatePosition(0.5, ShapeTool.data.voxel.getState() == 0 ? 0 : 0.5, 0.5);\n            HalfBoxVoxelShape._createFace();\n        },\n        north() {\n            ShapeTool.builder.quad\n                .setDirection(\"north\")\n                .setDimensions(1, 0.5)\n                .textures.setHeight(0.5, 1)\n                .quad.updatePosition(0.5, ShapeTool.data.voxel.getState() == 0 ? 0.5 : 0.75, 1);\n            HalfBoxVoxelShape._createFace();\n        },\n        south() {\n            ShapeTool.builder.quad\n                .setDirection(\"south\")\n                .setDimensions(1, 0.5)\n                .textures.setHeight(0.5, 1)\n                .quad.updatePosition(0.5, ShapeTool.data.voxel.getState() == 0 ? 0.5 : 0.75, 0);\n            HalfBoxVoxelShape._createFace();\n        },\n        east() {\n            ShapeTool.builder.quad\n                .setDirection(\"east\")\n                .setDimensions(1, 0.5)\n                .textures.setHeight(0.5, 1)\n                .quad.updatePosition(1, ShapeTool.data.voxel.getState() == 0 ? 0.5 : 0.75, 0.5);\n            HalfBoxVoxelShape._createFace();\n        },\n        west() {\n            ShapeTool.builder.quad\n                .setDirection(\"west\")\n                .setDimensions(1, 0.5)\n                .textures.setHeight(0.5, 1)\n                .quad.updatePosition(0, ShapeTool.data.voxel.getState() == 0 ? 0.5 : 0.75, 0.5);\n            HalfBoxVoxelShape._createFace();\n        },\n    },\n};\n//cullface\nOverrideManager.registerOverride(\"CullFace\", \"#dve_half_box\", \"#dve_panel\", (data) => {\n    return false;\n});\nOverrideManager.registerOverride(\"CullFace\", \"#dve_half_box\", \"#dve_box\", (data) => {\n    if (data.face == \"bottom\") {\n        if (data.currentVoxel.getShapeState() == 0) {\n            return false;\n        }\n    }\n    if (data.face == \"top\") {\n        if (data.currentVoxel.getShapeState() == 1) {\n            return false;\n        }\n    }\n    return true;\n});\nOverrideManager.registerOverride(\"CullFace\", \"#dve_half_box\", \"#dve_stair\", (data) => {\n    return data.default;\n});\n//AO\nOverrideManager.registerOverride(\"AO\", \"#dve_half_box\", \"#dve_panel\", (data) => {\n    return false;\n});\nOverrideManager.registerOverride(\"AO\", \"#dve_half_box\", \"#dve_box\", (data) => {\n    const shapeState = data.currentVoxel.getShapeState();\n    if (shapeState == 1) {\n        if (data.face == \"top\") {\n            if (data.neighborVoxel.location[2] > data.currentVoxel.location[2]) {\n                return true;\n            }\n        }\n        if (data.neighborVoxel.location[2] == data.currentVoxel.location[2]) {\n            return true;\n        }\n        return false;\n    }\n    return data.default;\n});\n","import { OverrideManager } from \"../../../Rules/Overrides/OverridesManager.js\";\nimport { ShapeTool } from \"../../ShapeTool.js\";\nimport { QuadVertexData } from \"../../../Classes/VertexData.js\";\n//objects\nconst addData = (face) => {\n    return ShapeTool.builder.quad\n        .setDirection(face)\n        .setFlipped(ShapeTool.data.isFaceFlipped())\n        .light.add(ShapeTool.data.getWorldLight())\n        .textures.add(ShapeTool.data.getTexture())\n        .overlayTexture.add(ShapeTool.data.getOverlayTextures())\n        .animationState.add(flowAnimationState);\n};\nconst flowAnimationState = new QuadVertexData();\nconst vertexValue = new QuadVertexData();\nconst vertexLevel = new QuadVertexData();\nlet topFaceExposed = false;\nexport const LiquidVoxelShape = {\n    id: \"#dve_liquid\",\n    start() {\n        topFaceExposed = false;\n        ShapeTool.builder.quad.setDimensions(1, 1).textures.setRoation(0);\n        flowAnimationState.setAll(0);\n        vertexLevel.setAll(15);\n        vertexValue.setAll(0);\n    },\n    add: {\n        top() {\n            topFaceExposed = true;\n            ShapeTool.data.calculateFlow();\n            vertexLevel.setFromQuadData(ShapeTool.data.getWorldLevel());\n            vertexValue.set(vertexLevel.vetexes[1] / 15 - 1, vertexLevel.vetexes[2] / 15 - 1, vertexLevel.vetexes[3] / 15 - 1, vertexLevel.vetexes[4] / 15 - 1);\n            ShapeTool.builder.quad\n                .setTransform(1, 0, vertexValue.vetexes[1], 0)\n                .setTransform(2, 0, vertexValue.vetexes[2], 0)\n                .setTransform(3, 0, vertexValue.vetexes[3], 0)\n                .setTransform(4, 0, vertexValue.vetexes[4], 0)\n                .textures.setRoation(getAngle());\n            addData(\"top\")\n                .updatePosition(0.5, 1, 0.5)\n                .create()\n                .clearTransform()\n                .textures.clear();\n        },\n        bottom() {\n            flowAnimationState.setAll(0);\n            addData(\"bottom\")\n                .updatePosition(0.5, 0, 0.5)\n                .create()\n                .clearTransform()\n                .textures.clear();\n        },\n        north() {\n            flowAnimationState.setAll(1);\n            ShapeTool.builder.quad\n                .setDirection(\"north\")\n                .updatePosition(0.5, 0.5, 1)\n                .setTransform(1, 0, vertexValue.vetexes[3], 0)\n                .setTransform(2, 0, vertexValue.vetexes[2], 0)\n                .light.add(ShapeTool.data.getWorldLight())\n                .overlayTexture.add(ShapeTool.data.getOverlayTextures())\n                .animationState.add(flowAnimationState);\n            if (topFaceExposed) {\n                ShapeTool.builder.quad.textures.advancedUVs.hs1 = Math.abs(vertexValue.vetexes[3]);\n                ShapeTool.builder.quad.textures.advancedUVs.hs2 = Math.abs(vertexValue.vetexes[2]);\n                ShapeTool.builder.quad.textures.addAdvancedUVs(ShapeTool.data.getTexture());\n            }\n            else {\n                ShapeTool.builder.quad.textures.add(ShapeTool.data.getTexture());\n            }\n            ShapeTool.builder.quad.create().clearTransform().textures.clear();\n        },\n        south() {\n            flowAnimationState.setAll(1);\n            ShapeTool.builder.quad\n                .setDirection(\"south\")\n                .updatePosition(0.5, 0.5, 0)\n                .setTransform(1, 0, vertexValue.vetexes[1], 0)\n                .setTransform(2, 0, vertexValue.vetexes[4], 0)\n                .light.add(ShapeTool.data.getWorldLight())\n                .overlayTexture.add(ShapeTool.data.getOverlayTextures())\n                .animationState.add(flowAnimationState);\n            if (topFaceExposed) {\n                ShapeTool.builder.quad.textures.advancedUVs.hs1 = Math.abs(vertexValue.vetexes[1]);\n                ShapeTool.builder.quad.textures.advancedUVs.hs2 = Math.abs(vertexValue.vetexes[4]);\n                ShapeTool.builder.quad.textures.addAdvancedUVs(ShapeTool.data.getTexture());\n            }\n            else {\n                ShapeTool.builder.quad.textures.add(ShapeTool.data.getTexture());\n            }\n            ShapeTool.builder.quad.create().clearTransform().textures.clear();\n        },\n        east() {\n            flowAnimationState.setAll(1);\n            ShapeTool.builder.quad\n                .setDirection(\"east\")\n                .updatePosition(1, 0.5, 0.5)\n                .setTransform(1, 0, vertexValue.vetexes[4], 0)\n                .setTransform(2, 0, vertexValue.vetexes[3], 0)\n                .light.add(ShapeTool.data.getWorldLight())\n                .overlayTexture.add(ShapeTool.data.getOverlayTextures())\n                .animationState.add(flowAnimationState);\n            if (topFaceExposed) {\n                ShapeTool.builder.quad.textures.advancedUVs.hs1 = Math.abs(vertexValue.vetexes[4]);\n                ShapeTool.builder.quad.textures.advancedUVs.hs2 = Math.abs(vertexValue.vetexes[3]);\n                ShapeTool.builder.quad.textures.addAdvancedUVs(ShapeTool.data.getTexture());\n            }\n            else {\n                ShapeTool.builder.quad.textures.add(ShapeTool.data.getTexture());\n            }\n            ShapeTool.builder.quad.create().clearTransform().textures.clear();\n        },\n        west() {\n            flowAnimationState.setAll(1);\n            ShapeTool.builder.quad\n                .setDirection(\"west\")\n                .updatePosition(0, 0.5, 0.5)\n                .setTransform(1, 0, vertexValue.vetexes[2], 0)\n                .setTransform(2, 0, vertexValue.vetexes[1], 0)\n                .light.add(ShapeTool.data.getWorldLight())\n                .overlayTexture.add(ShapeTool.data.getOverlayTextures())\n                .animationState.add(flowAnimationState);\n            if (topFaceExposed) {\n                ShapeTool.builder.quad.textures.advancedUVs.hs1 = Math.abs(vertexValue.vetexes[2]);\n                ShapeTool.builder.quad.textures.advancedUVs.hs2 = Math.abs(vertexValue.vetexes[1]);\n                ShapeTool.builder.quad.textures.addAdvancedUVs(ShapeTool.data.getTexture());\n            }\n            else {\n                ShapeTool.builder.quad.textures.add(ShapeTool.data.getTexture());\n            }\n            ShapeTool.builder.quad.create().clearTransform().textures.clear();\n        },\n    },\n};\nOverrideManager.registerOverride(\"CullFace\", \"#dve_liquid\", \"Any\", (data) => {\n    if (data.face == \"top\" &&\n        data.neighborVoxel.getSubstnaceData().isLiquid() &&\n        data.currentVoxel.getStringId() != data.neighborVoxel.getStringId()) {\n        return true;\n    }\n    return data.default;\n});\nconst getAngle = () => {\n    if (vertexLevel.isAllEqualTo(15)) {\n        flowAnimationState.setAll(0);\n        return 0;\n    }\n    const v1 = vertexLevel.vetexes[1];\n    const v2 = vertexLevel.vetexes[2];\n    const v3 = vertexLevel.vetexes[3];\n    const v4 = vertexLevel.vetexes[4];\n    if (v1 == v2 && v3 == v4 && v1 == v4 && v2 == v3) {\n        flowAnimationState.setAll(0);\n        return 0;\n    }\n    if (v2 == v3 && v1 == v4 && v2 > v1) {\n        //flowing south\n        flowAnimationState.setAll(1);\n        return 0;\n    }\n    if (v2 == v3 && v1 == v4 && v2 < v1) {\n        //flowing north\n        flowAnimationState.setAll(2);\n        return 0;\n    }\n    if (v2 == v1 && v3 == v4 && v1 > v4) {\n        //flowing east\n        flowAnimationState.setAll(2);\n        return 90;\n    }\n    if (v3 == v4 && v2 == v1 && v4 > v1) {\n        //flowing west\n        flowAnimationState.setAll(1);\n        return 90;\n    }\n    if (v2 < v4) {\n        //flowing north west\n        flowAnimationState.setAll(2);\n        return 315;\n    }\n    if (v2 > v4) {\n        //flowing south east\n        flowAnimationState.setAll(1);\n        return 315;\n    }\n    if (v1 > v3) {\n        //flowing north east\n        flowAnimationState.setAll(2);\n        return 45;\n    }\n    if (v1 < v3) {\n        //flowing south west\n        flowAnimationState.setAll(1);\n        return 45;\n    }\n    return 0;\n};\n","import { ShapeTool } from \"../../ShapeTool.js\";\nimport { QuadVertexData } from \"../../../Classes/VertexData.js\";\nconst animationState = new QuadVertexData();\nconst addData = () => {\n    return ShapeTool.builder.quad.light\n        .add(ShapeTool.data.getWorldLight())\n        .AO.add(ShapeTool.data.getWorldAO())\n        .textures.add(ShapeTool.data.getTexture())\n        .overlayTexture.add(ShapeTool.data.getOverlayTextures());\n};\nexport const CrossedPanels = {\n    id: \"#dve_crossed_panels\",\n    build() {\n        let topANIM = 0;\n        let bottomANIM = 0;\n        if (ShapeTool.data.voxel.getSubstance() == \"#dve_flora\") {\n            if (ShapeTool.data.voxel.isSameVoxel(ShapeTool.data.voxel.x, ShapeTool.data.voxel.y + 1, ShapeTool.data.voxel.z)) {\n                topANIM = 3;\n                bottomANIM = 3;\n            }\n            else {\n                topANIM = 1;\n            }\n        }\n        animationState.set(topANIM, topANIM, bottomANIM, bottomANIM);\n        ShapeTool.builder.quad.setDimensions(1, 1);\n        addData()\n            .setDirection(\"north\")\n            .setFlipped(false)\n            .animationState.add(animationState)\n            .updatePosition(0.5, 0.5, 1)\n            .setTransform(1, 0, 0, -1)\n            .setTransform(4, 0, 0, -1)\n            .create()\n            .clearTransform();\n        addData()\n            .setDirection(\"north\")\n            .setFlipped(false)\n            .animationState.add(animationState)\n            .updatePosition(0.5, 0.5, 0)\n            .setTransform(1, 0, 0, 1)\n            .setTransform(4, 0, 0, 1)\n            .create()\n            .clearTransform();\n        addData()\n            .setDirection(\"south\")\n            .setFlipped(false)\n            .animationState.add(animationState)\n            .updatePosition(0.5, 0.5, 0)\n            .setTransform(1, 0, 0, 1)\n            .setTransform(4, 0, 0, 1)\n            .create()\n            .clearTransform();\n        addData()\n            .setDirection(\"south\")\n            .setFlipped(false)\n            .animationState.add(animationState)\n            .updatePosition(0.5, 0.5, 1)\n            .setTransform(1, 0, 0, -1)\n            .setTransform(4, 0, 0, -1)\n            .create()\n            .clearTransform();\n    },\n};\n","import { QuadVertexData } from \"../../../Classes/VertexData.js\";\nimport { OverrideManager } from \"../../../Rules/Overrides/OverridesManager.js\";\nimport { ShapeTool } from \"../../ShapeTool.js\";\nconst animationState = new QuadVertexData();\nconst addData = () => {\n    return ShapeTool.builder.quad\n        .setDimensions(1, 1)\n        .animationState.add(animationState)\n        .light.add(ShapeTool.data.getWorldLight())\n        .AO.add(ShapeTool.data.getWorldAO())\n        .textures.add(ShapeTool.data.getTexture())\n        .overlayTexture.add(ShapeTool.data.getOverlayTextures());\n};\nconst shapeStates = {\n    0: () => {\n        addData().updatePosition(0.5, 0.5, 0.05).setDirection(\"south\").create();\n        addData().setDirection(\"north\").create().clear();\n    },\n    1: () => {\n        addData().updatePosition(0.5, 0.5, 0.95).setDirection(\"north\").create();\n        addData().setDirection(\"south\").create().clear();\n    },\n    2: () => {\n        addData().updatePosition(0.95, 0.5, 0.5).setDirection(\"east\").create();\n        addData().setDirection(\"west\").create().clear();\n    },\n    3: () => {\n        addData().updatePosition(0.05, 0.5, 0.5).setDirection(\"west\").create();\n        addData().setDirection(\"east\").create().clear();\n    },\n    4: () => {\n        addData().updatePosition(0.5, 0.05, 0.5).setDirection(\"top\").create();\n        addData().setDirection(\"bottom\").create().clear();\n    },\n    5: () => {\n        addData().updatePosition(0.5, 0.95, 0.5).setDirection(\"top\").create();\n        addData().setDirection(\"bottom\").create().clear();\n    },\n};\nexport const PanelVoxelShape = {\n    id: \"#dve_panel\",\n    build() {\n        animationState.setAll(0);\n        if (ShapeTool.data.voxel.getSubstance() == \"#dve_flora\") {\n            animationState.setAll(2);\n        }\n        shapeStates[ShapeTool.data.voxel.getShapeState()]();\n    },\n};\nOverrideManager.registerOverride(\"CullFace\", \"Panel\", \"Any\", (data) => {\n    if (data.currentVoxel.getSubstance() == \"#dve_flora\") {\n        return false;\n    }\n    return data.default;\n});\nOverrideManager.registerOverride(\"CullFace\", \"Panel\", \"Any\", (data) => {\n    if (data.currentVoxel.getSubstance() == \"#dve_flora\") {\n        return false;\n    }\n    return data.default;\n});\n","import { OverrideManager } from \"../../../Rules/Overrides/OverridesManager.js\";\nimport { StairStates } from \"../../../../../Data/Shapes/StairStates.js\";\nimport { FaceRecord } from \"../../../../../Math/Constants/Faces.js\";\n/*\n \"top\",\n \"bottom\",\n \"east\",\n \"west\",\n \"south\",\n \"north\",\n*/\nconst stairCulls = {};\nstairCulls[StairStates.normal.bottom.north] = {\n    faces: [0, 1, 3, 0, 3, 1, 0, 1],\n    stateCulls: [\n        [StairStates.normal.bottom.north],\n        [StairStates.normal.bottom.north],\n    ],\n};\nconst halfBoxCull = (Data) => {\n    return true;\n};\nconst stairCull = (data) => {\n    const shapeState = data.currentVoxel.getShapeState();\n    const stairData = stairCulls[shapeState];\n    if (!stairData)\n        return false;\n    const neighborShapeState = data.neighborVoxel.getShapeState();\n    let finalResult = false;\n    const faces = stairData.faces;\n    const type = faces[FaceRecord[data.face]];\n    if (type == 2 || type == 3) {\n        const i = faces[FaceRecord[data.face] + 1];\n        const override = stairData.stateCulls[i];\n        finalResult = !override.includes(neighborShapeState);\n    }\n    return finalResult;\n};\nconst boxCull = (data) => {\n    const shapeState = data.currentVoxel.getShapeState();\n    const stairData = stairCulls[shapeState];\n    if (!stairData)\n        return false;\n    let finalResult = false;\n    const faces = stairData.faces;\n    const type = faces[FaceRecord[data.face]];\n    if (type == 1 || type == 3) {\n        finalResult = false;\n    }\n    return finalResult;\n};\nexport const StairCullFace = (data) => {\n    const id = data.neighborVoxel.getShapeId();\n    if (id == \"#dve_box\") {\n        return boxCull(data);\n    }\n    if (id == \"#dve_half_box\") {\n        return halfBoxCull(data);\n    }\n    if (id == \"#dve_stair\") {\n        return stairCull(data);\n    }\n    return true;\n};\nexport function SetUpStairOverrides() {\n    OverrideManager.registerOverride(\"CullFace\", \"#dve_stair\", \"Any\", (data) => {\n        return StairCullFace(data);\n    });\n    OverrideManager.registerOverride(\"AOFlipFace\", \"#dve_stair\", \"Any\", (data) => {\n        if (data.face == \"top\" || data.face == \"bottom\")\n            return true;\n        return false;\n    });\n}\n","//functions\nimport { SetUpStairOverrides } from \"./Stair.overrides.js\";\n//data\nimport { StairStates } from \"../../../../../Data/Shapes/StairStates.js\";\nimport { ShapeBuilder } from \"../../Builder/ShapeBuilder.js\";\nimport { ShapeTool } from \"../../ShapeTool.js\";\nimport { FaceRecord } from \"../../../../../Math/Constants/Faces.js\";\nexport const StairVoxelShape = {\n    id: \"#dve_stair\",\n    add: {\n        top() {\n            ShapeBuilder.build(StairBuilderData[ShapeTool.data.voxel.getShapeState()][FaceRecord[\"top\"]]);\n        },\n        bottom() {\n            ShapeBuilder.build(StairBuilderData[ShapeTool.data.voxel.getShapeState()][FaceRecord[\"bottom\"]]);\n        },\n        north() {\n            ShapeBuilder.build(StairBuilderData[ShapeTool.data.voxel.getShapeState()][FaceRecord[\"north\"]]);\n        },\n        south() {\n            ShapeBuilder.build(StairBuilderData[ShapeTool.data.voxel.getShapeState()][FaceRecord[\"south\"]]);\n        },\n        east() {\n            ShapeBuilder.build(StairBuilderData[ShapeTool.data.voxel.getShapeState()][FaceRecord[\"east\"]]);\n        },\n        west() {\n            ShapeBuilder.build(StairBuilderData[ShapeTool.data.voxel.getShapeState()][FaceRecord[\"west\"]]);\n        },\n    },\n};\nSetUpStairOverrides();\nconst halfHeightQuad = (direction, position, AO, uvs) => {\n    const mewQuad = quad(direction, position);\n    mewQuad[1][1] = 0.5;\n    mewQuad[3] = AO;\n    mewQuad[4] = [-5, -5, -5, -5];\n    mewQuad[5] = [0, 0, 1, uvs[0], uvs[1]];\n    return mewQuad;\n};\nconst halfWidthQuad = (direction, position, AO, uvs) => {\n    const quad = halfHeightQuad(direction, position, AO, uvs);\n    quad[1][0] = 0.5;\n    quad[1][1] = 1;\n    quad[4] = [-5, -5, -5, -5];\n    quad[5] = [0, uvs[0], uvs[1], 0, 1];\n    return quad;\n};\nconst quaterQuad = (direction, position, AO, uvs) => {\n    const mewQuad = quad(direction, position);\n    mewQuad[1][0] = 0.5;\n    mewQuad[1][1] = 0.5;\n    mewQuad[3] = AO;\n    mewQuad[4] = [-5, -5, -5, -5];\n    mewQuad[5] = uvs;\n    return mewQuad;\n};\nconst quad = (direction, position, AO = [-1, -2, -3, -4], flip = -1 | 0 | 1) => {\n    return [\n        direction,\n        [1, 1],\n        position,\n        AO,\n        [-1, -2, -3, -4],\n        [0, 0, 1, 0, 1],\n        flip,\n    ];\n};\nconst fullQuads = {\n    top: quad(\"top\", [0.5, 1, 0.5]),\n    bottom: quad(\"bottom\", [0.5, 0, 0.5]),\n    east: quad(\"east\", [1, 0.5, 0.5]),\n    west: quad(\"west\", [0, 0.5, 0.5]),\n    south: quad(\"south\", [0.5, 0.5, 0]),\n    north: quad(\"north\", [0.5, 0.5, 1]),\n};\nconst a = 3;\nexport const StairBuilderData = {};\n//bottom\nStairBuilderData[StairStates.normal.bottom.north] = [\n    [\n        halfHeightQuad(\"top\", [0.5, 1, 0.75], [1, -2, -3, 1], [0, 0.5]),\n        halfHeightQuad(\"top\", [0.5, 0.5, 0.25], [1, a, a, 1], [0.5, 1]),\n    ],\n    [fullQuads.bottom],\n    [\n        quaterQuad(\"east\", [1, 0.75, 0.75], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"west\", [0, 0.75, 0.75], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\n        halfHeightQuad(\"south\", [0.5, 0.75, 0.5], [-1, -2, a, a], [0, 0.5]),\n    ],\n    [fullQuads.north],\n];\nStairBuilderData[StairStates.normal.bottom.south] = [\n    [\n        halfHeightQuad(\"top\", [0.5, 0.5, 0.75], [a, 1, 1, a], [0, 0.5]),\n        halfHeightQuad(\"top\", [0.5, 1, 0.25], [-1, 1, 1, -4], [0.5, 1]),\n    ],\n    [fullQuads.bottom],\n    [\n        quaterQuad(\"east\", [1, 0.75, 0.25], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"west\", [0, 0.75, 0.25], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [fullQuads.south],\n    [\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\n        halfHeightQuad(\"north\", [0.5, 0.75, 0.5], [-1, -2, a, a], [0, 0.5]),\n    ],\n];\nStairBuilderData[StairStates.normal.bottom.east] = [\n    [\n        halfWidthQuad(\"top\", [0.75, 1, 0.5], [1, 1, -3, -5], [0.5, 1]),\n        halfWidthQuad(\"top\", [0.25, 0.5, 0.5], [1, 1, a, a], [0, 0.5]),\n    ],\n    [fullQuads.bottom],\n    [fullQuads.east],\n    [\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n        halfHeightQuad(\"west\", [0.5, 0.75, 0.5], [-1, -2, a, a], [0, 0.5]),\n    ],\n    [\n        quaterQuad(\"south\", [0.75, 0.75, 0], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"north\", [0.75, 0.75, 1], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\n    ],\n];\nStairBuilderData[StairStates.normal.bottom.west] = [\n    [\n        halfWidthQuad(\"top\", [0.75, 0.5, 0.5], [a, a, 1, 1], [0.5, 1]),\n        halfWidthQuad(\"top\", [0.25, 1, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n    ],\n    [fullQuads.bottom],\n    [\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n        halfHeightQuad(\"east\", [0.5, 0.75, 0.5], [-1, -2, a, a], [0, 0.5]),\n    ],\n    [fullQuads.west],\n    [\n        quaterQuad(\"south\", [0.25, 0.75, 0], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"north\", [0.25, 0.75, 1], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\n    ],\n];\n//top\nStairBuilderData[StairStates.normal.top.north] = [\n    [fullQuads.top],\n    [\n        halfHeightQuad(\"bottom\", [0.5, 0, 0.75], [1, 1, -3, -4], [0, 0.5]),\n        halfHeightQuad(\"bottom\", [0.5, 0.5, 0.25], [1, 1, a, a], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"east\", [1, 0.25, 0.75], [-1, -2, 1, 1], [0, 0.5, 1, 0.5, 1]),\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [1, 1, -3, -4], [0, 0.5]),\n    ],\n    [\n        quaterQuad(\"west\", [0, 0.25, 0.75], [-1, -2, 1, 1], [0, 0, 0.5, 0.5, 1]),\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [1, 1, -3, -4], [0, 0.5]),\n    ],\n    [\n        halfHeightQuad(\"south\", [0.5, 0.25, 0.5], [a, a, 1, 1], [0.5, 1]),\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [-1, -2, 1, 1], [0, 0.5]),\n    ],\n    [fullQuads.north],\n];\nStairBuilderData[StairStates.normal.top.south] = [\n    [fullQuads.top],\n    [\n        halfHeightQuad(\"bottom\", [0.5, 0, 0.25], [-1, -2, 1, 1], [0, 0.5]),\n        halfHeightQuad(\"bottom\", [0.5, 0.5, 0.75], [a, a, 1, 1], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"east\", [1, 0.25, 0.25], [-1, -2, 1, 1], [0, 0, 0.5, 0.5, 1]),\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [1, 1, -3, -4], [0, 0.5]),\n    ],\n    [\n        quaterQuad(\"west\", [0, 0.25, 0.25], [-1, -2, 1, 1], [0, 0.5, 1, 0.5, 1]),\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [1, 1, -3, -4], [0, 0.5]),\n    ],\n    [fullQuads.south],\n    [\n        halfHeightQuad(\"north\", [0.5, 0.25, 0.5], [a, a, 1, 1], [0.5, 1]),\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [-1, -2, 1, 1], [0, 0.5]),\n    ],\n];\nStairBuilderData[StairStates.normal.top.east] = [\n    [fullQuads.top],\n    [\n        halfWidthQuad(\"bottom\", [0.75, 0, 0.5], [1, -2, -3, 1], [0.5, 1]),\n        halfWidthQuad(\"bottom\", [0.25, 0.5, 0.5], [1, a, a, 1], [0, 0.5]),\n    ],\n    [fullQuads.east],\n    [\n        halfHeightQuad(\"west\", [0.5, 0.25, 0.5], [a, a, 1, 1], [0.5, 1]),\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n    ],\n    [\n        quaterQuad(\"south\", [0.75, 0.25, 0], [-1, -2, 1, 1], [0, 0.5, 1, 0.5, 1]),\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [1, 1, -3, -4], [0, 0.5]),\n    ],\n    [\n        quaterQuad(\"north\", [0.75, 0.25, 1], [-1, -2, 1, 1], [0, 0, 0.5, 0.5, 1]),\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [1, 1, -3, -4], [0, 0.5]),\n    ],\n];\nStairBuilderData[StairStates.normal.top.west] = [\n    [fullQuads.top],\n    [\n        halfWidthQuad(\"bottom\", [0.75, 0.5, 0.5], [a, 1, 1, a], [0.5, 1]),\n        halfWidthQuad(\"bottom\", [0.25, 0, 0.5], [-1, 1, 1, -4], [0, 0.5]),\n    ],\n    [\n        halfHeightQuad(\"east\", [0.5, 0.25, 0.5], [a, a, 1, 1], [0.5, 1]),\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n    ],\n    [fullQuads.west],\n    [\n        quaterQuad(\"south\", [0.25, 0.25, 0], [-1, -2, 1, 1], [0, 0, 0.5, 0.5, 1]),\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [1, 1, -3, -4], [0, 0.5]),\n    ],\n    [\n        quaterQuad(\"north\", [0.25, 0.25, 1], [-1, -2, 1, 1], [0, 0.5, 1, 0.5, 1]),\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [1, 1, -3, -4], [0, 0.5]),\n    ],\n];\n//connected states\n//bottom\nStairBuilderData[StairStates.connected.bottom.northEast] = [\n    [\n        quaterQuad(\"top\", [0.75, 1, 0.75], [1, -2, -3, 1], [0, 0, 0.5, 0.5, 1]),\n        quad(\"top\", [0.5, 0.5, 0.5], [1, 1, a, 1]),\n    ],\n    [fullQuads.bottom],\n    [\n        quaterQuad(\"east\", [1, 0.75, 0.75], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"west\", [0.5, 0.75, 0.75], [-1, -2, a, a], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"south\", [0.75, 0.75, 0.5], [-1, -2, a, a], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"north\", [0.75, 0.75, 1], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\n    ],\n];\nStairBuilderData[StairStates.connected.bottom.northWest] = [\n    [\n        quaterQuad(\"top\", [0.25, 1, 0.75], [1, -2, -3, 1], [0, 0, 0.5, 0.5, 1]),\n        quad(\"top\", [0.5, 0.5, 0.5], [1, 1, a, 1], 1),\n    ],\n    [fullQuads.bottom],\n    [\n        quaterQuad(\"east\", [0.5, 0.75, 0.75], [-1, -2, a, a], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"west\", [0, 0.75, 0.75], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"south\", [0.25, 0.75, 0.5], [-1, -2, a, a], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"north\", [0.25, 0.75, 1], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\n    ],\n];\nStairBuilderData[StairStates.connected.bottom.southEast] = [\n    [\n        quaterQuad(\"top\", [0.75, 1, 0.25], [1, -2, -3, 1], [0, 0, 0.5, 0.5, 1]),\n        quad(\"top\", [0.5, 0.5, 0.5], [a, 1, 1, 1], 1),\n    ],\n    [fullQuads.bottom],\n    [\n        quaterQuad(\"east\", [1, 0.75, 0.25], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"west\", [0.5, 0.75, 0.25], [-1, -2, a, a], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"south\", [0.75, 0.75, 0], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"north\", [0.75, 0.75, 0.5], [-1, -2, a, a], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\n    ],\n];\nStairBuilderData[StairStates.connected.bottom.southWest] = [\n    [\n        quaterQuad(\"top\", [0.25, 1, 0.25], [1, -2, -3, 1], [0, 0, 0.5, 0.5, 1]),\n        quad(\"top\", [0.5, 0.5, 0.5], [a, 1, 1, 1]),\n    ],\n    [fullQuads.bottom],\n    [\n        quaterQuad(\"east\", [0.5, 0.75, 0.25], [-1, -2, a, a], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"west\", [0, 0.75, 0.25], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"south\", [0.25, 0.75, 0], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\n    ],\n    [\n        quaterQuad(\"north\", [0.25, 0.75, 0.5], [-1, -2, a, a], [0, 0.5, 1, 0, 0.5]),\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\n    ],\n];\n//top\nStairBuilderData[StairStates.connected.top.northEast] = [\n    [fullQuads.top],\n    [\n        quaterQuad(\"bottom\", [0.75, 0, 0.75], [1, -2, -3, 1], [0, 0.5, 1, 0.5, 1]),\n        quad(\"bottom\", [0.5, 0.5, 0.5], [1, 1, a, 1]),\n    ],\n    [\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"east\", [1, 0.25, 0.75], [1, 1, -3, -4], [0, 0.5, 1, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"west\", [0.5, 0.25, 0.75], [a, a, -3, -4], [0, 0, 0.5, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"south\", [0.75, 0.25, 0.5], [a, a, -3, -4], [0, 0.5, 1, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"north\", [0.75, 0.25, 1], [1, 1, -3, -4], [0, 0, 0.5, 0.5, 1]),\n    ],\n];\nStairBuilderData[StairStates.connected.top.northWest] = [\n    [fullQuads.top],\n    [\n        quaterQuad(\"bottom\", [0.25, 0, 0.75], [1, -2, -3, 1], [0, 0, 0.5, 0.5, 1]),\n        quad(\"bottom\", [0.5, 0.5, 0.5], [a, 1, 1, 1], 1),\n    ],\n    [\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"east\", [0.5, 0.25, 0.75], [a, a, -3, -4], [0, 0.5, 1, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"west\", [0, 0.25, 0.75], [1, 1, -3, -4], [0, 0, 0.5, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"south\", [0.25, 0.25, 0.5], [a, a, -3, -4], [0, 0, 0.5, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"north\", [0.25, 0.25, 1], [1, 1, -3, -4], [0, 0.5, 1, 0.5, 1]),\n    ],\n];\nStairBuilderData[StairStates.connected.top.southEast] = [\n    [fullQuads.top],\n    [\n        quaterQuad(\"bottom\", [0.75, 0, 0.25], [1, -2, -3, 1], [0, 0.5, 1, 0, 0.5]),\n        quad(\"bottom\", [0.5, 0.5, 0.5], [1, 1, a, 1], 1),\n    ],\n    [\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"east\", [1, 0.25, 0.25], [1, 1, -3, -4], [0, 0, 0.5, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"west\", [0.5, 0.25, 0.25], [a, a, -3, -4], [0, 0.5, 1, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"south\", [0.75, 0.25, 0], [1, 1, -3, -4], [0, 0.5, 1, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"north\", [0.75, 0.25, 0.5], [a, a, -3, -4], [0, 0, 0.5, 0.5, 1]),\n    ],\n];\nStairBuilderData[StairStates.connected.top.southWest] = [\n    [fullQuads.top],\n    [\n        quaterQuad(\"bottom\", [0.25, 0, 0.25], [1, -2, -3, 1], [0, 0, 0.5, 0, 0.5]),\n        quad(\"bottom\", [0.5, 0.5, 0.5], [a, 1, 1, 1]),\n    ],\n    [\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"east\", [0.5, 0.25, 0.25], [a, a, -3, -4], [0, 0, 0.5, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"west\", [0, 0.25, 0.25], [1, 1, -3, -4], [0, 0.5, 1, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"south\", [0.25, 0.25, 0], [1, 1, -3, -4], [0, 0, 0.5, 0.5, 1]),\n    ],\n    [\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [-1, -2, 1, 1], [0, 0.5]),\n        quaterQuad(\"north\", [0.25, 0.25, 0.5], [a, a, -3, -4], [0, 0.5, 1, 0.5, 1]),\n    ],\n];\n","export * from \"./Stairs/Stair.voxel.shape.js\";\nexport * from \"./Box/Box.voxel.shape.js\";\nexport * from \"./Box/HalfBox.voxel.shape.js\";\nexport * from \"./Liquid/Liquid.voxel.shape.js\";\nexport * from \"./Panel/CrossedPanels.voxel.shape.js\";\nexport * from \"./Panel/Panel.voxel.shape.js\";\n","export const TextureManager = {\n    textureDataHasBeenSet: false,\n    data: {},\n    getTextureUV(data, overlay = false) {\n        const [textureType, textureId, varation] = data;\n        let id = textureId;\n        if (varation) {\n            id = `${textureId}:${varation}`;\n        }\n        let uv = -1;\n        if (!overlay) {\n            uv = this.data[textureType][\"main\"][id];\n        }\n        else {\n            uv = this.data[textureType][\"overlay\"][id];\n        }\n        if (uv == -1) {\n            throw new Error(`Texture with id: ${id} does not exists. Overlay : ${overlay}`);\n        }\n        return uv;\n    },\n    setTextureIndex(data) {\n        this.textureDataHasBeenSet = true;\n        this.data = data;\n    },\n    releaseTextureData() {\n        this.data = null;\n        delete this[\"data\"];\n    },\n    isReady() {\n        return this.textureDataHasBeenSet;\n    },\n};\n","import { DataTool } from \"../../../Tools/Data/DataTool.js\";\nimport { Builder } from \"../Builder.js\";\nexport class BuilderDataTool extends DataTool {\n    getConstructor() {\n        return Builder.constructors.get(this.getStringId());\n    }\n}\n","import { QuadBuilder } from \"../Geometry/QuadBuilder.js\";\nimport { QuadUVs } from \"../Geometry/QuadUVs.js\";\nexport class MeshBuilderTool {\n    direction = \"top\";\n    tool;\n    constructor() { }\n    setMesherTool(tool) {\n        this.tool = tool;\n        this.quad.setMesherTool(tool);\n        return this;\n    }\n    quad = new QuadBuilderTool();\n}\nexport class QuadBuilderTool {\n    tool;\n    builder = QuadBuilder;\n    uvs = new QuadUVTool(this, \"cuv3\");\n    setMesherTool(tool) {\n        this.tool = tool;\n        return this;\n    }\n    _fliped = false;\n    _direction = \"top\";\n    _position = { x: 0, y: 0, z: 0 };\n    _cachedPosition = { x: 0, y: 0, z: 0 };\n    _dimension = { height: 0, width: 0 };\n    _transform = {\n        1: { x: 0, y: 0, z: 0 },\n        2: { x: 0, y: 0, z: 0 },\n        3: { x: 0, y: 0, z: 0 },\n        4: { x: 0, y: 0, z: 0 },\n    };\n    setDimensions(width, height) {\n        this._dimension.width = width;\n        this._dimension.height = height;\n        return this;\n    }\n    setPosition(x = 0, y = 0, z = 0) {\n        this._position.x = x;\n        this._position.y = y;\n        this._position.z = z;\n        this._cachedPosition.x = x;\n        this._cachedPosition.y = y;\n        this._cachedPosition.z = z;\n        return this;\n    }\n    updatePosition(x = 0, y = 0, z = 0) {\n        this._position.x = this._cachedPosition.x + x;\n        this._position.y = this._cachedPosition.y + y;\n        this._position.z = this._cachedPosition.z + z;\n        return this;\n    }\n    updatePositionInPlace(x = 0, y = 0, z = 0) {\n        this._position.x += x;\n        this._position.y += y;\n        this._position.z += z;\n        return this;\n    }\n    setTransform(vertex, x = 0, y = 0, z = 0) {\n        const t = this._transform[vertex];\n        t.x = x;\n        t.y = y;\n        t.z = z;\n        return this;\n    }\n    clearTransform() {\n        this.setTransform(1);\n        this.setTransform(2);\n        this.setTransform(3);\n        this.setTransform(4);\n        return this;\n    }\n    setFlipped(flipped) {\n        this._fliped = flipped;\n        return this;\n    }\n    setDirection(direction) {\n        this._direction = direction;\n        return this;\n    }\n    create() {\n        this.builder.create(this.tool, this._direction, this._position, this._dimension, this._fliped, this._transform);\n        return this;\n    }\n    clear() {\n        this._cachedPosition.x = 0;\n        this._cachedPosition.y = 0;\n        this._cachedPosition.z = 0;\n        this._fliped = false;\n        this._dimension.width = 1;\n        this._dimension.height = 1;\n        for (let i = 1; i < 5; i++) {\n            this._transform[i].x = 0;\n            this._transform[i].y = 0;\n            this._transform[i].z = 0;\n        }\n        return this;\n    }\n}\nexport class QuadUVTool {\n    quad;\n    attributeId;\n    uvs = QuadUVs;\n    _data = {\n        width: [0, 1],\n        height: [0, 1],\n    };\n    _fliped = false;\n    advancedUVs = {\n        hs1: 0,\n        hs2: 0,\n        he1: 1,\n        he2: 1,\n        ws1: 0,\n        ws2: 0,\n        we1: 1,\n        we2: 1,\n    };\n    _rotation = 0;\n    constructor(quad, attributeId) {\n        this.quad = quad;\n        this.attributeId = attributeId;\n    }\n    resetAdvancedUVs() {\n        this.advancedUVs.hs1 = 0;\n        this.advancedUVs.hs2 = 0;\n        this.advancedUVs.he1 = 1;\n        this.advancedUVs.he2 = 1;\n        this.advancedUVs.ws1 = 0;\n        this.advancedUVs.ws2 = 0;\n        this.advancedUVs.we1 = 1;\n        this.advancedUVs.we2 = 1;\n        return this;\n    }\n    setFlipped(flipped) {\n        this._fliped = flipped;\n        return this;\n    }\n    setWidth(start, end) {\n        this._data.width[0] = start;\n        this._data.width[1] = end;\n        return this;\n    }\n    setHeight(start, end) {\n        this._data.height[0] = start;\n        this._data.height[1] = end;\n        return this;\n    }\n    setRoation(rotation) {\n        this._rotation = rotation;\n        return this;\n    }\n    addAdvancedUVs(textureId) {\n        this.uvs.addAdvancedUVs(this.quad._direction, textureId, this.quad.tool.getAttribute(this.attributeId), this.advancedUVs, this._fliped);\n        return this;\n    }\n    add(textureId) {\n        this.uvs.addUVs({\n            direction: this.quad._direction,\n            uvs: this.quad.tool.getAttribute(this.attributeId),\n            uv: textureId,\n            width: { start: this._data.width[0], end: this._data.width[1] },\n            height: { start: this._data.height[0], end: this._data.height[1] },\n            flipped: this._fliped,\n            rotoate: this._rotation,\n        });\n        return this.quad;\n    }\n    clear() {\n        this._data.width[0] = 0;\n        this._data.width[1] = 1;\n        this._data.height[0] = 0;\n        this._data.height[1] = 1;\n        this._fliped = false;\n        this._rotation = 0;\n        this.resetAdvancedUVs();\n        return this.quad;\n    }\n}\n","import { UtilMap } from \"../../../Global/Util/UtilMap.js\";\nimport { TypedArrayMap } from \"divine-binary-object/Constants/ByteData.js\";\nexport class MesherDataTool {\n    indicieIndex = 0;\n    vars = new UtilMap();\n    segments = new UtilMap();\n    quadVertexData = new UtilMap();\n    attributes = new UtilMap([\n        [\"position\", [[], 3, \"32f\"]],\n        [\"normal\", [[], 3, \"32f\"]],\n        [\"indices\", [[], 1, \"16ui\"]],\n    ]);\n    addPositions(...positions) {\n        this.attributes.get(\"position\")[0].push(...positions);\n        return this;\n    }\n    addNormals(...normals) {\n        this.attributes.get(\"normal\")[0].push(...normals);\n        return this;\n    }\n    addIndices(...indices) {\n        this.attributes.get(\"indices\")[0].push(...indices);\n        return this;\n    }\n    addToAttribute(id, ...data) {\n        const attribute = this.attributes.get(id);\n        if (!attribute)\n            return this;\n        attribute[0].push(...data);\n        return this;\n    }\n    getAttribute(id) {\n        return this.attributes.get(id)[0];\n    }\n    addToSegment(id, ...normals) {\n        const segment = this.segments.get(id);\n        if (!segment)\n            return this;\n        segment.push(...normals);\n        return this;\n    }\n    setVar(id, value) {\n        if (this.vars.has(id)) {\n            this.vars.set(id, value);\n        }\n        return this;\n    }\n    getVar(id) {\n        return this.vars.get(id);\n    }\n    resetAll() {\n        this.resetSegments();\n        this.resetAttributes();\n        this.resetVars();\n        return this;\n    }\n    resetSegments() {\n        for (const [key, v] of this.segments._map) {\n            this.segments._map.set(key, []);\n        }\n        return this;\n    }\n    resetAttributes() {\n        for (const [key, v] of this.attributes._map) {\n            this.attributes._map.set(key, [[], v[1], v[2]]);\n        }\n        this.indicieIndex = 0;\n        return this;\n    }\n    resetVars() {\n        for (const key of this.vars._map.keys()) {\n            this.vars.set(key, 0);\n        }\n        return this;\n    }\n    getMeshData() {\n        const arrays = [];\n        const strides = [];\n        const trasnfers = [];\n        for (const [key, [value, stride, type]] of this.attributes._map) {\n            //@ts-ignore\n            const newArray = TypedArrayMap[type].from(value);\n            arrays.push(newArray);\n            strides.push(stride);\n            trasnfers.push(newArray.buffer);\n        }\n        return [arrays, trasnfers, strides];\n    }\n    getAllAttributes() {\n        const data = [];\n        const trasnfers = [];\n        for (const [key, [value, stride, type]] of this.attributes._map) {\n            //@ts-ignore\n            const newArray = TypedArrayMap[type].from(value);\n            trasnfers.push(newArray.buffer);\n            data.push([key, newArray, stride]);\n        }\n        return [data, trasnfers];\n    }\n}\n","import { DVEC } from \"../../DivineVoxelEngineConstructor.js\";\nconst checkSets = {\n    north: [\n        [0, 0, 1],\n        [1, 0, 1],\n        [-1, 0, 1],\n    ],\n    south: [\n        [0, 0, -1],\n        [1, 0, -1],\n        [-1, 0, -1],\n    ],\n    east: [[1, 0, 0]],\n    west: [[-1, 0, 0]],\n    top: [\n        [0, 1, 0],\n        [-1, 1, -1],\n        [1, 1, 1],\n    ],\n    bottom: [\n        [0, -1, 0],\n        [-1, -1, -1],\n        [1, -1, 1],\n    ],\n    right: [[-1, 0, 0]],\n    left: [[1, 0, 0]],\n};\nconst DirectionNormals = {\n    top: [0, 1, 0],\n    bottom: [0, -1, 0],\n    east: [1, 0, 0],\n    west: [-1, 0, 0],\n    north: [0, 0, 1],\n    south: [0, 0, -1],\n};\nconst uvsSets = {\n    north: {\n        0b0: 0,\n        0b101: 1,\n        0b011: 2,\n        0b001: 3,\n    },\n    south: {\n        0b0: 4,\n        0b101: 5,\n        0b011: 6,\n        0b001: 7,\n    },\n    east: {\n        0b0: 8,\n    },\n    west: {\n        0b0: 9,\n    },\n    top: {\n        0b0: 0,\n        0b101: 1,\n        0b011: 2,\n        0b001: 3,\n    },\n    bottom: {\n        0b0: 4,\n        0b101: 5,\n        0b011: 6,\n        0b001: 7,\n    },\n    right: {\n        0b0: 8,\n    },\n    left: {\n        0b0: 9,\n    },\n};\nexport const OutlinedVoxelTool = {\n    _currentTexts: [],\n    setCurrentTextures(textures) {\n        this._currentTexts = textures;\n    },\n    addTo: {\n        top(tool) {\n            tool\n                .getOverlayTextures()\n                .set(OutlinedVoxelTool.getTexture(\"north\", \"top\", tool), OutlinedVoxelTool.getTexture(\"south\", \"top\", tool), OutlinedVoxelTool.getTexture(\"east\", \"top\", tool), OutlinedVoxelTool.getTexture(\"west\", \"top\", tool));\n        },\n        bottom(tool) {\n            tool\n                .getOverlayTextures()\n                .set(OutlinedVoxelTool.getTexture(\"north\", \"bottom\", tool), OutlinedVoxelTool.getTexture(\"south\", \"bottom\", tool), OutlinedVoxelTool.getTexture(\"east\", \"bottom\", tool), OutlinedVoxelTool.getTexture(\"west\", \"bottom\", tool));\n        },\n        north(tool) {\n            tool\n                .getOverlayTextures()\n                .set(OutlinedVoxelTool.getTexture(\"top\", \"north\", tool), OutlinedVoxelTool.getTexture(\"bottom\", \"north\", tool), OutlinedVoxelTool.getTexture(\"right\", \"north\", tool), OutlinedVoxelTool.getTexture(\"left\", \"north\", tool));\n        },\n        south(tool) {\n            tool\n                .getOverlayTextures()\n                .set(OutlinedVoxelTool.getTexture(\"top\", \"south\", tool), OutlinedVoxelTool.getTexture(\"bottom\", \"south\", tool), OutlinedVoxelTool.getTexture(\"right\", \"south\", tool), OutlinedVoxelTool.getTexture(\"left\", \"south\", tool));\n        },\n        east(tool) {\n            tool\n                .getOverlayTextures()\n                .set(OutlinedVoxelTool.getTexture(\"top\", \"east\", tool), OutlinedVoxelTool.getTexture(\"bottom\", \"east\", tool), OutlinedVoxelTool.getTexture(\"right\", \"east\", tool), OutlinedVoxelTool.getTexture(\"left\", \"east\", tool));\n        },\n        west(tool) {\n            tool\n                .getOverlayTextures()\n                .set(OutlinedVoxelTool.getTexture(\"top\", \"west\", tool), OutlinedVoxelTool.getTexture(\"bottom\", \"west\", tool), OutlinedVoxelTool.getTexture(\"right\", \"west\", tool), OutlinedVoxelTool.getTexture(\"left\", \"west\", tool));\n        },\n    },\n    getOutlineUVs(texture, onRegister) {\n        const overlayTextures = [];\n        DVEC.hooks.texturesRegistered.addToRun((textureManager) => {\n            const type = texture[0];\n            const id = texture[1];\n            overlayTextures.push(textureManager.getTextureUV([type, id, \"top\"], true) /** */, textureManager.getTextureUV([type, id, \"corner-top-right\"], true), textureManager.getTextureUV([type, id, \"corner-top-left\"], true), textureManager.getTextureUV([type, id, \"corner-top-left-top-right\"], true), textureManager.getTextureUV([type, id, \"bottom\"], true), textureManager.getTextureUV([type, id, \"corner-bottom-right\"], true), textureManager.getTextureUV([type, id, \"corner-bottom-left\"], true), textureManager.getTextureUV([type, id, \"corner-bottom-left-bottom-right\"], true), textureManager.getTextureUV([type, id, \"right\"], true), textureManager.getTextureUV([type, id, \"left\"], true));\n            onRegister(overlayTextures);\n        });\n    },\n    getTexture(direction, face, tool) {\n        const { x, y, z } = tool.voxel;\n        let key = 0b0;\n        const sets = checkSets[direction];\n        const sl = sets.length;\n        for (let i = 0; i < sets.length; i++) {\n            const set = sets[i];\n            let cx = x;\n            let cy = y;\n            let cz = z;\n            switch (face) {\n                case \"top\":\n                    cx += set[0];\n                    cz += set[2];\n                    break;\n                case \"bottom\":\n                    cx += set[0];\n                    cz += set[2] * -1;\n                    break;\n                case \"north\":\n                    if (sl == 0) {\n                        cx += set[0];\n                    }\n                    else {\n                        cx += set[0];\n                        cy += set[1];\n                    }\n                    break;\n                case \"south\":\n                    if (sl == 0) {\n                        cx += set[0] * -1;\n                    }\n                    else {\n                        cx += set[0] * -1;\n                        cy += set[1];\n                    }\n                    break;\n                case \"west\":\n                    if (sl == 0) {\n                        cz += set[0];\n                    }\n                    else {\n                        cz += set[0];\n                        cy += set[1];\n                    }\n                    break;\n                case \"east\":\n                    if (sl == 0) {\n                        cz += set[0] * -1;\n                    }\n                    else {\n                        cz += set[0] * -1;\n                        cy += set[1];\n                    }\n                    break;\n            }\n            const normal = DirectionNormals[face];\n            const sameLevelCheck = tool.voxel.isSameVoxel(cx, cy, cz);\n            let normalCheck = true;\n            if (tool.nVoxel.loadInAt(cx + normal[0], cy + normal[1], cz + normal[2])) {\n                if (tool.nVoxel.isOpaque()) {\n                    normalCheck = false;\n                }\n            }\n            if (sameLevelCheck && normalCheck) {\n                key |= 0b1 << i;\n            }\n            else {\n                key |= 0b0 << i;\n                if (i == 0)\n                    break;\n            }\n        }\n        if (uvsSets[direction][key] == undefined)\n            return 0;\n        const index = uvsSets[direction][key];\n        return this._currentTexts[index];\n    },\n};\n","//objects\nimport { LightGradient } from \"../Calc/Light/LightGradient.js\";\nimport { FlowGradient } from \"../Calc/Flow/FlowGradient.js\";\nimport { OverrideManager } from \"../Rules/Overrides/OverridesManager.js\";\nimport { SubstanceRules } from \"../Rules/SubstanceRules.js\";\n//tools\nimport { BuilderDataTool } from \"./BuilderDataTool.js\";\nimport { MesherDataTool } from \"./MesherDataTools.js\";\n//data\nimport { FaceNormals } from \"../../../Math/Constants/Faces.js\";\nimport { QuadVertexData } from \"../Classes/VertexData.js\";\nexport class VoxelMesherDataTool extends MesherDataTool {\n    voxel = new BuilderDataTool();\n    nVoxel = new BuilderDataTool();\n    faceDataOverride = {\n        face: \"south\",\n        default: false,\n        currentVoxel: {},\n        neighborVoxel: {},\n    };\n    constructor() {\n        super();\n        this.faceDataOverride.currentVoxel = this.voxel;\n        this.faceDataOverride.neighborVoxel = this.nVoxel;\n        this.attributes.add([\n            [\"voxelData\", [[], 1, \"32f\"]],\n            [\"cuv3\", [[], 3, \"32f\"]],\n            [\"ocuv3\", [[], 4, \"32f\"]],\n            [\"colors\", [[], 3, \"32f\"]],\n        ]);\n        this.segments.add([\n            [\"uvs\", []],\n            [\"overlay-uvs\", []],\n        ]);\n        this.quadVertexData.add([\n            [\"light\", new QuadVertexData()],\n            [\"ao\", new QuadVertexData()],\n            [\"level\", new QuadVertexData()],\n            [\"overlay-uvs\", new QuadVertexData()],\n        ]);\n        this.vars.add([\n            [\"face-flipped\", 0],\n            [\"texture-index\", 0],\n        ]);\n    }\n    calculateLight(direction, ignoreAO = false) {\n        LightGradient.calculate(direction, this, ignoreAO);\n    }\n    calculateFlow() {\n        FlowGradient.calculate(this);\n    }\n    getWorldLight() {\n        return this.quadVertexData.get(\"light\");\n    }\n    getWorldAO() {\n        return this.quadVertexData.get(\"ao\");\n    }\n    getWorldLevel() {\n        return this.quadVertexData.get(\"level\");\n    }\n    getOverlayTextures() {\n        return this.quadVertexData.get(\"overlay-uvs\");\n    }\n    setTexture(uv) {\n        this.vars.set(\"texture-index\", uv);\n        return this;\n    }\n    getTexture() {\n        return this.vars.get(\"texture-index\");\n    }\n    setFaceFlipped(value) {\n        this.vars.set(\"face-flipped\", value ? 1 : 0);\n        return this;\n    }\n    isFaceFlipped() {\n        return this.vars.get(\"face-flipped\") == 1;\n    }\n    isFaceExposed(face) {\n        const voxelExists = this.nVoxel.loadInAt(FaceNormals[face][0] + this.voxel.x, FaceNormals[face][1] + this.voxel.y, FaceNormals[face][2] + this.voxel.z);\n        if (!voxelExists || !this.nVoxel.isRenderable())\n            return true;\n        let finalResult = false;\n        let substanceRuleResult = SubstanceRules.exposedCheck(this.voxel.getSubstance(), this.nVoxel.getSubstance());\n        this.faceDataOverride.face = face;\n        this.faceDataOverride.default = substanceRuleResult;\n        finalResult = substanceRuleResult;\n        this.faceDataOverride.default = finalResult;\n        finalResult = OverrideManager.runOverride(\"CullFace\", this.voxel.getShapeId(), \"Any\", this.faceDataOverride);\n        this.faceDataOverride.default = finalResult;\n        finalResult = OverrideManager.runOverride(\"CullFace\", this.voxel.getShapeId(), this.nVoxel.getShapeId(), this.faceDataOverride);\n        this.faceDataOverride.default = finalResult;\n        finalResult = OverrideManager.runOverride(\"CullFace\", this.voxel.getStringId(), this.nVoxel.getShapeId(), this.faceDataOverride);\n        return finalResult;\n    }\n}\n","import { QuadBuilderTool, QuadUVTool } from \"./MeshBuilderTool.js\";\nimport { QuadVertexData } from \"../Classes/VertexData.js\";\nimport { VoxelShaderDataTool } from \"../../../Tools/Shaders/VoxelShaderData.js\";\nconst faceData = new VoxelShaderDataTool();\nclass VoxelQuadBulder extends QuadBuilderTool {\n    constructor() {\n        super();\n        this.light._s = this;\n        this.AO._s = this;\n        this.overlayTexture._s = this;\n        this.animationState._s = this;\n    }\n    _lightData = new QuadVertexData();\n    _AOData = new QuadVertexData();\n    _animationData = new QuadVertexData();\n    clear() {\n        this._cachedPosition.x = 0;\n        this._cachedPosition.y = 0;\n        this._cachedPosition.z = 0;\n        this._fliped = false;\n        this._dimension.width = 1;\n        this._dimension.height = 1;\n        this.textures.clear();\n        for (let i = 1; i < 5; i++) {\n            this._transform[i].x = 0;\n            this._transform[i].y = 0;\n            this._transform[i].z = 0;\n        }\n        return this;\n    }\n    create() {\n        this.builder.create(this.tool, this._direction, this._position, this._dimension, this._fliped, this._transform);\n        const attribute = this.tool.getAttribute(\"voxelData\");\n        attribute.push(faceData\n            .setLight(this._lightData.getVertex(1))\n            .setAO(this._AOData.getVertex(1))\n            .setAnimation(this._animationData.getVertex(1))\n            .getValue(), faceData\n            .setLight(this._lightData.getVertex(2))\n            .setAO(this._AOData.getVertex(2))\n            .setAnimation(this._animationData.getVertex(2))\n            .getValue(), faceData\n            .setLight(this._lightData.getVertex(3))\n            .setAO(this._AOData.getVertex(3))\n            .setAnimation(this._animationData.getVertex(3))\n            .getValue(), faceData\n            .setLight(this._lightData.getVertex(4))\n            .setAO(this._AOData.getVertex(4))\n            .setAnimation(this._animationData.getVertex(4))\n            .getValue());\n        return this;\n    }\n    setFlipped(flipped) {\n        this._fliped = flipped;\n        this.textures.setFlipped(flipped);\n        return this;\n    }\n    animationState = {\n        _s: {},\n        add(data) {\n            this._s._animationData.setFromQuadData(data);\n            return this._s;\n        },\n    };\n    light = {\n        _s: {},\n        add(data) {\n            this._s._lightData.setFromQuadData(data);\n            return this._s;\n        },\n    };\n    AO = {\n        _s: {},\n        add(data) {\n            this._s._AOData.setFromQuadData(data);\n            return this._s;\n        },\n    };\n    textures = new QuadUVTool(this, \"cuv3\");\n    overlayTexture = {\n        _s: {},\n        add(data) {\n            let i = 4;\n            const attribute = this._s.tool.getAttribute(\"ocuv3\");\n            while (i--) {\n                attribute.push(data.vetexes[1], data.vetexes[2], data.vetexes[3], data.vetexes[4]);\n            }\n            return this._s;\n        },\n    };\n}\nexport class VoxelShapeTool {\n    quad = new VoxelQuadBulder();\n}\n","export {};\n","export {};\n","export {};\n","export * from \"./Geometry.types.js\";\nexport * from \"./Override.types.js\";\nexport * from \"./ShapeBuilder.types.js\";\n","//objects\nimport { EngineSettings } from \"../Data/Settings/EngineSettings.js\";\nimport { Util } from \"../Global/Util.helper.js\";\nimport { Builder } from \"./Builder/Builder.js\";\nimport { Propagation } from \"./Propagation/Propagation.js\";\nimport { WorldGeneration } from \"./WorldGeneration/WorldGeneration.js\";\nimport { Analyzer } from \"./Analyzer/Analyzer.js\";\n//data\nimport { DataManager } from \"../Data/DataManager.js\";\nimport { DataSyncNode } from \"../Data/DataSyncNode.js\";\nimport { VoxelConstructors } from \"./Builder/Constructors/Voxel/VoxelConstructors.js\";\n//threadcomm\nimport { ThreadComm } from \"threadcomm\";\nimport { WorldComm, ParentComm } from \"./Threads/ConstrcutorTheads.js\";\nimport { Tasks } from \"./Tasks/ConstructorTasks.js\";\n//functions\nimport { InitWorker } from \"./Init/InitWorker.js\";\nimport { ConstructorHooks } from \"./Hooks/ConstructorHooks.js\";\nimport { RichDataTool } from \"../Tools/Data/RichDataTool.js\";\nimport { TasksRequest } from \"./Tasks/TasksRequest.js\";\nimport { DataTool } from \"../Tools/Data/DataTool.js\";\nexport const DVEC = {\n    environment: \"browser\",\n    UTIL: Util,\n    settings: EngineSettings,\n    propagation: Propagation,\n    worldGen: WorldGeneration,\n    builder: Builder,\n    analyzer: Analyzer,\n    dataSyncNode: DataSyncNode,\n    data: DataManager,\n    voxelManager: VoxelConstructors,\n    TC: ThreadComm,\n    parentComm: ParentComm,\n    worldComm: WorldComm,\n    tasks: Tasks,\n    hooks: ConstructorHooks,\n    requests: TasksRequest,\n    async $INIT() {\n        await InitWorker(this);\n    },\n    getDataTool() {\n        return new DataTool();\n    },\n    getRichDataTool() {\n        return new RichDataTool();\n    },\n};\nDVEC.environment = Util.getEnviorment();\n","import { Hooks } from \"divine-hooks\";\nexport const ConstructorHooks = {\n    texturesRegistered: Hooks.getSyncHook(),\n};\n","import { EngineSettings } from \"../../Data/Settings/EngineSettings.js\";\nimport { ConstructorThreadState } from \"../Threads/ConstructorThreadState.js\";\nimport { ThreadComm } from \"threadcomm\";\nimport { DataHooks } from \"../../Data/DataHooks.js\";\nimport { SubstanceRules } from \"../Builder/Rules/SubstanceRules.js\";\nexport async function InitWorker(DVEC) {\n    let parent = \"render\";\n    if (DVEC.environment == \"node\") {\n        parent = \"server\";\n    }\n    await ThreadComm.$INIT(\"constructor\", parent);\n    DVEC.builder.$INIT();\n    ThreadComm.registerTasks(\"sync-settings\", (settings) => {\n        EngineSettings.syncSettings(settings);\n        ConstructorThreadState._settingsSynced = true;\n        DataHooks.settingsSynced.run(settings);\n    });\n    await DVEC.UTIL.createPromiseCheck({\n        check: () => {\n            return ConstructorThreadState.isReady();\n        },\n        onReady() { },\n        checkInterval: 1,\n    });\n    ThreadComm.registerTasks(\"ready\", () => {\n        SubstanceRules.$BuildRules();\n    });\n}\n","//data\nimport { $3dCardinalNeighbors } from \"../../../Math/Constants/CardinalNeighbors.js\";\n//objects\nimport { DataTool } from \"../../../Tools/Data/DataTool.js\";\nimport { LightData } from \"../../../Data/Light/LightByte.js\";\n//functions\nimport { Distance3D } from \"../../../Math/Functions/Distance3d.js\";\nimport { RGBRemove, RGBUpdate } from \"../Illumanation/Functions/RGBUpdate.js\";\nimport { SunRemove, SunUpdate } from \"../Illumanation/Functions/SunUpdate.js\";\nimport { FlowManager } from \"../Flow/FlowManager.js\";\nconst dataTool = new DataTool();\nconst nDataTool = new DataTool();\nexport const ExplosionManager = {\n    runExplosion(tasks) {\n        tasks.start();\n        const [dimension, sx, sy, sz] = tasks.origin;\n        FlowManager.setDimension(dimension);\n        tasks.setPriority(0);\n        const queue = tasks.queues.queue;\n        const map = tasks.queues.map;\n        queue.push([sx, sy, sz]);\n        dataTool.setDimension(dimension);\n        nDataTool.setDimension(dimension);\n        const radius = tasks.getData();\n        while (queue.length) {\n            const node = queue.shift();\n            if (!node)\n                break;\n            const x = node[0];\n            const y = node[1];\n            const z = node[2];\n            if (!map.inMap(x + 1, y, z)) {\n                if (dataTool.loadInAt(x + 1, y, z)) {\n                    const d = Distance3D(sx, sy, sz, x + 1, y, z);\n                    if (d <= radius) {\n                        queue.push([x + 1, y, z]);\n                    }\n                    map.add(x + 1, y, z);\n                }\n            }\n            if (!map.inMap(x - 1, y, z)) {\n                if (dataTool.loadInAt(x - 1, y, z)) {\n                    const d = Distance3D(sx, sy, sz, x - 1, y, z);\n                    if (d <= radius) {\n                        queue.push([x - 1, y, z]);\n                    }\n                }\n                map.add(x - 1, y, z);\n            }\n            if (!map.inMap(x, y, z + 1)) {\n                if (dataTool.loadInAt(x, y, z + 1)) {\n                    const d = Distance3D(sx, sy, sz, x, y, z + 1);\n                    if (d <= radius) {\n                        queue.push([x, y, z + 1]);\n                    }\n                }\n                map.add(x, y, z + 1);\n            }\n            if (!map.inMap(x, y, z - 1)) {\n                if (dataTool.loadInAt(x, y, z - 1)) {\n                    const d = Distance3D(sx, sy, sz, x, y, z - 1);\n                    if (d <= radius) {\n                        queue.push([x, y, z - 1]);\n                    }\n                }\n                map.add(x, y, z - 1);\n            }\n            if (!map.inMap(x, y + 1, z)) {\n                if (dataTool.loadInAt(x, y + 1, z)) {\n                    const d = Distance3D(sx, sy, sz, x, y + 1, z);\n                    if (d <= radius) {\n                        queue.push([x, y + 1, z]);\n                    }\n                }\n                map.add(x, y + 1, z);\n            }\n            if (!map.inMap(x, y - 1, z)) {\n                if (dataTool.loadInAt(x, y - 1, z)) {\n                    const d = Distance3D(sx, sy, sz, x, y - 1, z);\n                    if (d <= radius) {\n                        queue.push([x, y - 1, z]);\n                    }\n                }\n                map.add(x, y - 1, z);\n            }\n            if (dataTool.loadInAt(x, y, z)) {\n                if (dataTool.isRenderable()) {\n                    for (const n of $3dCardinalNeighbors) {\n                        const nx = x + n[0];\n                        const ny = y + n[1];\n                        const nz = z + n[2];\n                        if (nDataTool.loadInAt(nx, ny, nz)) {\n                            const l = nDataTool.getLight();\n                            if (l > 0) {\n                                if (LightData.getS(l) > 0) {\n                                    tasks.queues.sun.remove.push(nx, ny, nz);\n                                }\n                                if (LightData.hasRGBLight(l)) {\n                                    tasks.queues.rgb.remove.push(nx, ny, nz);\n                                }\n                            }\n                        }\n                    }\n                    tasks.addNeighborsToRebuildQueue(x, y, z);\n                    if (dataTool.getHardness() > 10_000 ||\n                        dataTool.getSubstnaceData().isLiquid()) {\n                        continue;\n                    }\n                    dataTool.setAir().commit(2);\n                }\n            }\n        }\n        RGBRemove(tasks);\n        SunRemove(tasks);\n        RGBUpdate(tasks);\n        SunUpdate(tasks);\n        tasks.runRebuildQueue();\n        tasks.stop();\n    },\n};\n","import { $3dCardinalNeighbors } from \"../../../Math/Constants/CardinalNeighbors.js\";\nimport { LightData } from \"../../../Data/Light/LightByte.js\";\nimport { DataTool } from \"../../../Tools/Data/DataTool.js\";\nimport { BrushTool } from \"../../../Tools/Brush/Brush.js\";\nimport { SunRemove, SunUpdate } from \"../Illumanation/Functions/SunUpdate.js\";\nimport { RGBRemove, RGBUpdate } from \"../Illumanation/Functions/RGBUpdate.js\";\nimport { IlluminationManager } from \"../Illumanation/IlluminationManager.js\";\nimport { SubstanceDataTool } from \"../../../Tools/Data/SubstanceDataTool.js\";\nexport const FlowManager = {\n    lightData: LightData,\n    _brush: new BrushTool(),\n    _sDataTool: new DataTool(),\n    _nDataTool: new DataTool(),\n    _substanceTool: new SubstanceDataTool(),\n    setVoxel(tasks, vox, level, levelState, x, y, z) {\n        this.sunCheck(tasks, x, y, z);\n        SunRemove(tasks);\n        this._brush.setId(vox).setXYZ(x, y, z).paint();\n        this._sDataTool.loadInAt(x, y, z);\n        this._sDataTool\n            .setLevel(level)\n            .setLevelState(levelState)\n            .setLight(this.getAbsorbLight(x, y, z))\n            .commit();\n        SunUpdate(tasks);\n    },\n    setDimension(dimension) {\n        this._sDataTool.setDimension(dimension);\n        this._nDataTool.setDimension(dimension);\n        this._brush.setDimension(dimension);\n        IlluminationManager.setDimension(dimension);\n    },\n    removeVoxel(tasks, x, y, z) {\n        for (const n of $3dCardinalNeighbors) {\n            const nx = x + n[0];\n            const ny = y + n[1];\n            const nz = z + n[2];\n            if (!this._nDataTool.loadInAt(nx, ny, nz))\n                continue;\n            const l = this._nDataTool.getLight();\n            if (l <= 0)\n                continue;\n            if (this.lightData.getS(l) > 0) {\n                tasks.queues.sun.update.push(nx, ny, nz);\n            }\n            if (this.lightData.hasRGBLight(l)) {\n                tasks.queues.rgb.update.push(nx, ny, nz);\n            }\n        }\n        this._nDataTool.loadInAt(x, y, z);\n        const currentLight = this._nDataTool.getLight();\n        this._brush.setXYZ(x, y, z).erase();\n        this._nDataTool.clear().loadInAt(x, y, z);\n        this._nDataTool.setLight(currentLight).commit();\n        tasks.queues.rgb.remove.push(x, y, z);\n        RGBRemove(tasks);\n        SunUpdate(tasks);\n        RGBUpdate(tasks);\n    },\n    getFlowRate(substance) {\n        this._substanceTool.setSubstance(substance);\n        return this._substanceTool.getFlowRate();\n    },\n    getVoxel(x, y, z) {\n        if (!this._sDataTool.loadInAt(x, y, z))\n            return false;\n        if (!this._sDataTool.isRenderable())\n            return false;\n        const substance = this._sDataTool.getSubstnaceData();\n        if (!substance.isLiquid())\n            return false;\n        return this._sDataTool;\n    },\n    setLevel(level, x, y, z) {\n        this._nDataTool.loadInAt(x, y, z);\n        this._nDataTool.setLevel(level).commit();\n    },\n    getLevel(vox, x, y, z) {\n        if (!this._nDataTool.loadInAt(x, y, z))\n            return -2;\n        const voxel = this._nDataTool.getStringId();\n        if (this._nDataTool.isAir()) {\n            return 0;\n        }\n        if (voxel == vox) {\n            return this._nDataTool.getLevel();\n        }\n        return -1;\n    },\n    getLevelState(vox, x, y, z) {\n        if (!this._nDataTool.loadInAt(x, y, z))\n            return -2;\n        const voxel = this._nDataTool.getStringId();\n        if (voxel == vox) {\n            return this._nDataTool.getLevelState();\n        }\n        if (this._nDataTool.isAir()) {\n            return -1;\n        }\n        return -3;\n    },\n    canFlowOutwardTest(vox, x, y, z) {\n        const level = this.getLevel(vox, x, y - 1, z);\n        if (level == -1) {\n            return true;\n        }\n        return false;\n    },\n    flowDownTest(vox, x, y, z) {\n        const level = this.getLevel(vox, x, y - 1, z);\n        if (level >= 0) {\n            return true;\n        }\n        return false;\n    },\n    wait(ms) {\n        return new Promise((resolve, reject) => setTimeout(resolve, ms));\n    },\n    _lightValues: [0, 0, 0, 0],\n    getAbsorbLight(x, y, z) {\n        for (const n of $3dCardinalNeighbors) {\n            if (!n[0] && !n[1] && !n[2])\n                continue;\n            if (!this._nDataTool.loadInAt(x + n[0], y + n[1], z + n[2]))\n                continue;\n            let l = this._nDataTool.getLight();\n            if (l <= 0)\n                continue;\n            const v = this.lightData.getLightValues(l);\n            for (let i = 0; i < 4; i++) {\n                if (this._lightValues[i] < v[i]) {\n                    this._lightValues[i] = v[i];\n                }\n            }\n        }\n        let brightest = this.lightData.setLightValues(this._lightValues);\n        for (let i = 0; i < 4; i++) {\n            this._lightValues[i] = 0;\n        }\n        return this.lightData.minusOneForAll(brightest);\n    },\n    sunCheck(tasks, x, y, z) {\n        if (!this._nDataTool.loadInAt(x, y - 1, z))\n            return;\n        if (!this._nDataTool.isAir())\n            return;\n        const l = this._nDataTool.getLight();\n        if (this.lightData.getS(l) == 0xf) {\n            tasks.queues.sun.remove.push(x, y - 1, z);\n        }\n    },\n};\n","import { FlowManager as FM } from \"../FlowManager.js\";\nimport { FlowUpdate } from \"./FlowUpdate.js\";\nimport { EngineSettings } from \"../../../../Data/Settings/EngineSettings.js\";\nfunction RunRemoveCheck(tasks, vox) {\n    const [dimension, x, y, z] = tasks.origin;\n    const queue = tasks.queues.flow.remove.queue;\n    const cl = FM.getLevel(vox, x, y, z);\n    queue.push([x, y, z]);\n    const n1 = FM.getLevel(vox, x + 1, y, z);\n    const n1s = FM.getLevelState(vox, x + 1, y, z);\n    if ((n1 > -1 && n1 < cl) || n1s == 1) {\n        queue.push([x + 1, y, z]);\n    }\n    const n2 = FM.getLevel(vox, x - 1, y, z);\n    const n2s = FM.getLevelState(vox, x - 1, y, z);\n    if ((n2 > 0 && n2 < cl) || n2s == 1) {\n        queue.push([x - 1, y, z]);\n    }\n    const n3 = FM.getLevel(vox, x, y, z + 1);\n    const n3s = FM.getLevelState(vox, x, y, z + 1);\n    if ((n3 > 0 && n3 < cl) || n3s == 1) {\n        queue.push([x, y, z + 1]);\n    }\n    const n4 = FM.getLevel(vox, x, y, z - 1);\n    const n4s = FM.getLevelState(vox, x, y, z - 1);\n    if ((n4 > 0 && n4 < cl) || n4s == 1) {\n        queue.push([x, y, z - 1]);\n    }\n}\nexport async function FlowRemove(tasks) {\n    const [dimension, x, y, z] = tasks.origin;\n    const vox = FM.getVoxel(x, y, z);\n    if (!vox)\n        return;\n    const voxId = vox.getStringId();\n    const flowRate = vox.getSubstnaceData().getFlowRate();\n    RunRemoveCheck(tasks, voxId);\n    const noRemoveMap = tasks.queues.flow.remove.noRemoveMap;\n    while (tasks.queues.flow.remove.queue.length != 0) {\n        FM.setDimension(dimension);\n        RunRemovePropagation(tasks, voxId);\n        RunFlowReduce(tasks, voxId);\n        await FlowUpdate(tasks, false);\n        noRemoveMap.clear();\n        tasks.runRebuildQueue();\n        await FM.wait(EngineSettings.settings.flow.baseFlowLimit * flowRate);\n    }\n}\nfunction RunRemovePropagation(tasks, vox) {\n    const removeQ = tasks.queues.flow.remove.queue;\n    const updateQ = tasks.queues.flow.update.queue;\n    const map = tasks.queues.flow.update.map;\n    const noRemoveMap = tasks.queues.flow.remove.noRemoveMap;\n    for (let i = 0; i < removeQ.length; i++) {\n        const node = removeQ[i];\n        const x = node[0];\n        const y = node[1];\n        const z = node[2];\n        const l = FM.getLevel(vox, x, y, z);\n        const s = FM.getLevelState(vox, x, y, z);\n        map.add(x, y, z);\n        if (noRemoveMap.inMap(x, y, z))\n            continue;\n        n1t: if (!map.inMap(x + 1, y, z)) {\n            const n1 = FM.getLevel(vox, x + 1, y, z);\n            const n1s = FM.getLevelState(vox, x + 1, y, z);\n            if (n1 <= 0 || n1s == 1)\n                break n1t;\n            if (n1 < l && l > 0 && n1 > 0) {\n                removeQ.push([x + 1, y, z]);\n            }\n            if (n1 > l) {\n                updateQ.push([x + 1, y, z]);\n            }\n        }\n        n2t: if (!map.inMap(x - 1, y, z)) {\n            const n2 = FM.getLevel(vox, x - 1, y, z);\n            const n2s = FM.getLevelState(vox, x - 1, y, z);\n            if (n2 <= 0 || n2s == 1)\n                break n2t;\n            if (n2 < l && l > 0 && n2 > 0) {\n                removeQ.push([x - 1, y, z]);\n            }\n            if (n2 > l) {\n                updateQ.push([x - 1, y, z]);\n            }\n        }\n        n3t: if (!map.inMap(x, y, z + 1)) {\n            const n3 = FM.getLevel(vox, x, y, z + 1);\n            const n3s = FM.getLevelState(vox, x, y, z + 1);\n            if (n3 <= 0 || n3s == 1)\n                break n3t;\n            if (n3 < l && l > 0 && n3 > 0) {\n                removeQ.push([x, y, z + 1]);\n            }\n            if (n3 > l) {\n                updateQ.push([x, y, z + 1]);\n            }\n        }\n        n4t: if (!map.inMap(x, y, z - 1)) {\n            const n4 = FM.getLevel(vox, x, y, z - 1);\n            const n4s = FM.getLevelState(vox, x, y, z - 1);\n            if (n4 <= 0 || n4s == 1)\n                break n4t;\n            if (n4 < l && l > 0 && n4 > 0) {\n                removeQ.push([x, y, z - 1]);\n            }\n            if (n4 > l) {\n                updateQ.push([x, y, z - 1]);\n            }\n        }\n        if (!map.inMap(x, y - 1, z)) {\n            const n5 = FM.getLevel(vox, x, y - 1, z);\n            if (n5 < 0)\n                continue;\n            const n5s = FM.getLevelState(vox, x, y - 1, z);\n            let add = false;\n            if (s == 1 && n5s == 1) {\n                if (l < 2) {\n                    add = true;\n                }\n            }\n            if (s == 0 && l < 2) {\n                add = true;\n            }\n            if (add) {\n                removeQ.push([x, y - 1, z]);\n            }\n        }\n    }\n    map.clear();\n}\nfunction RunFlowReduce(tasks, vox) {\n    const queue = tasks.queues.flow.remove.queue;\n    const map = tasks.queues.flow.remove.map;\n    const reque = [];\n    while (queue.length != 0) {\n        const node = queue.shift();\n        if (!node) {\n            break;\n        }\n        const x = node[0];\n        const y = node[1];\n        const z = node[2];\n        if (map.inMap(x, y, z))\n            continue;\n        map.add(x, y, z);\n        const l = FM.getLevel(vox, x, y, z);\n        const state = FM.getLevelState(vox, x, y, z);\n        let syncRebuild = false;\n        if (l <= 1) {\n            FM.removeVoxel(tasks, x, y, z);\n            if (state == 1)\n                syncRebuild = true;\n        }\n        else {\n            FM.setLevel(l - 1, x, y, z);\n            reque.push([x, y, z]);\n        }\n        tasks.setBuldMode(syncRebuild ? \"sync\" : \"async\").addToRebuildQueue(x, y, z);\n    }\n    tasks.queues.flow.remove.queue = reque;\n    map.clear();\n}\n","import { FlowManager as FM } from \"../FlowManager.js\";\nimport { EngineSettings } from \"../../../../Data/Settings/EngineSettings.js\";\nexport async function FlowUpdate(tasks, rebuild = true) {\n    const [dimension, x, y, z] = tasks.origin;\n    const vox = FM.getVoxel(x, y, z);\n    if (!vox)\n        return;\n    const flowRate = vox.getSubstnaceData().getFlowRate();\n    const level = FM.getLevel(vox.getStringId(), x, y, z);\n    if (level < 0)\n        return;\n    const levelState = FM.getLevelState(vox.getStringId(), x, y, z);\n    tasks.queues.flow.update.queue.push([x, y, z, level, levelState]);\n    while (tasks.queues.flow.update.queue.length != 0) {\n        FM.setDimension(dimension);\n        RunFlowPropagation(tasks, vox.getStringId());\n        RunFlowIncrease(tasks, vox.getStringId());\n        if (rebuild) {\n            tasks.runRebuildQueue();\n            await FM.wait(EngineSettings.settings.flow.baseFlowLimit * flowRate);\n        }\n    }\n}\nfunction RunFlowPropagation(tasks, vox) {\n    const que = tasks.queues.flow.update.queue;\n    const noRemoveMap = tasks.queues.flow.remove.noRemoveMap;\n    for (let i = 0; i < que.length; i++) {\n        const node = que[i];\n        const x = node[0];\n        const y = node[1];\n        const z = node[2];\n        const l = FM.getLevel(vox, x, y, z);\n        const s = FM.getLevelState(vox, x, y, z);\n        noRemoveMap.add(x, y, z);\n        if (FM.canFlowOutwardTest(vox, x, y, z)) {\n            const n1 = FM.getLevel(vox, x + 1, y, z);\n            if (n1 + 2 < l && n1 >= 0) {\n                let n1l = l - 2;\n                que.push([x + 1, y, z, n1l, 0]);\n            }\n            const n2 = FM.getLevel(vox, x - 1, y, z);\n            if (n2 + 2 < l && n2 >= 0) {\n                let n2l = l - 2;\n                que.push([x - 1, y, z, n2l, 0]);\n            }\n            const n3 = FM.getLevel(vox, x, y, z + 1);\n            if (n3 + 2 < l && n3 >= 0) {\n                let n3l = l - 2;\n                que.push([x, y, z + 1, n3l, 0]);\n            }\n            const n4 = FM.getLevel(vox, x, y, z - 1);\n            if (n4 + 2 < l && n4 >= 0) {\n                let n4l = l - 2;\n                que.push([x, y, z - 1, n4l, 0]);\n            }\n        }\n        const n5 = FM.getLevel(vox, x, y - 1, z);\n        if (n5 <= l && n5 >= 0) {\n            let state = 1;\n            let level = 15;\n            if (l <= 0 && s != 1) {\n                state = 0;\n                level = l - 2;\n            }\n            que.push([x, y - 1, z, level, state]);\n        }\n    }\n}\nfunction RunFlowIncrease(tasks, vox) {\n    const que = tasks.queues.flow.update.queue;\n    const map = tasks.queues.flow.update.map;\n    const reque = [];\n    while (que.length != 0) {\n        const node = que.shift();\n        if (!node) {\n            break;\n        }\n        const x = node[0];\n        const y = node[1];\n        const z = node[2];\n        const level = node[3];\n        const levelState = node[4];\n        if (map.inMap(x, y, z))\n            continue;\n        map.add(x, y, z);\n        if (level > -1) {\n            FM.setVoxel(tasks, vox, level, levelState, x, y, z);\n            reque.push([x, y, z, -1]);\n        }\n        tasks.addToRebuildQueue(x, y, z);\n    }\n    //@ts-ignore\n    tasks.queues.flow.update.queue = reque;\n    map.clear();\n}\n","import { IlluminationManager as IM } from \"../IlluminationManager.js\";\nexport function RGBUpdate(tasks) {\n    IM.setDimension(tasks.origin[0]);\n    const queue = tasks.queues.rgb.update;\n    while (queue.length != 0) {\n        const x = queue.shift();\n        const y = queue.shift();\n        const z = queue.shift();\n        if (!IM._sDataTool.loadInAt(x, y, z))\n            continue;\n        if (IM._sDataTool.isBarrier())\n            continue;\n        const sl = IM._sDataTool.getLight();\n        if (sl <= 0)\n            continue;\n        if (IM._nDataTool.loadInAt(x - 1, y, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\n                queue.push(x - 1, y, z);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x + 1, y, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\n                queue.push(x + 1, y, z);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y, z - 1)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\n                queue.push(x, y, z - 1);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y, z + 1)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\n                queue.push(x, y, z + 1);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y - 1, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\n                queue.push(x, y - 1, z);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y + 1, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\n                queue.push(x, y + 1, z);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\n            }\n        }\n        tasks.addNeighborsToRebuildQueue(x, y, z);\n    }\n}\nexport function RGBRemove(tasks) {\n    IM.setDimension(tasks.origin[0]);\n    const remove = tasks.queues.rgb.remove;\n    const update = tasks.queues.rgb.update;\n    const map = tasks.queues.rgb.map;\n    while (remove.length != 0) {\n        const x = remove.shift();\n        const y = remove.shift();\n        const z = remove.shift();\n        if (map.inMap(x, y, z))\n            continue;\n        map.add(x, y, z);\n        if (!IM._sDataTool.loadInAt(x, y, z))\n            continue;\n        const sl = IM._sDataTool.getLight();\n        if (sl <= 0)\n            continue;\n        if (IM._nDataTool.loadInAt(x - 1, y, z)) {\n            const nl = IM._nDataTool.getLight();\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\n                remove.push(x - 1, y, z);\n                if (IM._nDataTool.isLightSource()) {\n                    update.push(x - 1, y, z);\n                }\n            }\n            else {\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\n                    update.push(x - 1, y, z);\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x + 1, y, z)) {\n            const nl = IM._nDataTool.getLight();\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\n                remove.push(x + 1, y, z);\n                if (IM._nDataTool.isLightSource()) {\n                    update.push(x + 1, y, z);\n                }\n            }\n            else {\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\n                    update.push(x + 1, y, z);\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y, z - 1)) {\n            const nl = IM._nDataTool.getLight();\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\n                remove.push(x, y, z - 1);\n            }\n            else {\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\n                    update.push(x, y, z - 1);\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y, z + 1)) {\n            const nl = IM._nDataTool.getLight();\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\n                remove.push(x, y, z + 1);\n                if (IM._nDataTool.isLightSource()) {\n                    update.push(x, y, z + 1);\n                }\n            }\n            else {\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\n                    update.push(x, y, z + 1);\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y - 1, z)) {\n            const nl = IM._nDataTool.getLight();\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\n                remove.push(x, y - 1, z);\n                if (IM._nDataTool.isLightSource()) {\n                    update.push(x, y - 1, z);\n                }\n            }\n            else {\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\n                    update.push(x, y - 1, z);\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y + 1, z)) {\n            const nl = IM._nDataTool.getLight();\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\n                remove.push(x, y + 1, z);\n                if (IM._nDataTool.isLightSource()) {\n                    update.push(x, y + 1, z);\n                }\n            }\n            else {\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\n                    update.push(x, y + 1, z);\n                }\n            }\n        }\n        tasks.addNeighborsToRebuildQueue(x, y, z);\n        IM._sDataTool.setLight(IM.lightData.removeRGBLight(sl)).commit();\n    }\n    map.clear();\n}\n","import { IlluminationManager as IM } from \"../IlluminationManager.js\";\nexport function SunUpdate(tasks) {\n    const update = tasks.queues.sun.update;\n    while (update.length > 0) {\n        const x = update.shift();\n        const y = update.shift();\n        const z = update.shift();\n        if (!IM._sDataTool.loadInAt(x, y, z))\n            continue;\n        const sl = IM._sDataTool.getLight();\n        if (sl <= 0)\n            continue;\n        if (!IM.lightData.getS(sl))\n            continue;\n        if (IM._nDataTool.loadInAt(x - 1, y, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\n                update.push(x - 1, y, z);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x + 1, y, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\n                update.push(x + 1, y, z);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y, z - 1)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\n                update.push(x, y, z - 1);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y, z + 1)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\n                update.push(x, y, z + 1);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y - 1, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAddDown(nl, sl)) {\n                if (IM._nDataTool.isAir()) {\n                    update.push(x, y - 1, z);\n                    IM._nDataTool\n                        .setLight(IM.lightData.getSunLightForUnderVoxel(sl, nl))\n                        .commit();\n                }\n                else {\n                    const substance = IM._nDataTool.getSubstance();\n                    if (substance != \"#dve_magma\" && substance != \"#dve_solid\") {\n                        update.push(x, y - 1, z);\n                        IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n                    }\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y + 1, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\n                update.push(x, y + 1, z);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n            }\n        }\n        tasks.addNeighborsToRebuildQueue(x, y, z);\n    }\n}\nexport function SunRemove(tasks, clearUpdateMap = true) {\n    const remove = tasks.queues.sun.remove;\n    const update = tasks.queues.sun.update;\n    const removeMap = tasks.queues.sun.remvoeMap;\n    const updateMap = tasks.queues.sun.updateMap;\n    while (remove.length != 0) {\n        const x = remove.shift();\n        const y = remove.shift();\n        const z = remove.shift();\n        if (removeMap.inMap(x, y, z))\n            continue;\n        removeMap.add(x, y, z);\n        if (!IM._sDataTool.loadInAt(x, y, z))\n            continue;\n        const sl = IM._sDataTool.getLight();\n        if (sl <= 0)\n            continue;\n        if (!IM.lightData.getS(sl))\n            continue;\n        if (IM._nDataTool.loadInAt(x - 1, y, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > 0) {\n                if (IM.lightData.isLessThanForSunRemove(nl, sl)) {\n                    remove.push(x - 1, y, z);\n                }\n                else {\n                    if (!updateMap.inMap(x - 1, y, z) &&\n                        IM.lightData.isGreaterOrEqualThanForSunRemove(nl, sl)) {\n                        update.push(x - 1, y, z);\n                        updateMap.add(x - 1, y, z);\n                    }\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x + 1, y, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > 0) {\n                if (IM.lightData.isLessThanForSunRemove(nl, sl)) {\n                    remove.push(x + 1, y, z);\n                }\n                else {\n                    if (!updateMap.inMap(x + 1, y, z) &&\n                        IM.lightData.isGreaterOrEqualThanForSunRemove(nl, sl)) {\n                        update.push(x + 1, y, z);\n                        updateMap.add(x + 1, y, z);\n                    }\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y, z - 1)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > 0) {\n                if (IM.lightData.isLessThanForSunRemove(nl, sl)) {\n                    remove.push(x, y, z - 1);\n                }\n                else {\n                    if (!updateMap.inMap(x, y, z - 1) &&\n                        IM.lightData.isGreaterOrEqualThanForSunRemove(nl, sl)) {\n                        update.push(x, y, z - 1);\n                        updateMap.add(x, y, z - 1);\n                    }\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y, z + 1)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > 0) {\n                if (IM.lightData.isLessThanForSunRemove(nl, sl)) {\n                    remove.push(x, y, z + 1);\n                }\n                else {\n                    if (!updateMap.inMap(x, y, z + 1) &&\n                        IM.lightData.isGreaterOrEqualThanForSunRemove(nl, sl)) {\n                        update.push(x, y, z + 1);\n                        updateMap.add(x, y, z + 1);\n                    }\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y - 1, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > 0) {\n                if (IM.lightData.sunLightCompareForDownSunRemove(nl, sl)) {\n                    remove.push(x, y - 1, z);\n                }\n                else {\n                    if (!updateMap.inMap(x, y - 1, z) &&\n                        IM.lightData.isGreaterOrEqualThanForSunRemove(nl, sl)) {\n                        update.push(x, y - 1, z);\n                        updateMap.add(x, y - 1, z);\n                    }\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y + 1, z)) {\n            const n6 = IM._nDataTool.getLight();\n            if (n6 > 0) {\n                if (IM.lightData.isLessThanForSunRemove(n6, sl)) {\n                    remove.push(x, y + 1, z);\n                }\n                else {\n                    if (!updateMap.inMap(x, y - 1, z) &&\n                        IM.lightData.isGreaterOrEqualThanForSunRemove(n6, sl)) {\n                        update.push(x, y + 1, z);\n                        updateMap.add(x, y + 1, z);\n                    }\n                }\n            }\n        }\n        tasks.addNeighborsToRebuildQueue(x, y, z);\n        IM._sDataTool.setLight(IM.lightData.removeSunLight(sl)).commit();\n    }\n    if (clearUpdateMap)\n        updateMap.clear();\n    removeMap.clear();\n}\n","//data\nimport { WorldBounds } from \"../../../../Data/World/WorldBounds.js\";\nimport { WorldRegister } from \"../../../../Data/World/WorldRegister.js\";\nimport { $3dCardinalNeighbors } from \"../../../../Math/Constants/CardinalNeighbors.js\";\nimport { WorldSpaces } from \"../../../../Data/World/WorldSpaces.js\";\nimport { IlluminationManager as IM } from \"../IlluminationManager.js\";\nimport { HeightMapTool } from \"../../../../Tools/Data/WorldData/HeightMapTool.js\";\nconst inColumnBounds = (cx, cz, x, z) => {\n    if (x >= cx &&\n        x <= cx + WorldSpaces.chunk._bounds.x &&\n        z >= cz &&\n        z <= cz + WorldSpaces.chunk._bounds.z)\n        return true;\n    return false;\n};\nconst heightMapTool = new HeightMapTool();\nexport function RunWorldSun(tasks) {\n    IM.setDimension(tasks.origin[0]);\n    tasks.start();\n    if (!WorldRegister.column.get(tasks.origin))\n        return false;\n    const [dimension, cx, cy, cz] = tasks.origin;\n    const queue = tasks.queues.sun;\n    IM._sDataTool.setDimension(dimension);\n    const RmaxY = heightMapTool.column.getRelative(tasks.origin);\n    const AmaxY = heightMapTool.column.getAbsolute(tasks.origin);\n    //fill\n    for (let iy = AmaxY; iy < WorldBounds.bounds.MaxY; iy++) {\n        for (let iz = cz; iz < cz + WorldSpaces.chunk._bounds.z; iz++) {\n            for (let ix = cx; ix < cx + WorldSpaces.chunk._bounds.x; ix++) {\n                if (!IM._sDataTool.loadInAt(ix, iy, iz))\n                    continue;\n                const l = IM._sDataTool.getLight();\n                if (l < 0)\n                    continue;\n                IM._sDataTool.setLight(IM.lightData.setS(0xf, l)).commit();\n            }\n        }\n    }\n    //accumulate\n    for (let iy = AmaxY; iy <= RmaxY; iy++) {\n        for (let iz = cz; iz < cz + WorldSpaces.chunk._bounds.z; iz++) {\n            for (let ix = cx; ix < cx + WorldSpaces.chunk._bounds.x; ix++) {\n                if (!IM._sDataTool.loadInAt(ix, iy, iz))\n                    continue;\n                const l = IM._sDataTool.getLight();\n                if (l < 0 && IM.lightData.getS(l) != 0xf)\n                    continue;\n                let add = false;\n                for (const n of $3dCardinalNeighbors) {\n                    const nx = ix + n[0];\n                    const ny = iy + n[1];\n                    const nz = iz + n[2];\n                    if (IM._nDataTool.loadInAt(nx, ny, nz)) {\n                        const nl = IM._nDataTool.getLight();\n                        if (nl >= 0 && IM.lightData.getS(nl) < 0xf) {\n                            add = true;\n                            break;\n                        }\n                    }\n                }\n                if (add) {\n                    queue.push(ix, iy, iz);\n                }\n            }\n        }\n    }\n    //flood\n    while (queue.length) {\n        const x = queue.shift();\n        const y = queue.shift();\n        const z = queue.shift();\n        if (!IM._sDataTool.loadInAt(x, y, z))\n            continue;\n        const sl = IM._sDataTool.getLight();\n        if (sl <= 0)\n            continue;\n        const sunL = IM.lightData.getS(sl);\n        if (sunL >= 0xf && !inColumnBounds(cx, cz, x, z))\n            continue;\n        if (IM._nDataTool.loadInAt(x - 1, y, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\n                queue.push(x - 1, y, z);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x + 1, y, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\n                queue.push(x + 1, y, z);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y, z - 1)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\n                queue.push(x, y, z - 1);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y, z + 1)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\n                queue.push(x, y, z + 1);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y - 1, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAddDown(nl, sl)) {\n                if (IM._nDataTool.isAir()) {\n                    queue.push(x, y - 1, z);\n                    IM._nDataTool\n                        .setLight(IM.lightData.getSunLightForUnderVoxel(sl, nl))\n                        .commit();\n                }\n                else {\n                    const substance = IM._nDataTool.getSubstance();\n                    if (substance != \"#dve_magma\" && substance != \"#dve_solid\") {\n                        queue.push(x, y - 1, z);\n                        IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n                    }\n                }\n            }\n        }\n        if (IM._nDataTool.loadInAt(x, y + 1, z)) {\n            const nl = IM._nDataTool.getLight();\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\n                queue.push(x, y + 1, z);\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\n            }\n        }\n    }\n    tasks.stop();\n}\n","//functions\nimport { DataTool } from \"../../../Tools/Data/DataTool.js\";\nimport { LightData } from \"../../../Data/Light/LightByte.js\";\nexport const IlluminationManager = {\n    lightData: LightData,\n    //tools\n    _sDataTool: new DataTool(),\n    _nDataTool: new DataTool(),\n    setDimension(dimension) {\n        this._sDataTool.setDimension(dimension);\n        this._nDataTool.setDimension(dimension);\n    },\n};\n","import { RGBRemove, RGBUpdate } from \"./Illumanation/Functions/RGBUpdate.js\";\nimport { SunRemove, SunUpdate } from \"./Illumanation/Functions/SunUpdate.js\";\nimport { RunWorldSun } from \"./Illumanation/Functions/WorldSun.js\";\nimport { FlowUpdate } from \"./Flow/Functions/FlowUpdate.js\";\nimport { FlowRemove } from \"./Flow/Functions/FlowRemove.js\";\nimport { ExplosionManager } from \"./Explosion/ExplosionManager.js\";\nexport const Propagation = {\n    expolosion: {\n        run(tasks) {\n            ExplosionManager.runExplosion(tasks);\n        },\n    },\n    flow: {\n        async update(tasks) {\n            await FlowUpdate(tasks);\n        },\n        async remove(tasks) {\n            await FlowRemove(tasks);\n        },\n    },\n    worldSun: {\n        run(tasks) {\n            RunWorldSun(tasks);\n        },\n    },\n    rgb: {\n        update(tasks) {\n            RGBUpdate(tasks);\n        },\n        remove(tasks) {\n            RGBRemove(tasks);\n        },\n    },\n    sun: {\n        update(tasks) {\n            SunUpdate(tasks);\n        },\n        remove(tasks) {\n            SunRemove(tasks);\n        },\n    },\n};\n","import { ConstructorTasks } from \"../../Common/Threads/Contracts/ConstructorTasks.js\";\nimport { DVEC } from \"../DivineVoxelEngineConstructor.js\";\nimport { ThreadComm } from \"threadcomm\";\nimport { EreaseAndUpdate, PaintAndUpdate, VoxelUpdate, } from \"./Functions/VoxelUpdate.js\";\nimport { WorldRegister } from \"../../Data/World/WorldRegister.js\";\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\nimport { TasksRequest } from \"./TasksRequest.js\";\nconst chunkTool = new ChunkDataTool();\nexport const Tasks = {\n    data: {\n        syncTextures: ThreadComm.registerTasks(\"sync-texuture-index\", (data) => {\n            DVEC.builder.textureManager.setTextureIndex(data);\n            DVEC.hooks.texturesRegistered.run(DVEC.builder.textureManager);\n        }),\n    },\n    build: {\n        nodeMesh: ThreadComm.registerTasks(\"build-node-mesh\", (data, onDone) => {\n            const nodeData = DVEC.builder.nodes.buildNode(data);\n            if (!nodeData)\n                return onDone ? onDone(false) : 0;\n            onDone ? onDone(nodeData[0], nodeData[1]) : 0;\n        }, \"deferred\"),\n        chunk: {\n            tasks: ThreadComm.registerTasks(ConstructorTasks.buildChunk, async (buildData, onDone) => {\n                const location = buildData.data[0];\n                await DVEC.builder.buildChunk(location, buildData.data[1]);\n                if (onDone)\n                    onDone();\n            }),\n        },\n        column: ThreadComm.registerTasks(ConstructorTasks.buildColumn, async (data, onDone) => {\n            const column = WorldRegister.column.get(data[0]);\n            if (!column)\n                return false;\n            if (column.chunks.size == 0)\n                return false;\n            let totalChunks = 0;\n            const location = data[0];\n            for (const [key, chunk] of column.chunks) {\n                chunkTool.setChunk(chunk);\n                const chunkPOS = chunkTool.getPositionData();\n                location[1] = chunkPOS.x;\n                location[2] = chunkPOS.y;\n                location[3] = chunkPOS.z;\n                totalChunks++;\n                DVEC.builder.buildChunk([...location]);\n            }\n            if (onDone)\n                onDone();\n        }, \"deferred\"),\n    },\n    voxelUpdate: {\n        update: ThreadComm.registerTasks(ConstructorTasks.voxelUpdate, async (data, onDone) => {\n            await VoxelUpdate(data);\n            if (onDone)\n                onDone();\n        }, \"deferred\"),\n        erase: ThreadComm.registerTasks(ConstructorTasks.voxelErease, async (data, onDone) => {\n            await EreaseAndUpdate(data);\n            if (onDone)\n                onDone();\n        }, \"deferred\"),\n        paint: ThreadComm.registerTasks(ConstructorTasks.voxelPaint, async (data, onDone) => {\n            await PaintAndUpdate(data);\n            if (onDone)\n                onDone();\n        }, \"deferred\"),\n    },\n    explosion: ThreadComm.registerTasks(ConstructorTasks.explosion, async (data) => {\n        await DVEC.propagation.expolosion.run(TasksRequest.getExplosionRequests(data[0], data[1], data[2], data[3]));\n    }),\n    worldSun: ThreadComm.registerTasks(ConstructorTasks.worldSun, (data, onDone) => {\n        DVEC.propagation.worldSun.run(TasksRequest.getWorldSunRequests(data[0], data[1]));\n        if (onDone)\n            onDone();\n    }, \"deferred\"),\n    worldGen: {\n        generate: ThreadComm.registerTasks(ConstructorTasks.generate, (data, onDone) => {\n            if (!onDone)\n                return;\n            DVEC.worldGen.generate(data, \"generate\", onDone);\n        }, \"deferred\"),\n        decorate: ThreadComm.registerTasks(ConstructorTasks.decorate, (data, onDone) => {\n            if (!onDone)\n                return;\n            DVEC.worldGen.generate(data, \"decorate\", onDone);\n        }, \"deferred\"),\n    },\n    anaylzer: {\n        propagation: ThreadComm.registerTasks(ConstructorTasks.analyzerPropagation, async (data, onDone) => {\n            await DVEC.analyzer.runPropagation(data);\n            if (onDone)\n                onDone();\n        }, \"deferred\"),\n        update: ThreadComm.registerTasks(ConstructorTasks.analyzerUpdate, async (data, onDone) => {\n            await DVEC.analyzer.runUpdate(data);\n            if (onDone)\n                onDone();\n        }, \"deferred\"),\n    },\n};\n","import { Propagation } from \"../../Propagation/Propagation.js\";\nimport { EngineSettings as ES } from \"../../../Data/Settings/EngineSettings.js\";\nimport { DataTool } from \"../../../Tools/Data/DataTool.js\";\nimport { $3dCardinalNeighbors } from \"../../../Math/Constants/CardinalNeighbors.js\";\nimport { BrushTool } from \"../../../Tools/Brush/Brush.js\";\nimport { TasksRequest } from \"../TasksRequest.js\";\nconst dataTool = new DataTool();\nconst nDataTool = new DataTool();\nconst brushTool = new BrushTool();\nbrushTool._update = false;\nconst updateLightTask = (tasks) => {\n    let doRGB = ES.doRGBPropagation();\n    let doSun = ES.doSunPropagation();\n    const [dimension, x, y, z] = tasks.origin;\n    nDataTool.setDimension(dimension);\n    for (const n of $3dCardinalNeighbors) {\n        const nx = n[0] + x;\n        const ny = n[1] + y;\n        const nz = n[2] + z;\n        if (!nDataTool.loadInAt(nx, ny, nz))\n            continue;\n        if (doRGB) {\n            if (nDataTool.hasRGBLight()) {\n                tasks.queues.rgb.update.push(nx, ny, nz);\n            }\n        }\n        if (doSun) {\n            if (nDataTool.hasSunLight()) {\n                tasks.queues.sun.update.push(nx, ny, nz);\n            }\n        }\n    }\n};\nexport async function EreaseAndUpdate(data) {\n    if (!dataTool.setLocation(data[0]).loadIn())\n        return false;\n    const [dimension, x, y, z] = data[0];\n    const tasks = TasksRequest.getVoxelUpdateRequests(data[0], data[1], data[2]);\n    tasks.setPriority(0).start().setBuldMode(\"sync\").addToRebuildQueue(x, y, z);\n    tasks.setBuldMode(\"async\").addNeighborsToRebuildQueue(x, y, z);\n    if (ES.doFlow()) {\n        if (dataTool.getSubstnaceData().isLiquid()) {\n            await Propagation.flow.remove(tasks);\n            tasks.stop();\n            return true;\n        }\n    }\n    const light = dataTool.getLight();\n    const isLightSource = dataTool.isLightSource();\n    dataTool\n        .setLight(light > 0 ? light : 0)\n        .setAir()\n        .commit(2);\n    if (ES.doLight()) {\n        if (ES.doRGBPropagation() && isLightSource) {\n            tasks.queues.rgb.remove.push(x, y, z);\n            Propagation.rgb.remove(tasks);\n        }\n        updateLightTask(tasks);\n        if (ES.doRGBPropagation()) {\n            Propagation.rgb.update(tasks);\n        }\n        if (ES.doSunPropagation()) {\n            Propagation.sun.update(tasks);\n        }\n    }\n    // LocationDataDistanceSort(tasks.origin, tasks.syncQueue);\n    tasks.runRebuildQueue();\n    tasks.stop();\n    return true;\n}\nexport async function PaintAndUpdate(data) {\n    if (!dataTool.setLocation(data[0]).loadIn())\n        return false;\n    const [dimension, x, y, z] = data[0];\n    const raw = data[1];\n    const tasks = TasksRequest.getVoxelUpdateRequests(data[0], data[2], data[3]);\n    tasks.start().setPriority(0).setBuldMode(\"sync\").addToRebuildQueue(x, y, z);\n    tasks.setBuldMode(\"async\").addNeighborsToRebuildQueue(x, y, z);\n    brushTool.setLocation(data[0]).setRaw(raw);\n    nDataTool.loadInRaw(raw);\n    const substanceData = nDataTool.getSubstnaceData();\n    const isOpaque = nDataTool.isOpaque();\n    let doRGB = ES.doRGBPropagation();\n    let doSun = ES.doSunPropagation();\n    lighttest: if (ES.doLight()) {\n        const light = dataTool.getLight();\n        if (light <= 0)\n            break lighttest;\n        if (doSun) {\n            if (dataTool.hasSunLight()) {\n                tasks.queues.sun.remove.push(x, y, z);\n                Propagation.sun.remove(tasks);\n            }\n        }\n        if (doRGB) {\n            if (dataTool.hasRGBLight() && isOpaque) {\n                tasks.queues.rgb.remove.push(x, y, z);\n                Propagation.rgb.remove(tasks);\n            }\n        }\n    }\n    brushTool.paint();\n    if (ES.doLight()) {\n        updateLightTask(tasks);\n        if (doRGB) {\n            tasks.queues.rgb.update.push(x, y, z);\n            Propagation.rgb.update(tasks);\n        }\n        if (doSun) {\n            Propagation.sun.update(tasks);\n        }\n    }\n    if (ES.doFlow()) {\n        if (substanceData.isLiquid()) {\n            Propagation.flow.update(tasks);\n        }\n    }\n    tasks.runRebuildQueue();\n    tasks.stop();\n    return;\n}\nexport async function VoxelUpdate(data) {\n    if (!dataTool.setLocation(data[0]).loadIn())\n        return false;\n    const [dimension, x, y, z] = data[0];\n    const tasks = TasksRequest.getVoxelUpdateRequests(data[0], data[2], data[3]);\n    tasks.setPriority(0).start().setBuldMode(\"sync\").addToRebuildQueue(x, y, z);\n    tasks.setBuldMode(\"async\").addNeighborsToRebuildQueue(x, y, z);\n    dataTool.loadInRaw(data[1]);\n    dataTool.commit();\n    let doRGB = ES.doRGBPropagation();\n    let doSun = ES.doSunPropagation();\n    if (ES.doLight()) {\n        updateLightTask(tasks);\n        if (doRGB) {\n            tasks.queues.rgb.update.push(x, y, z);\n            Propagation.rgb.update(tasks);\n        }\n        if (doSun) {\n            Propagation.sun.update(tasks);\n        }\n    }\n    if (ES.doFlow()) {\n        if (dataTool.getSubstnaceData().isLiquid()) {\n            Propagation.flow.update(tasks);\n        }\n    }\n    tasks.runRebuildQueue();\n    tasks.stop();\n    return;\n}\n","import { ConstructorRemoteThreadTasks } from \"../../Common/Threads/Contracts/ConstructorRemoteThreadTasks.js\";\nimport { EngineSettings } from \"../../Data/Settings/EngineSettings.js\";\nimport { ThreadComm } from \"threadcomm\";\nimport { $3dMooreNeighborhood } from \"../../Math/Constants/CardinalNeighbors.js\";\nimport { WorldSpaces } from \"../../Data/World/WorldSpaces.js\";\nimport { WorldRegister } from \"../../Data/World/WorldRegister.js\";\nimport { Builder } from \"../../Constructor/Builder/Builder.js\";\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\nimport { VisitedMap } from \"../../Global/Util/VisistedMap.js\";\nconst chunkTool = new ChunkDataTool();\nclass Request {\n    tasksType;\n    origin;\n    data;\n    buildQueue;\n    originThread;\n    queues;\n    rebuildQueMap = new Map();\n    comm;\n    priority = 2;\n    LOD = 0;\n    syncQueue = [];\n    aSyncQueue = [];\n    buildMode = \"sync\";\n    buildTasks = {\n        data: [[\"main\", 0, 0, 0], 1],\n        priority: 0,\n    };\n    rebuildTasks;\n    constructor(tasksType, origin, data, buildQueue = \"none\", originThread = \"self\", queues) {\n        this.tasksType = tasksType;\n        this.origin = origin;\n        this.data = data;\n        this.buildQueue = buildQueue;\n        this.originThread = originThread;\n        this.queues = queues;\n        if (originThread != \"self\") {\n            this.comm = ThreadComm.getComm(originThread);\n        }\n        this.rebuildTasks = [this.origin, this.buildQueue, this.priority];\n        return this;\n    }\n    start() {\n        WorldRegister.cache.enable();\n        return this;\n    }\n    stop() {\n        WorldRegister.cache.disable();\n        return this;\n    }\n    setPriority(priority) {\n        this.priority = priority;\n        return this;\n    }\n    getData() {\n        return this.data;\n    }\n    getOriginThread() {\n        return this.origin;\n    }\n    getBuildQueue() {\n        return this.buildQueue;\n    }\n    getOrigin() {\n        return this.origin;\n    }\n    needsRebuild() {\n        return this.buildQueue != \"none\";\n    }\n    needsToUpdateOriginThread() {\n        return this.originThread != \"self\";\n    }\n    setBuldMode(mode) {\n        this.buildMode = mode;\n        return this;\n    }\n    addToRebuildQueue(x, y, z) {\n        if (EngineSettings.isServer())\n            return false;\n        if (!this.needsRebuild())\n            return false;\n        if (!chunkTool.setDimension(this.origin[0]).loadInAt(x, y, z))\n            return false;\n        const chunkKey = WorldSpaces.chunk.getKeyLocation(chunkTool.location);\n        if (this.rebuildQueMap.has(chunkKey))\n            return false;\n        this.rebuildQueMap.set(chunkKey, true);\n        if (this.buildMode == \"async\") {\n            this.aSyncQueue.push([...chunkTool.location]);\n            return true;\n        }\n        this.syncQueue.push([...chunkTool.location]);\n        return true;\n    }\n    addNeighborsToRebuildQueue(x, y, z) {\n        if (!this.needsRebuild())\n            return false;\n        const voxelPOS = WorldSpaces.voxel.getPositionXYZ(x, y, z);\n        if (voxelPOS.x == 0 ||\n            voxelPOS.x == WorldSpaces.chunk._bounds.x - 1 ||\n            voxelPOS.y == 0 ||\n            voxelPOS.y == WorldSpaces.chunk._bounds.y - 1 ||\n            voxelPOS.z == 0 ||\n            voxelPOS.z == WorldSpaces.chunk._bounds.z - 1) {\n            let i = $3dMooreNeighborhood.length;\n            while (i--) {\n                this.addToRebuildQueue(x + $3dMooreNeighborhood[i][0], y + $3dMooreNeighborhood[i][1], z + $3dMooreNeighborhood[i][2]);\n            }\n            return;\n        }\n        this.addToRebuildQueue(x, y, z);\n        return this;\n    }\n    runRebuildQueue() {\n        while (this.aSyncQueue.length !== 0) {\n            const node = this.aSyncQueue.shift();\n            this.buildTasks.priority = this.priority;\n            if (!node)\n                break;\n            this.buildTasks.data[0] = node;\n            this.comm.runTasks(ConstructorRemoteThreadTasks.buildChunk, this.buildTasks);\n        }\n        while (this.syncQueue.length !== 0) {\n            const node = this.syncQueue.shift();\n            if (!node)\n                break;\n            Builder.buildChunk(node);\n        }\n        this.rebuildQueMap.clear();\n        return this;\n    }\n    clear() {\n        this.buildTasks.priority = 0;\n        this.syncQueue = [];\n        this.aSyncQueue = [];\n        this.rebuildQueMap.clear();\n        this.buildMode = \"sync\";\n    }\n}\nconst getLightQueues = () => {\n    return {\n        rgb: {\n            update: [],\n            remove: [],\n            map: new VisitedMap(),\n        },\n        sun: {\n            update: [],\n            remove: [],\n            updateMap: new VisitedMap(),\n            remvoeMap: new VisitedMap(),\n        },\n    };\n};\nconst getFlowQueues = () => {\n    return {\n        update: {\n            queue: [],\n            map: new VisitedMap(),\n        },\n        remove: {\n            queue: [],\n            map: new VisitedMap(),\n            noRemoveMap: new VisitedMap(),\n        },\n    };\n};\nconst getVoxelUpdateQueueData = () => {\n    return { ...getLightQueues(), flow: getFlowQueues() };\n};\nconst getExplosionQueuesData = () => {\n    return {\n        queue: [],\n        map: new VisitedMap(),\n        ...getLightQueues(),\n        flow: getFlowQueues(),\n    };\n};\nexport const TasksRequest = {\n    getLightUpdateRequest(origin, buildQueue = \"none\", originThread = \"self\") {\n        return new Request(\"light-update\", origin, null, buildQueue, originThread, getLightQueues());\n    },\n    getFlowUpdateRequest(origin, buildQueue = \"none\", originThread = \"self\") {\n        return new Request(\"flow-update\", origin, null, buildQueue, originThread, getVoxelUpdateQueueData());\n    },\n    getVoxelUpdateRequests(origin, buildQueue = \"none\", originThread = \"self\") {\n        return new Request(\"voxel-update\", origin, null, buildQueue, originThread, getVoxelUpdateQueueData());\n    },\n    getWorldSunRequests(origin, buildQueue = \"none\", originThread = \"self\") {\n        return new Request(\"world-sun\", origin, null, buildQueue, originThread, {\n            sun: [],\n        });\n    },\n    getExplosionRequests(origin, radius, buildQueue = \"none\", originThread = \"self\") {\n        return new Request(\"voxel-update\", origin, radius, buildQueue, originThread, getExplosionQueuesData());\n    },\n};\n","import { ThreadComm } from \"threadcomm\";\nexport const ParentComm = ThreadComm.parent;\nexport const RichWorldComm = ThreadComm.createComm(\"rich-world\");\nexport const WorldComm = ThreadComm.createComm(\"world\");\n","import { Util } from \"../../Global/Util.helper.js\";\nimport { WorldComm } from \"./ConstrcutorTheads.js\";\nexport const ConstructorThreadState = {\n    _settingsSynced: false,\n    environment: Util.getEnviorment(),\n    isReady() {\n        if (this.environment == \"node\") {\n            return WorldComm.isPortSet() && this._settingsSynced;\n        }\n        else {\n            return (WorldComm.isPortSet() &&\n                this._settingsSynced);\n        }\n    },\n};\n","import { WorldGenRegister } from \"../WorldGeneration/Register/WorldGenRegister.js\";\nimport { BrushTool } from \"../../Tools/Brush/Brush.js\";\nimport { WorldPainter } from \"../../Data/World/WorldPainter.js\";\nimport { TasksRequest } from \"../Tasks/TasksRequest.js\";\nimport { LightData } from \"../../Data/Light/LightByte.js\";\nimport { Propagation } from \"../Propagation/Propagation.js\";\nimport { WorldComm } from \"../Threads/ConstrcutorTheads.js\";\nimport { RichDataTool } from \"../../Tools/Data/RichDataTool.js\";\nimport { SunRemove, SunUpdate, } from \"../Propagation/Illumanation/Functions/SunUpdate.js\";\nexport class WorldGenBrush extends BrushTool {\n    constructor() {\n        super();\n    }\n    requestsId;\n    tasks = TasksRequest.getVoxelUpdateRequests(this.location);\n    richData = new RichDataTool();\n    paint() {\n        if (!this._dt.loadInAtLocation(this.location) && this.requestsId != \"\") {\n            WorldGenRegister.addToRequest(this.requestsId, this.location, [\n                ...this.getRaw(),\n            ]);\n            return this;\n        }\n        const sl = this._dt.getLight();\n        if (LightData.hasRGBLight(sl)) {\n            this.tasks.queues.rgb.remove.push(this.x, this.y, this.z);\n            Propagation.rgb.remove(this.tasks);\n        }\n        if (LightData.hasSunLight(sl)) {\n            this.tasks.queues.sun.remove.push(this.x, this.y, this.z);\n            SunRemove(this.tasks, false);\n        }\n        WorldPainter.paint.voxel(this.location, this.data);\n        return this;\n    }\n    erease() {\n        const sl = this._dt.getLight();\n        this._dt\n            .setAir()\n            .setLight(sl > 0 ? sl : 0)\n            .commit(2);\n        if (LightData.hasRGBLight(sl)) {\n            this.tasks.queues.rgb.remove.push(this.x, this.y, this.z);\n            Propagation.rgb.remove(this.tasks);\n        }\n        if (LightData.hasSunLight(sl)) {\n            this.tasks.queues.sun.remove.push(this.x, this.y, this.z);\n            SunRemove(this.tasks, false);\n        }\n        WorldPainter.paint.erase(this.location);\n    }\n    runUpdates() {\n        Propagation.rgb.update(this.tasks);\n        SunUpdate(this.tasks);\n        this.tasks.queues.sun.updateMap.clear();\n    }\n    worldAlloc(start, end) {\n        return new Promise((resolve) => {\n            WorldComm.runPromiseTasks(\"world-alloc\", [this.dimension, start, end], [], () => {\n                resolve(true);\n            });\n        });\n    }\n    worldDealloc(start, end) {\n        return new Promise((resolve) => {\n            WorldComm.runPromiseTasks(\"world-dealloc\", [this.dimension, start, end], [], () => {\n                resolve(true);\n            });\n        });\n    }\n}\n","import { BrushTool } from \"../../../Tools/Brush/Brush.js\";\nimport { WorldSpaces } from \"../../../Data/World/WorldSpaces.js\";\nimport { ChunkDataTool } from \"../../../Tools/Data/WorldData/ChunkDataTool.js\";\nimport { WorldComm } from \"../../Threads/ConstrcutorTheads.js\";\nconst brush = new BrushTool();\nconst dataTool = brush._dt;\nconst chunkTool = new ChunkDataTool();\nexport const WorldGenRegister = {\n    MAX_ATTEMPTS: 100,\n    _requests: new Map(),\n    registerRequest(location) {\n        const id = location.toString();\n        this._requests.set(id, {\n            attempts: 0,\n            chunks: new Map(),\n            dimension: location[0],\n            voxels: [],\n        });\n        return id;\n    },\n    addToRequest(registerId, location, rawData) {\n        const requests = this._requests.get(registerId);\n        if (!requests)\n            return;\n        const chunkPOS = WorldSpaces.chunk.getPositionLocation(location);\n        const chunkKey = WorldSpaces.chunk.getKeyLocation(location);\n        if (!chunkTool.loadInAtLocation(location)) {\n            if (!requests.chunks.has(chunkKey)) {\n                WorldComm.runTasks(\"add-chunk\", [\n                    requests.dimension,\n                    chunkPOS.x,\n                    chunkPOS.y,\n                    chunkPOS.z,\n                ]);\n                requests.chunks.set(chunkKey, [chunkPOS.x, chunkPOS.y, chunkPOS.z]);\n            }\n        }\n        const [dim, x, y, z] = location;\n        requests.voxels.push([x, y, z, rawData]);\n    },\n    attemptRequestFullFill(registerId) {\n        const requests = this._requests.get(registerId);\n        if (!requests || !requests.voxels.length)\n            return true;\n        chunkTool.setDimension(requests.dimension);\n        let done = true;\n        for (const [key, pos] of requests.chunks) {\n            if (!chunkTool.loadInAt(pos[0], pos[1], pos[2])) {\n                done = false;\n                WorldComm.runTasks(\"add-chunk\", [\n                    requests.dimension,\n                    pos[0],\n                    pos[1],\n                    pos[2],\n                ]);\n            }\n        }\n        if (!done) {\n            requests.attempts++;\n            if (requests.attempts >= this.MAX_ATTEMPTS) {\n                console.error(`World gen requests cancled after max attempts`, requests);\n                this._requests.delete(registerId);\n                return true;\n            }\n            return false;\n        }\n        brush.setDimension(requests.dimension);\n        dataTool.setDimension(requests.dimension);\n        const voxels = requests.voxels;\n        brush.start();\n        while (voxels.length) {\n            const data = voxels.shift();\n            if (!data)\n                break;\n            dataTool.loadInAt(data[0], data[1], data[2]);\n            brush.setXYZ(data[0], data[1], data[2]).setRaw(data[3]).paint();\n        }\n        brush.stop();\n        this._requests.delete(registerId);\n        return true;\n    },\n};\n","//objects\nimport { WorldBounds } from \"../../Data/World/WorldBounds.js\";\nimport { WorldGenRegister } from \"./Register/WorldGenRegister.js\";\n//tools\nimport { WorldGenBrush } from \"../Tools/WorldGenBrush.js\";\nimport { SafeInterval } from \"../../Global/Util/SafeInterval.js\";\nexport const WorldGeneration = {\n    worldGen: null,\n    register: WorldGenRegister,\n    worldBounds: WorldBounds,\n    _brushes: [],\n    setWorldGen(worldGen) {\n        this.worldGen = worldGen;\n    },\n    async generate(data, mode, onDone) {\n        if (!this.worldGen) {\n            throw new Error(`A World Generator must be set.`);\n        }\n        const requestsId = WorldGenRegister.registerRequest(data[0]);\n        for (const brush of this._brushes) {\n            brush.requestsId = requestsId;\n        }\n        if (mode == \"generate\") {\n            await this.worldGen.generate(data);\n        }\n        if (mode == \"decorate\") {\n            await this.worldGen.decorate(data);\n        }\n        const inte = new SafeInterval().setInterval(100).setOnRun(() => {\n            if (WorldGenRegister.attemptRequestFullFill(requestsId)) {\n                onDone();\n                inte.stop();\n            }\n        });\n        inte.start();\n    },\n    getBrush() {\n        const brush = new WorldGenBrush();\n        this._brushes.push(brush);\n        return brush;\n    },\n};\n","export * from \"./DivineVoxelEngineConstructor.js\";\nexport * from \"./Analyzer/Analyzer.js\";\nexport * from \"./WorldGeneration/WorldGeneration.js\";\nexport * from \"./Tools/WorldGenBrush.js\";\nexport * from \"./Builder/Types/index.js\";\nexport * from \"./Builder/Shapes/default/index.js\";\nexport * from \"./Builder/Constructors/Voxel/Classes/VoxelConstructor.js\";\n","//objects\nimport { ThreadComm } from \"threadcomm\";\nimport { WorldRegister } from \"./World/WorldRegister.js\";\nimport { DataSyncIds } from \"../Common/Threads/Contracts/DataSyncIds.js\";\nimport { VoxelPaletteReader } from \"./Voxel/VoxelPalette.js\";\nimport { DimensionsRegister } from \"./World/Dimensions/DimensionsRegister.js\";\nimport { ChunkTags } from \"./World/Chunk/ChunkTags.js\";\nimport { RegionHeaderTags, RegionTags } from \"./World/Region/RegionTags.js\";\nimport { ColumnTags } from \"./World/Column/ColumnTags.js\";\nimport { VoxelTags } from \"./Voxel/VoxelTags.js\";\nimport { MappedDataRegister } from \"./Register/MappedDataRegister.js\";\nimport { RegionHeaderRegister } from \"./World/Region/RegionHeaderRegister.js\";\nimport { SubstancePaletteReader } from \"./Substance/SubstancePalette.js\";\nimport { SubstanceTags } from \"./Substance/SubstanceTags.js\";\nexport const DataSyncNode = {\n    maps: {\n        strings: ThreadComm.onDataSync(DataSyncIds.registerStringMap, (data) => {\n            MappedDataRegister.stringMaps.sync(data);\n        }),\n        objects: ThreadComm.onDataSync(DataSyncIds.registerObjectMap, (data) => {\n            MappedDataRegister.objectMaps.sync(data);\n        }),\n    },\n    palettes: {\n        voxel: ThreadComm.onDataSync(DataSyncIds.voxelPalette, ([palette, map]) => {\n            VoxelPaletteReader.setVoxelPalette(palette, map);\n        }),\n        substance: ThreadComm.onDataSync(DataSyncIds.substancePalette, ([palette, map]) => {\n            SubstancePaletteReader.setPalette(palette, map);\n        }),\n    },\n    worldData: {\n        dimension: ThreadComm.onDataSync(DataSyncIds.dimesnion, (data) => {\n            DimensionsRegister.registerDimension(data.id, data.options);\n        }),\n        chunk: ThreadComm.onDataSync(DataSyncIds.chunk, (data) => {\n            WorldRegister.chunk.add(data[0], data[1]);\n        }, (data) => {\n            WorldRegister.chunk.remove(data);\n        }),\n        column: ThreadComm.onDataSync(DataSyncIds.column, (data) => {\n            WorldRegister.column.add(data[0], data[1]);\n        }, (data) => {\n            WorldRegister.column.remove(data);\n        }),\n        region: ThreadComm.onDataSync(DataSyncIds.region, (data) => {\n            WorldRegister.region.add(data[0], data[1]);\n        }, (data) => {\n            WorldRegister.region.remove(data);\n        }),\n        regionHeader: ThreadComm.onDataSync(DataSyncIds.regionHeader, (data) => {\n            RegionHeaderRegister.add(data[0], data[1]);\n        }, (data) => {\n            RegionHeaderRegister.remove(data);\n        }),\n    },\n    tags: {\n        voxel: ThreadComm.onDataSync(DataSyncIds.voxelTags, (data) => {\n            VoxelTags.$INIT(data[0]);\n            VoxelTags.sync(new Uint16Array(data[1]));\n        }),\n        substance: ThreadComm.onDataSync(DataSyncIds.substanceTags, (data) => {\n            SubstanceTags.$INIT(data);\n        }),\n        chunk: ThreadComm.onDataSync(DataSyncIds.chunkTags, (data) => {\n            ChunkTags.$INIT(data);\n        }),\n        column: ThreadComm.onDataSync(DataSyncIds.columnTags, (data) => {\n            ColumnTags.$INIT(data);\n        }),\n        region: ThreadComm.onDataSync(DataSyncIds.regionTags, (data) => {\n            RegionTags.$INIT(data[0]);\n            RegionHeaderTags.$INIT(data[1]);\n        }),\n    },\n};\n","export const StairStates = {\n    normal: {\n        bottom: {\n            north: 0,\n            south: 1,\n            east: 2,\n            west: 3,\n        },\n        top: {\n            north: 4,\n            south: 5,\n            east: 6,\n            west: 7,\n        },\n    },\n    connected: {\n        bottom: {\n            northEast: 8,\n            northWest: 9,\n            southEast: 10,\n            southWest: 11,\n        },\n        top: {\n            northEast: 12,\n            northWest: 13,\n            southEast: 14,\n            southWest: 15,\n        },\n    },\n};\n","export class UtilMap {\n    _map = new Map();\n    constructor(data) {\n        if (data)\n            this.add(data);\n    }\n    set(id, value) {\n        this._map.set(id, value);\n    }\n    get(id) {\n        if (!this._map.has(id))\n            return undefined;\n        return this._map.get(id);\n    }\n    add(data) {\n        data.forEach(([id, value]) => this._map.set(id, value));\n    }\n    has(id) {\n        return this._map.has(id);\n    }\n    remove(id) {\n        this._map.delete(id);\n    }\n}\n","export class VisitedMap {\n    _map = new Map();\n    get size() {\n        return this._map.size;\n    }\n    _getKey(x, y, z) {\n        return `${x}_${y}_${z}`;\n    }\n    inMap(x, y, z) {\n        return this._map.has(this._getKey(x, y, z));\n    }\n    add(x, y, z) {\n        this._map.set(this._getKey(x, y, z), true);\n    }\n    remove(x, y, z) {\n        this._map.delete(this._getKey(x, y, z));\n    }\n    removeDiffernce(map) {\n        for (const [key] of map._map) {\n            if (this._map.has(key)) {\n                this._map.delete(key);\n            }\n        }\n        return map;\n    }\n    clear() {\n        this._map.clear();\n    }\n}\n","export const FaceMap = [\n    \"top\",\n    \"bottom\",\n    \"east\",\n    \"west\",\n    \"south\",\n    \"north\",\n];\nexport const FaceRecord = {\n    top: 0,\n    bottom: 1,\n    east: 2,\n    west: 3,\n    south: 4,\n    north: 5,\n};\nexport const FaceNormals = {\n    top: [0, 1, 0],\n    bottom: [0, -1, 0],\n    east: [1, 0, 0],\n    west: [-1, 0, 0],\n    north: [0, 0, 1],\n    south: [0, 0, -1],\n    \"north-east\": [1, 0, 1],\n    \"north-west\": [-1, 0, 1],\n    \"south-east\": [1, 0, -1],\n    \"south-west\": [-1, 0, -1],\n};\n","import { DataTool } from \"../../Tools/Data/DataTool.js\";\nimport { WorldPainter } from \"../../Data/World/WorldPainter.js\";\nimport { WorldRegister } from \"../../Data/World/WorldRegister.js\";\nimport { VoxelPaletteReader } from \"../../Data/Voxel/VoxelPalette.js\";\nimport { LocationBoundTool } from \"../Classes/LocationBoundTool.js\";\nexport class BrushTool extends LocationBoundTool {\n    data = {\n        id: \"dve_air\",\n        state: 0,\n        shapeState: 0,\n        secondaryState: 0,\n        secondaryVoxelId: \"dve_air\",\n        level: 0,\n        levelState: 0,\n    };\n    _update = true;\n    _dt = new DataTool();\n    setData(data) {\n        for (const key in data) {\n            if (typeof data[key] !== undefined) {\n                this.data[key] = data[key];\n            }\n        }\n        return this;\n    }\n    setId(id, state = 0, shapeState = 0) {\n        this.data.id = id;\n        this.data.state = state;\n        this.data.shapeState = shapeState;\n        return this;\n    }\n    setDimension(dimensionId) {\n        this.location[0] = dimensionId;\n        this._dt.setDimension(dimensionId);\n        return this;\n    }\n    setSecondaryId(id, state = 0) {\n        this.data.secondaryVoxelId = id;\n        this.data.secondaryState = state;\n        return this;\n    }\n    setState(state) {\n        this.data.state = state;\n        return this;\n    }\n    setShapeState(state) {\n        this.data.shapeState = state;\n        return this;\n    }\n    setLevel(level) {\n        this.data.level = level;\n        return this;\n    }\n    setLevelState(levelState) {\n        this.data.levelState = levelState;\n        return this;\n    }\n    clear() {\n        this.data.id = \"dve_air\";\n        this.data.secondaryVoxelId = \"dve_air\";\n        this.data.level = 0;\n        this.data.levelState = 0;\n        this.data.state = 0;\n        this.data.secondaryState = 0;\n        this.data.shapeState = 0;\n        this.location[1] = 0;\n        this.location[2] = 0;\n        this.location[3] = 0;\n    }\n    setRaw(data) {\n        this._dt.loadInRaw(data);\n        this.data.id = this._dt.getStringId();\n        this.data.shapeState = this._dt.getShapeState();\n        this.data.state = this._dt.getState();\n        this._dt.setSecondary(true);\n        if (this._dt.data.secondaryId >= 2) {\n            this.data.secondaryVoxelId = this._dt.getStringId();\n            this.data.secondaryState = this._dt.getState();\n        }\n        this._dt.setSecondary(false);\n        return this;\n    }\n    getRaw() {\n        this._dt.setId(VoxelPaletteReader.id.getPaletteId(this.data.id, this.data.state));\n        this._dt\n            .setSecondary(true)\n            .setId(VoxelPaletteReader.id.getPaletteId(this.data.secondaryVoxelId, this.data.secondaryState))\n            .setSecondary(false);\n        this._dt.setLevel(this.data.level);\n        this._dt.setLevelState(this.data.levelState);\n        this._dt.setShapeState(this.data.shapeState);\n        this._dt.data.raw[3] == -1 ? (this._dt.data.raw[3] = 0) : false;\n        return this._dt.data.raw;\n    }\n    getData() {\n        return this.data;\n    }\n    paint() {\n        WorldPainter.paint.voxel(this.location, this.data, this._update);\n        return this;\n    }\n    erase() {\n        WorldPainter.paint.erase(this.location);\n        return this;\n    }\n    start() {\n        WorldRegister.cache.enable();\n        return this;\n    }\n    stop() {\n        WorldRegister.cache.disable();\n        return this;\n    }\n}\n","export class VoxelShaderDataTool {\n    _v = 0;\n    _lightMask = 0xffff;\n    _aoMask = 0b11;\n    _animationMask = 0b1111_1111_1111_11;\n    _setLight(index, value) {\n        return ((this._v & ~(this._lightMask << index)) |\n            ((value & this._lightMask) << index));\n    }\n    _setAO(value) {\n        const index = 16;\n        return ((this._v & ~(this._aoMask << index)) | ((value & this._aoMask) << index));\n    }\n    _setAnimation(value) {\n        const index = 18;\n        return ((this._v & ~(this._animationMask << index)) |\n            ((value & this._animationMask) << index));\n    }\n    setLight(values) {\n        this._v = 0;\n        this._v = this._setLight(0, values);\n        return this;\n    }\n    setAO(value) {\n        this._v = this._setAO(value);\n        return this;\n    }\n    setAnimation(value) {\n        this._v = this._setAnimation(value);\n        return this;\n    }\n    getValue() {\n        return this._v;\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"DSLIBS_divineBinaryObject_dist_index_js-DSLIBS_divineVoxelEngine_dist_Common_Threads_Contract-5324f4\",\"DSLIBS_divineVoxelEngine_dist_Math_index_js-DSLIBS_divineVoxelEngine_dist_Tools_Data_RichData-f07748\"], () => (__webpack_require__(\"./compiled/client/Constructor/constructor.js\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && !queue.d) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = 1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && (queue.d = 0);\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".DVE.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"compiled_client_Constructor_constructor_js\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdve_testing\"] = self[\"webpackChunkdve_testing\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(\"DSLIBS_divineBinaryObject_dist_index_js-DSLIBS_divineVoxelEngine_dist_Common_Threads_Contract-5324f4\"),\n\t\t__webpack_require__.e(\"DSLIBS_divineVoxelEngine_dist_Math_index_js-DSLIBS_divineVoxelEngine_dist_Tools_Data_RichData-f07748\")\n\t]).then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":[],"sourceRoot":""}