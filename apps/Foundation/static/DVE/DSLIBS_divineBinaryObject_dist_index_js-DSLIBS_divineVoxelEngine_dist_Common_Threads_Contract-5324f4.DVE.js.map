{"version":3,"file":"DSLIBS_divineBinaryObject_dist_index_js-DSLIBS_divineVoxelEngine_dist_Common_Threads_Contract-5324f4.DVE.js","mappings":";;;;;;;;;;;;;;AAA2D;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACO;AACA;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzCuE;AACvE,WAAW,UAAU;AACoD;AACrB;AACO;AACpD;AACP;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAS,CAAC,gEAAU,eAAe,gEAAU;AAChE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA;AACA,2BAA2B,sEAAkB;AAC7C,qBAAqB,qEAAS;AAC9B,gCAAgC,qBAAqB,sEAAU,EAAE;AACjE,yDAAyD,uEAAmB;AAC5E;AACA,oCAAoC,sEAAU;AAC9C,SAAS;AACT,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,oEAAQ;AACvC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA,0BAA0B,qEAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,oEAAQ;AACvC,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS;AACxC,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS;AACxC,SAAS;AACT;AACA,0BAA0B,uEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,sEAAU;AACzC,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS;AACxC,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS;AACxC,SAAS;AACT;AACA,0BAA0B,uEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS,GAAG,sEAAU;AACrD,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS;AACxC,SAAS;AACT;AACA,0BAA0B,oEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,mEAAU;AACzC,SAAS;AACT;AACA,0BAA0B,qEAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,oEAAW;AAC1C,SAAS;AACT,+CAA+C;AAC/C,0CAA0C;AAC1C;AACA,yBAAyB,uEAAmB;AAC5C,qBAAqB,sEAAU,GAAG,qEAAS;AAC3C;AACA,4BAA4B,UAAU;AACtC;AACA,mCAAmC,uEAAmB;AACtD,yBAAyB,sEAAU;AACnC,gCAAgC,gBAAgB;AAChD,kDAAkD,uEAAmB;AACrE,6BAA6B,sEAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,uEAAmB;AAC9C,qBAAqB,qEAAS,GAAG,qEAAS;AAC1C;AACA,gCAAgC,qBAAqB,sEAAU,EAAE;AACjE,8CAA8C,uEAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sEAAU;AAC9C,SAAS;AACT;AACA,yBAAyB,mEAAa,CAAC,sEAAkB;AACzD,2BAA2B,uEAAmB;AAC9C,qBAAqB,qEAAS,OAAO,sEAAU;AAC/C;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAAe;AACvC;AACA,yBAAyB,+DAAW;AACpC,4BAA4B,YAAY;AACxC;AACA,yBAAyB,8DAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,uEAAmB;AAC9C,qBAAqB,qEAAS,GAAG,qEAAS;AAC1C;AACA,gCAAgC,qBAAqB,sEAAU,EAAE;AACjE,kDAAkD,uEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sEAAU;AAC9C,SAAS;AACT,+BAA+B;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AChWwD;AACF;AAC/C;AACP;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,uEAAmB,QAAQ,gEAAU;AAC7C,KAAK;AACL;AACA,QAAQ,uEAAmB;AAC3B,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC1I4D;AACR;AACd;AACS;AACxC;AACP;AACA;AACA,qBAAqB,qDAAU,GAAG;AAClC;AACA;AACA;AACA,iCAAiC,4DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,oDAAS;AAC9B;AACA,iCAAiC,4DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,qDAAU;AAC7B;AACA;AACA,mBAAmB,mDAAQ;AAC3B;AACA;AACA,mBAAmB,sDAAW;AAC9B;AACA;AACA,mBAAmB,wDAAa;AAChC;AACA;AACA;AACA,gBAAgB,wEAAoB;AACpC,uBAAuB,yDAAc;AACrC;AACA,gBAAgB,wEAAoB;AACpC;AACA;AACA;AACA;AACA,4BAA4B,4DAAS;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B,qDAAU,GAAG;AACxC;AACA;AACA;AACA;AACA,2BAA2B,oDAAS;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,iEAAoB;AACnC,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACnGqC;AACc;AACM;AACN;AAC5C;AACP,WAAW,8CAAG;AACd;AACA,eAAe,qEAAoB;AACnC,KAAK;AACL;AACA,eAAe,2EAAuB;AACtC,KAAK;AACL;AACA,eAAe,wEAAoB;AACnC,KAAK;AACL;AACA,eAAe,qEAAoB;AACnC,KAAK;AACL;AACA,eAAe,kEAAiB;AAChC,KAAK;AACL;;;;;;;;;;;;;;;;;;ACrBmD;AACI;AACC;AACjD;AACP;AACA,mBAAmB,4DAAS,CAAC,qEAAkB;AAC/C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,oEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAoB;AACjD,KAAK;AACL;AACA;AACA;AACA,mBAAmB,4DAAS,CAAC,sEAAmB;AAChD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,sEAAgB;AAC7C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,wEAAkB;AAC/C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,wEAAkB;AAC/C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,qEAAkB;AAC/C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,sEAAmB;AAChD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,wEAAqB;AAClD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,0EAAuB;AACpD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,+EAAyB;AACtD;AACA,4CAA4C,iEAAa,oBAAoB,gEAAU;AACvF,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,gFAA0B;AACvD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAoB;AACjD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,gFAA0B;AACvD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,qFAA+B,SAAS,gEAAU;AAC/E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,MAAM;AAChC,wBAAwB,QAAQ;AAChC;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACvF+B;AACQ;AACC;;;;;;;;;;;;;;;;ACFmB;AAC3D;AACA;AACA;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,kEAAoB;AAChD,4BAA4B,iEAAmB;AAC/C,mBAAmB,iEAAmB;AACtC;AACA,4BAA4B,sEAAwB;AACpD,mBAAmB,oEAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,kEAAoB;AAChD,4BAA4B,iEAAmB;AAC/C,+DAA+D,iEAAmB;AAClF;AACA;AACA,4BAA4B,sEAAwB;AACpD,YAAY,oEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,2EAA6B;AACzD,mBAAmB,oEAAsB;AACzC;AACA,wBAAwB,4EAA8B;AACtD;AACA,4BAA4B,mEAAqB;AACjD,mBAAmB,sEAAwB;AAC3C;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,2EAA6B;AACzD;AACA;AACA,wBAAwB,4EAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,4BAA4B,2EAA6B;AACzD,mBAAmB,oEAAsB;AACzC;AACA,wBAAwB,4EAA8B;AACtD;AACA,4BAA4B,mEAAqB;AACjD,mBAAmB,sEAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;;AC9IyD;AACZ;AACtC;AACP;AACA,mBAAmB,sDAAU;AAC7B,KAAK;AACL;AACA,mBAAmB,kEAAgB;AACnC,KAAK;AACL;;;;;;;;;;;;;;;;ACT6D;AACtD,+BAA+B,sEAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChB4E;AACf;AAC7D,qBAAqB,kEAAoB,WAAW,kEAAoB;AACxE;AACA;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA,wBAAwB,kEAAoB;AAC5C;AACA;AACO,yBAAyB,sEAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAoB;AACjD,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uFAAuF,8DAAgB,kBAAkB,sEAAwB;AACjJ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,mGAAmG,kEAAoB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uGAAuG,iEAAmB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAoB;AACjD,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uFAAuF,8DAAgB,kBAAkB,sEAAwB;AACjJ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAoB;AACjD,4BAA4B,iBAAiB;AAC7C;AACA;AACA,uFAAuF,8DAAgB,kBAAkB,2EAA6B;AACtJ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6FAA6F,mEAAqB;AAClH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9LU;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;ACAH;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnGsC;AACA;AACN;AACY;AACD;AACL;AACJ;;;;;;;;;;;;;;;ACN3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZmD;AACF;AAC1C;AACP;AACA,mBAAmB,4DAAS;AAC5B,KAAK;AACL;AACA,mBAAmB,0DAAQ;AAC3B,KAAK;AACL;;;;;;;;;;;;;;;;ACT2B;;;;;;;;;;;;;;;ACApB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACTO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPqC;AAC9B;AACP;AACA,6BAA6B,2DAAiB;AAC9C,KAAK;AACL;AACA,oBAAoB,4DAAkB;AACtC,mBAAmB,2DAAiB;AACpC,eAAe,4DAAkB;AACjC,kBAAkB,2DAAiB;AACnC,KAAK;AACL;AACA,oBAAoB,4DAAkB;AACtC,mBAAmB,2DAAiB;AACpC,eAAe,4DAAkB;AACjC,kBAAkB,2DAAiB;AACnC,KAAK;AACL;AACA,oBAAoB,4DAAkB;AACtC,mBAAmB,2DAAiB;AACpC,eAAe,4DAAkB;AACjC,kBAAkB,2DAAiB;AACnC,KAAK;AACL;AACA,0BAA0B,2DAAiB;AAC3C,0BAA0B,2DAAiB;AAC3C,KAAK;AACL,oBAAoB,2DAAiB;AACrC;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5B8E;AACR;AACrB;AACI;AACE;AACE;AACF;AACG;AACA;AACL;AACyB;AACjB;AACtD;AACP,WAAW,gEAAY;AACvB,iBAAiB,8DAAW;AAC5B,YAAY,8DAAW;AACvB;AACA,oBAAoB,uFAAkB;AACtC,eAAe,kEAAa;AAC5B,gBAAgB,+EAAkB;AAClC,sBAAsB,wFAAoB;AAC1C,KAAK;AACL;AACA,gBAAgB,0DAAS;AACzB,oBAAoB,uEAAa;AACjC,gBAAgB,gEAAS;AACzB,gBAAgB,mEAAU;AAC1B,gBAAgB,mEAAU;AAC1B,KAAK;AACL;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACjXO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClDmD;AACG;AACA;AACtD;AACA;AACA;AACA;AACO;AACP,gBAAgB,sEAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,oEAAiB;AACzB;AACA,YAAY,6EAA0B;AACtC;AACA,KAAK;AACL,wCAAwC;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;AClKO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;ACfsD;AACS;AAC/D,qBAAqB,gEAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4FAA0C;AAC3F;AACA;AACO;;;;;;;;;;;;;;;ACZA;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY,2CAA2C,QAAQ;AAClG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC5BsD;AACtD,qBAAqB,gEAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;AChB+C;AAC/C,sBAAsB,gEAAgB;;;;;;;;;;;;;;;;ACDS;AAC/C,uBAAuB,gEAAgB;;;;;;;;;;;;;;;;;ACDC;AACK;AAC7C;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sFAA2C;AACnD,QAAQ,2EAA4B;AACpC,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC9CgD;AACG;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAA4B;AACtD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAA4B;AACtD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAA4B;AACzD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAA0B;AAClC,4BAA4B,2EAA8B;AAC1D,eAAe,6EAAiC;AAChD;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACrDsD;AAC/C,uBAAuB,gEAAgB;AACvC,6BAA6B,gEAAgB;;;;;;;;;;;;;;;ACF7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACjBmD;AACP;AACkB;AACN;AACxD;AACA;AACA;AACA,iBAAiB,6DAAQ;AACzB;AACA;AACA;AACA;AACA,wBAAwB,sEAAuB;AAC/C;AACA,6BAA6B,wEAA6B;AAC1D;AACA;AACA,wBAAwB,sEAAuB;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,sFAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sFAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAoC;AACxD;AACA;AACA;AACA,gBAAgB,+EAAoC;AACpD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;;;;;;;;;;;;;;;;;;;;;;ACpE6C;AACL;AACyB;AACI;AACE;AACA;AAC/B;AAC/C,sBAAsB,iFAAa;AACnC,uBAAuB,mFAAc;AACrC,uBAAuB,mFAAc;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,iBAAiB,sGAAuC;AACxD;AACA;AACA,SAAS;AACT;AACA,iBAAiB,sGAAuC;AACxD;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mFAAsC;AACpE;AACA;AACA;AACA,0BAA0B,sEAAyB;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yCAAyC,8EAAiC;AAC1E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,8EAAiC;AACzD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,6BAA6B,8EAA8B;AAC3D;AACA;AACA;AACA,gBAAgB,0EAA0B;AAC1C;AACA;AACA,8BAA8B,mFAAsC;AACpE;AACA;AACA;AACA,+BAA+B,wEAA2B;AAC1D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8BAA8B,8EAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gFAAmC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,gFAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,oEAAuB,EAAE,KAAK,oEAAuB,EAAE,MAAM,wEAA2B;AAClH;AACA;AACA,kCAAkC,6EAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW;AACX,KAAK;AACL;AACA;AACA;AACA;AACA,6BAA6B,8EAA8B;AAC3D;AACA;AACA;AACA,gBAAgB,0EAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA,6BAA6B,kFAAqC;AAClE;AACA;AACA,8BAA8B,uEAA0B;AACxD,YAAY,yEAAyB;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+EAAkC;AAChE,YAAY,yEAAyB;AACrC;AACA,SAAS;AACT;AACA,6BAA6B,6EAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uEAA0B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,+EAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;AC/QA;AAC0C;AAC1C;AACmD;AAC5C,oBAAoB,8DAAU,CAAC,mEAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL,CAAC;;;;;;;;;;;;;;;;;ACxBiE;AAC1B;AACjC;AACP,wBAAwB,2EAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,iDAAK;AACxB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACtCiD;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtCO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxBmD;AACoC;AAC5B;AACoB;AACxE,2BAA2B,oEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2CAA2C,8FAAyB;AACpE,2CAA2C,8FAAyB;AACpE,2CAA2C,8FAAyB;AACpE;AACA;AACA;AACA,yBAAyB,8FAAyB;AAClD,yBAAyB,8FAAyB;AAClD,yBAAyB,8FAAyB;AAClD;AACA;AACA;AACA,yBAAyB,gGAA2B,EAAE,kHAAwC;AAC9F;AACA;AACA,eAAe,iHAAuC,kBAAkB,gGAA2B;AACnG;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrFO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDuF;AACzB;AACJ;AACY;AACT;AACA;AACH;AACI;AACC;AACL;AACa;AACQ;AACpB;AAC3D,uBAAuB,kEAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAa;AAClC,yBAAyB,qEAAiB;AAC1C,gCAAgC,sEAAa;AAC7C,6BAA6B,wEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iHAAuC;AAClE;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAkB;AAC9B;AACA;AACA,YAAY,wEAAkB;AAC9B;AACA;AACA;AACA;AACA,eAAe,0FAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0FAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0FAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAqB;AACpC;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAqB;AACpC;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA,4CAA4C,wFAAsB;AAClE;AACA,iCAAiC,2FAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAoB;AACnC;AACA;AACA,2BAA2B,4EAAoB;AAC/C;AACA;AACA;AACA,eAAe,iFAAyB;AACxC;AACA;AACA,2BAA2B,iFAAyB;AACpD;AACA;AACA;AACA,eAAe,iFAAyB;AACxC;AACA;AACA,2BAA2B,iFAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,oGAAiC,UAAU,qFAAmB,EAAE,sEAAgB,CAAC,qFAAmB;AACnH;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,2FAAyB;AACzD;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,wFAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,mBAAmB,oGAAiC,UAAU,uFAAqB,EAAE,sEAAgB,CAAC,uFAAqB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,oGAAiC,UAAU,sFAAoB,EAAE,sEAAgB,CAAC,sFAAoB;AACrH;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,sFAAoB;AACpD;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,oGAAiC,UAAU,wFAAsB,EAAE,sEAAgB,CAAC,wFAAsB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,gCAAgC,6FAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B,eAAe,sEAAgB,CAAC,2FAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+FAAsC;AAChE;AACA;AACA;AACA,mBAAmB,+FAAsC;AACzD;AACA,eAAe,+FAAsC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;;;;;;;ACzX2D;AACG;AACZ;AACS;AAC/E;AACA,kBAAkB,2EAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2GAA0C;AACtD;AACA;AACA,sEAAsE,4FAAuB;AAC7F;AACA;AACA,sEAAsE,6FAAwB;AAC9F;AACA;AACA,eAAe,mGAAiC,cAAc,2FAAsB,wDAAwD,2FAAsB;AAClK;AACA;AACA,eAAe,mGAAiC,cAAc,6FAAwB,wDAAwD,6FAAwB;AACtK;AACA;AACA,eAAe,mGAAiC,cAAc,qGAAgC,wDAAwD,qGAAgC;AACtL;AACA;AACA,qEAAqE,6FAAwB;AAC7F;AACA;AAC6B;;;;;;;;;;;;;;;;;;;;ACpC7B;AACqE;AACF;AACK;AACE;AACT;AAC1D,4BAA4B,6EAAuB;AAC1D,WAAW,qEAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wFAAgC;AACxC,sBAAsB,iFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,gDAAgD,2FAA0B;AAC1E,aAAa;AACb;AACA,gDAAgD,2FAA0B;AAC1E,aAAa;AACb,SAAS;AACT;AACA,kBAAkB;AAClB;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb,SAAS;AACT;AACA,kBAAkB;AAClB;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb;AACA,gDAAgD,8FAA6B;AAC7E,aAAa;AACb,SAAS;AACT;AACA,kBAAkB;AAClB;AACA,gDAAgD,oGAAmC;AACnF,aAAa;AACb;AACA,gDAAgD,oGAAmC;AACnF,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;ACnEA;AACqE;AACG;AACF;AACH;AAC5D,6BAA6B,6EAAuB;AAC3D,WAAW,wEAAU;AACrB;AACA;AACA,uBAAuB,kFAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAkB,GAAG,6EAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/EA;AACqE;AACJ;AACA;AACjE;AACgF;AAC7B;AACnD;AAC0E;AACU;AACpF,4BAA4B,kFAAiB;AAC7C,4BAA4B,4DAAa;AACzC;AACA;AACA;AACA;AACA,0BAA0B,iFAAuB;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,iFAAuB;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,gFAAwB;AACpC,sBAAsB,qFAA6B;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,mFAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8DAA8D,sFAAqB;AACnF;AACA,SAAS;AACT;AACA;AACA,8DAA8D,qFAAoB;AAClF;AACA,SAAS;AACT;AACA;AACA,6DAA6D,sFAAqB;AAClF,SAAS;AACT;AACA;AACA,6DAA6D,qFAAoB;AACjF,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,mFAA2B;AAC1D,+BAA+B,mFAA2B;AAC1D;AACA;AACA,gCAAgC,sFAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,kFAAwB;AACnD;AACA,uBAAuB,+EAAuB;AAC9C;AACA,uBAAuB,+EAAuB;AAC9C,4BAA4B,+EAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACyB;;;;;;;;;;;;;;;;;;ACjHzB;AACqE;AACG;AACF;AAC/D,6BAA6B,6EAAuB;AAC3D,WAAW,wEAAU;AACrB;AACA;AACA,uBAAuB,kFAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpC8C;AACiC;AACvB;AACK;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4EAAyB;AAClD,YAAY,6EAA0B;AACtC,YAAY,iEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gFAAwB;AACpC,mBAAmB,iFAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wCAAwC,UAAU,IAAI,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iFAA8B;AAC5E,mCAAmC,iFAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8EAA2B,OAAO,iEAAqB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,6BAA6B,UAAU,GAAG,GAAG,GAAG,WAAW;AAC3D,mCAAmC,gFAA6B;AAChE;AACA,YAAY,iEAAqB;AACjC;AACA;AACA,QAAQ,gFAA4B;AACpC;AACA,SAAS;AACT;AACA;AACA,2BAA2B,wEAA4B;AACvD,QAAQ,gFAA4B;AACpC,mCAAmC,8EAA2B,OAAO,iEAAqB;AAC1F;AACA;AACA,yBAAyB,4EAAyB;AAClD;AACA;AACA,yBAAyB,4EAAyB;AAClD,YAAY,+EAA4B;AACxC,YAAY,iEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA,yBAAyB,4EAAyB;AAClD,YAAY,iFAA8B;AAC1C,YAAY,iEAAqB;AACjC;AACA;AACA;AACA;AACA,mCAAmC,8EAA2B;AAC9D;AACA;AACA,mCAAmC,gFAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnLO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpByC;AAClC;AACP;AACA;AACA,yBAAyB,kDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpBqE;AACvB;AACU;AACF;AACC;AACM;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,mEAAyB,EAAE,wEAA8B;AACrF;AACA;AACA;AACA,QAAQ,kEAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAkB;AACvC;AACA;AACA;AACA,qBAAqB,qEAAyB;AAC9C;AACA;AACA,CAAC;AACD,4BAA4B,mEAAyB,EAAE,oEAA0B;AACjF;AACA,iBAAiB,8DAAkB;AACnC;AACA;AACA;AACA,CAAC;AACD,4BAA4B,mEAAyB,EAAE,uEAA6B;AACpF;AACA;AACA,IAAI,iEAAqB;AACzB,IAAI,mEAAuB;AAC3B,CAAC;AACD,4BAA4B,mEAAyB,EAAE,sEAA4B;AACnF;AACA;AACA;AACA,SAAS,kEAAsB;AAC/B,QAAQ,kEAAsB;AAC9B;AACA;AACA,IAAI,kEACQ;AACZ,0BAA0B,8DAAW;AACrC,CAAC;AACD,4BAA4B,mEAAyB,EAAE,wEAA8B;AACrF;AACA;AACA,SAAS,kEAAsB;AAC/B;AACA;AACA;AACA,IAAI,kEAAsB;AAC1B,CAAC;AACD,4BAA4B,mEAAyB,EAAE,0EAAgC;AACvF;AACA;AACA;AACA,IAAI,qFAAiC;AACrC,CAAC;AACD,4BAA4B,mEAAyB,EAAE,6EAAmC;AAC1F;AACA;AACA,IAAI,qFAAiC;AACrC,CAAC;AACD;AACA;AACA,qBAAqB,8DAAkB;AACvC,yBAAyB,mEAAyB,GAAG,0EAAgC;AACrF;AACA;AACA;AACA;AACA,0BAA0B,qEAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAyB,EAAE,qEAA2B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD,4BAA4B,mEAAyB,EAAE,uEAA6B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAkB;AACrC,kBAAkB,wEAAqB;AACvC;AACA;AACA;AACA,2BAA2B,mEAAyB;AACpD,YAAY,6EAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAyB;AACpD,YAAY,6EAAmC;AAC/C;AACA;AACA;AACA;AACA,CAAC;AACD,4BAA4B,mEAAyB,EAAE,qEAA2B;AAClF;AACA;AACA,qBAAqB,iFAA2B;AAChD;AACA;AACA;AACA;AACA,CAAC;AACD,4BAA4B,mEAAyB,EAAE,uEAA6B;AACpF;AACA;AACA,qBAAqB,iFAA2B;AAChD;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;AC3LM;AACP;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrBA;AAC+E;AAC/E;AAC2C;AACa;AACV;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iBAAiB,IAAI,QAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,+BAA+B,iBAAiB,GAAG,iBAAiB;AACpE,4BAA4B,mDAAQ;AACpC,QAAQ,8DAAkB;AAC1B;AACA;AACA;AACA,4BAA4B,4EAAyB;AACrD,YAAY,gFAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH;AACpH;AACA,4CAA4C,IAAI;AAChD;AACA,6BAA6B,gEAAY;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5KU;;;;;;;;;;;;;;;;ACAgC;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAK;AAC5B,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ,GAAG,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3HO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACpCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACpBkC;AAC3B;AACP;AACA;AACA,0BAA0B,2CAAI;AAC9B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACTA;AACuD;AACb;AACY;AACM;AACA;AACrD;AACP;AACA;AACA;AACA,cAAc;AACd,sBAAsB;AACtB;AACA,gBAAgB,mDAAQ;AACxB,cAAc,qEAAa;AAC3B;AACA,uBAAuB;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,qCAAqC;AACrC,yCAAyC,mDAAQ;AACjD;AACA;AACA,KAAK;AACL;AACA,mCAAmC,gEAAW;AAC9C;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA,KAAK;AACL;AACA,QAAQ,6EAA0B;AAClC,KAAK;AACL;AACA,eAAe,sFAAgC;AAC/C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AChFgC;AACD;AACI;AACM;AACR;AACS;;;;;;;;;;;;;;;ACL1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,GAAG,OAAO,GAAG,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB,GAAG,iBAAiB,GAAG,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;;;;;;;;;;;;ACnLZ;;;;;;;;;;;;;;;;ACA2C;AACrD;AACA;AACA;AACO;AACP,wBAAwB,8DAAU;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,sCAAsC,8DAAU;AAChD;AACA,uBAAuB,6EAAyB;AAChD,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT,2BAA2B,kBAAkB;AAC7C,4BAA4B,kBAAkB;AAC9C;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT,gCAAgC,8DAAU;AAC1C;AACA,uBAAuB,6EAAyB;AAChD,aAAa;AACb;AACA,uBAAuB,uEAAmB,CAAC,0EAAsB;AACjE,aAAa;AACb;AACA,uBAAuB,mFAA+B;AACtD,aAAa;AACb,SAAS;AACT,qCAAqC,8DAAU;AAC/C;AACA,uBAAuB,6EAAyB;AAChD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,mFAA+B;AACtD,aAAa;AACb,SAAS;AACT,+BAA+B,kBAAkB;AACjD;AACA;AACA,uBAAuB,0EAAsB;AAC7C,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,uBAAuB,uEAAmB;AAC1C,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,+BAA+B,8DAAU;AACzC;AACA,gBAAgB,0EAAsB;AACtC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,uEAAmB;AAC1C,aAAa;AACb;AACA,uBAAuB,mFAA+B;AACtD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,0BAA0B,8DAAU;AACpC;AACA,gBAAgB,0EAAsB;AACtC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,uEAAmB;AAC1C,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC1IiC;AACY","sources":["webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/Classes/TypedNode.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/Constants/ByteData.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/Constants/MetaValues.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/DBO/BufferToDBO.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/DBO/DBOToBuffer.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/DBO/ObjectToBuffer.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/DivineBinaryObject.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/NodeMaker.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/index.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Classes/TagManagerBase.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/DivineBinaryTags.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/RemoteTagManager.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/TagManager.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Types/DBTSchema.types.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Types/Util.types.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/Util/DBTUtil.js","webpack://dve-testing/../../DSLIBS/divineBinaryTags/dist/index.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/Classes/AsyncHook.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/Classes/SyncHook.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/Hooks.js","webpack://dve-testing/../../DSLIBS/divineHooks/dist/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Common/Threads/Contracts/DataSyncIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Tags/ChunkTagIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Tags/SubstanceTagIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Tags/VoxelTagIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Tags/WorldDataTagIds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataHooks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Light/LightByte.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Register/MappedDataRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Settings/EngineSettings.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Substance/SubstancePalette.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Substance/SubstanceTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Voxel/VoxelPalette.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Voxel/VoxelReader.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Voxel/VoxelTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Chunk/ChunkTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Column/ColumnTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Dimensions/DimensionsRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Region/RegionHeaderRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/Region/RegionTags.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/WorldBounds.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/WorldPainter.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/WorldRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/World/WorldSpaces.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Global/Util.helper.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Global/Util/CreatePromiseCheck.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Global/Util/Queue.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Global/Util/SafeInterval.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Math/Constants/CardinalNeighbors.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Classes/DataToolBase.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Classes/LocationBoundTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/DataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/SubstanceDataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/ChunkDataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/ColumnDataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/HeightMapTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Data/WorldData/RegionDataTool.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Comm/Comm.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Data/DataSync.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Data/DataSyncManager.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Internal/InternalTasks.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Internal/Messages.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Manager/CommManager.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Meta/Comm/Comm.types.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Queue/QueueManager.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Queue/SyncedQueue.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Tasks/PromiseTasks.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Tasks/TaskManager.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/Tasks/Tasks.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/ThreadComm.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/index.js","webpack://dve-testing/../../DSLIBS/threadComm/dist/tools/Queue.js","webpack://dve-testing/../../DSLIBS/voxelSpaces/dist/Classes/VoxelSpace.js","webpack://dve-testing/../../DSLIBS/voxelSpaces/dist/Types/VoxelSpaces.types.js","webpack://dve-testing/../../DSLIBS/voxelSpaces/dist/VoxelSpaces.js","webpack://dve-testing/../../DSLIBS/voxelSpaces/dist/index.js"],"sourcesContent":["import { MetaMapValues } from \"../Constants/MetaValues.js\";\nexport class TypedNode {\n    data;\n    get length() {\n        return this.data[2];\n    }\n    get type() {\n        return this.data[0];\n    }\n    get typeName() {\n        return MetaMapValues[this.type];\n    }\n    get primiteName() {\n        return MetaMapValues[this.type];\n    }\n    get listType() {\n        return this.data[1];\n    }\n    get listTypeName() {\n        return MetaMapValues[this.listType];\n    }\n    get value() {\n        return this.data[3];\n    }\n    set value(data) {\n        this.data[3] = data;\n    }\n    constructor(type, value, listType = 0, length = 0) {\n        this.data = [type, listType, length, value];\n    }\n}\n","export const ByteCounts = {\n    \"8i\": 1,\n    \"8ui\": 1,\n    \"8uic\": 1,\n    \"16i\": 2,\n    \"16ui\": 2,\n    \"32i\": 4,\n    \"32ui\": 4,\n    \"32f\": 4,\n    \"64f\": 8,\n    bigi: 8,\n    bigui: 8,\n};\nexport const ByteDataGet = {\n    \"8i\": (dv, index) => dv.getInt8(index),\n    \"8ui\": (dv, index) => dv.getUint8(index),\n    \"8uic\": (dv, index) => dv.getUint8(index),\n    \"16i\": (dv, index) => dv.getInt16(index),\n    \"16ui\": (dv, index) => dv.getUint16(index),\n    \"32i\": (dv, index) => dv.getInt32(index),\n    \"32ui\": (dv, index) => dv.getUint32(index),\n    \"32f\": (dv, index) => dv.getFloat32(index),\n    \"64f\": (dv, index) => dv.getFloat64(index),\n    //@ts-ignore\n    bigi: (dv, index) => dv.getBigInt64(index),\n    //@ts-ignore\n    bigui: (dv, index) => dv.getBigUint64(index),\n};\nexport const ByteDataSet = {\n    \"8i\": (dv, index, value) => dv.setInt8(index, value),\n    \"8ui\": (dv, index, value) => dv.setUint8(index, value),\n    \"8uic\": (dv, index, value) => dv.setUint8(index, value),\n    \"16i\": (dv, index, value) => dv.setInt16(index, value),\n    \"16ui\": (dv, index, value) => dv.setUint16(index, value),\n    \"32i\": (dv, index, value) => dv.setInt32(index, value),\n    \"32ui\": (dv, index, value) => dv.setUint32(index, value),\n    \"32f\": (dv, index, value) => dv.setFloat32(index, value),\n    \"64f\": (dv, index, value) => dv.setFloat64(index, value),\n    bigi: (dv, index, value) => dv.setBigInt64(index, BigInt(value)),\n    bigui: (dv, index, value) => dv.setBigUint64(index, BigInt(value)),\n};\nexport const TypedArrayCrete = {\n    \"8i\": (length) => new Int8Array(length),\n    \"8ui\": (length) => new Uint8Array(length),\n    \"8uic\": (length) => new Uint8ClampedArray(length),\n    \"16i\": (length) => new Int16Array(length),\n    \"16ui\": (length) => new Uint16Array(length),\n    \"32i\": (length) => new Int32Array(length),\n    \"32ui\": (length) => new Uint32Array(length),\n    \"32f\": (length) => new Float32Array(length),\n    \"64f\": (length) => new Float64Array(length),\n    bigi: (length) => new BigInt64Array(length),\n    bigui: (length) => new BigUint64Array(length),\n};\nexport const TypedArrayMap = {\n    \"8i\": Int8Array,\n    \"8ui\": Uint8Array,\n    \"8uic\": Uint8ClampedArray,\n    \"16i\": Int16Array,\n    \"16ui\": Uint16Array,\n    \"32i\": Int32Array,\n    \"32ui\": Uint32Array,\n    \"32f\": Float32Array,\n    \"64f\": Float64Array,\n    bigi: BigInt64Array,\n    bigui: BigUint64Array,\n};\nexport const TypedArrayRecord = new Map([\n    [Int8Array, \"8i\"],\n    [Uint8Array, \"8ui\"],\n    [Uint8ClampedArray, \"8uic\"],\n    [Int16Array, \"16i\"],\n    [Uint16Array, \"16ui\"],\n    [Int32Array, \"32i\"],\n    [Uint32Array, \"32ui\"],\n    [Float32Array, \"32f\"],\n    [Float64Array, \"64f\"],\n    [BigInt64Array, \"bigi\"],\n    [BigUint64Array, \"bigui\"],\n]);\nexport const ByteParser = {\n    view: new DataView(new ArrayBuffer(8)),\n    count: 0,\n    value: 0,\n    setValue(type, value) {\n        this.value = value;\n        ByteDataSet[type](this.view, 0, value);\n        this.count = ByteCounts[type];\n        return this;\n    },\n    addBytes(data) {\n        for (let i = 0; i < this.count; i++) {\n            data.push(this.view.getUint8(i));\n        }\n    },\n};\n","const markers = [\n    \"start\",\n    \"end\",\n    \"object\",\n    \"object-start\",\n    \"object-end\",\n    \"array\",\n    \"array-start\",\n    \"array-end\",\n    \"name\",\n    \"8i\",\n    \"8ui\",\n    \"8uic\",\n    \"16i\",\n    \"16ui\",\n    \"32f\",\n    \"32i\",\n    \"32ui\",\n    \"64f\",\n    \"bigi\",\n    \"bigui\",\n    \"fixed-typed-array\",\n    \"fixed-string\",\n    \"string\",\n    \"fixed-string-array\",\n    \"string-array\",\n    \"typed-array\",\n    \"json\",\n    \"DBO\",\n    \"boolean\",\n    \"undefined\",\n];\nconst metaValues = {};\nfor (let i = 0; i < markers.length; i++) {\n    metaValues[markers[i]] = i;\n}\nexport const MetaValues = metaValues;\nexport const MetaMapValues = {};\nfor (const key of Object.keys(MetaValues)) {\n    //@ts-ignore\n    MetaMapValues[Number(MetaValues[key])] = key;\n}\n","import { MetaValues, MetaMapValues } from \"../Constants/MetaValues.js\";\n//import { DBONode } from \"../Classes/DBONode.js\";\nimport { ByteCounts as BC, ByteDataGet } from \"../Constants/ByteData.js\";\nimport { TypedNode } from \"../Classes/TypedNode.js\";\nimport { TypedArrayCrete } from \"../Constants/ByteData.js\";\nexport const BufferToDBO = {\n    _mode: \"object\",\n    _cobj: {},\n    _parents: [],\n    _objArray: [],\n    _name: \"\",\n    _length: 0,\n    _objCount: 0,\n    _inOject: false,\n    _newDBONode(type, value, listType = \"start\") {\n        //@ts-ignore\n        return new TypedNode(MetaValues[type], value, MetaValues[listType]);\n    },\n    _assign(value) {\n        if (BufferToDBO._mode == \"object\" || BufferToDBO._mode == \"json\") {\n            if (Array.isArray(this._cobj)) {\n                this._cobj.push(value);\n            }\n            else {\n                this._cobj[this._name] = value;\n            }\n        }\n        else {\n            if (Array.isArray(this._cobj.value)) {\n                this._cobj.value.push(value);\n            }\n            else {\n                this._cobj.value[this._name] = value;\n            }\n        }\n    },\n    markFunctions: {\n        start: (dv, index) => {\n            return BC[\"8ui\"] + index;\n        },\n        end: (dv, index) => {\n            return BC[\"8ui\"] + index;\n        },\n        name: (dv, index) => {\n            BufferToDBO._name = \"\";\n            const length = ByteDataGet[\"8ui\"](dv, index + 1);\n            index += BC[\"8ui\"] * 2;\n            for (let i = index; i < index + length * BC[\"16ui\"]; i += 2) {\n                BufferToDBO._name += String.fromCharCode(ByteDataGet[\"16ui\"](dv, i));\n            }\n            return index + length * BC[\"16ui\"];\n        },\n        object: (dv, index) => { },\n        \"object-start\": (dv, index) => {\n            let newObj;\n            if (BufferToDBO._mode == \"object\") {\n                newObj = {};\n            }\n            else {\n                newObj = BufferToDBO._newDBONode(\"object\", {});\n            }\n            if (BufferToDBO._objCount != 0) {\n                BufferToDBO._assign(newObj);\n                BufferToDBO._parents.push(BufferToDBO._cobj);\n            }\n            BufferToDBO._objCount++;\n            BufferToDBO._cobj = newObj;\n            return BC[\"8ui\"] + index;\n        },\n        \"object-end\": (dv, index) => {\n            if (BufferToDBO._parents.length > 0) {\n                BufferToDBO._cobj = BufferToDBO._parents.pop();\n            }\n            return BC[\"8ui\"] + index;\n        },\n        array: (dv, index) => {\n            return BC[\"8ui\"] + index;\n        },\n        \"array-start\": (dv, index) => {\n            let newObj;\n            if (BufferToDBO._mode == \"object\") {\n                newObj = [];\n            }\n            else {\n                newObj = BufferToDBO._newDBONode(\"array\", []);\n            }\n            if (BufferToDBO._objCount != 0) {\n                BufferToDBO._assign(newObj);\n                BufferToDBO._parents.push(BufferToDBO._cobj);\n            }\n            BufferToDBO._objCount++;\n            BufferToDBO._cobj = newObj;\n            return BC[\"8ui\"] + index;\n        },\n        \"array-end\": (dv, index) => {\n            if (BufferToDBO._parents.length > 0) {\n                BufferToDBO._cobj = BufferToDBO._parents.pop();\n            }\n            return BC[\"8ui\"] + index;\n        },\n        boolean: (dv, index) => {\n            const value = ByteDataGet[\"8ui\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value ? false : true);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"boolean\", value ? false : true));\n            }\n            return BC[\"8ui\"] + BC[\"8i\"] + index;\n        },\n        undefined: (dv, index) => {\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(undefined);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"undefined\", undefined));\n            }\n            return BC[\"8ui\"] + index;\n        },\n        \"8i\": (dv, index) => {\n            const value = ByteDataGet[\"8i\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"8i\", value));\n            }\n            return BC[\"8ui\"] + BC[\"8i\"] + index;\n        },\n        \"8ui\": (dv, index) => {\n            const value = ByteDataGet[\"8ui\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"8ui\", value));\n            }\n            return BC[\"8ui\"] + BC[\"8ui\"] + index;\n        },\n        \"16i\": (dv, index) => {\n            const value = ByteDataGet[\"16i\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"16i\", value));\n            }\n            return BC[\"8ui\"] + BC[\"16i\"] + index;\n        },\n        \"16ui\": (dv, index) => {\n            const value = ByteDataGet[\"16ui\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"16ui\", value));\n            }\n            return BC[\"8ui\"] + BC[\"16ui\"] + index;\n        },\n        \"32f\": (dv, index) => {\n            const value = ByteDataGet[\"32f\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"32f\", value));\n            }\n            return BC[\"8ui\"] + BC[\"32f\"] + index;\n        },\n        \"32i\": (dv, index) => {\n            const value = ByteDataGet[\"32i\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"32i\", value));\n            }\n            return BC[\"8ui\"] + BC[\"32i\"] + index;\n        },\n        \"32ui\": (dv, index) => {\n            const value = ByteDataGet[\"32ui\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"32ui\", value));\n            }\n            return BC[\"8ui\"] + BC[\"8ui\"] + BC[\"32ui\"] + index + 1;\n        },\n        \"64f\": (dv, index) => {\n            const value = ByteDataGet[\"64f\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"64f\", value));\n            }\n            return BC[\"8ui\"] + BC[\"64f\"] + index;\n        },\n        bigi: (dv, index) => {\n            const value = ByteDataGet[\"bigi\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"bigi\", value));\n            }\n            return BC[\"8ui\"] + BC[\"bigi\"] + index;\n        },\n        bigui: (dv, index) => {\n            const value = ByteDataGet[\"bigui\"](dv, index + 1);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(value);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"bigui\", value));\n            }\n            return BC[\"8ui\"] + BC[\"bigui\"] + index;\n        },\n        \"fixed-typed-array\": (dv, index) => { },\n        \"fixed-string\": (dv, index) => { },\n        \"string-array\": (dv, index) => {\n            const size = ByteDataGet[\"32ui\"](dv, index + 1);\n            index += BC[\"32ui\"] + BC[\"8ui\"];\n            const array = [];\n            for (let i = 0; i < size; i++) {\n                let string = \"\";\n                const stringSize = ByteDataGet[\"32ui\"](dv, index);\n                index += BC[\"32ui\"];\n                for (let k = 0; k < stringSize; k++) {\n                    string += String.fromCharCode(ByteDataGet[\"16ui\"](dv, index));\n                    index += BC[\"16ui\"];\n                }\n                array.push(string);\n            }\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(array);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"string-array\", array));\n            }\n            return index;\n        },\n        string: (dv, index) => {\n            const length = ByteDataGet[\"32ui\"](dv, index + 1);\n            index += BC[\"32f\"] + BC[\"8ui\"];\n            let string = \"\";\n            for (let i = index; i < index + length * BC[\"16ui\"]; i += 2) {\n                string += String.fromCharCode(ByteDataGet[\"16ui\"](dv, i));\n            }\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(string);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"string\", string));\n            }\n            return index + length * BC[\"16ui\"];\n        },\n        \"typed-array\": (dv, index) => {\n            const type = MetaMapValues[ByteDataGet[\"8ui\"](dv, index + 1)];\n            const length = ByteDataGet[\"32ui\"](dv, index + 2);\n            index += BC[\"8ui\"] * 2 + BC[\"32ui\"];\n            let array;\n            if (BufferToDBO._mode == \"json\") {\n                array = [];\n            }\n            else {\n                array = TypedArrayCrete[type](length);\n            }\n            const func = ByteDataGet[type];\n            for (let i = 0; i < length; i++) {\n                array[i] = func(dv, index);\n                index += BC[type];\n            }\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(array);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"typed-array\", array, type));\n            }\n            return index;\n        },\n        json: (dv, index) => {\n            const length = ByteDataGet[\"32ui\"](dv, index + 1);\n            index += BC[\"32f\"] + BC[\"8ui\"];\n            let jsonString = \"\";\n            for (let i = index; i < index + length * BC[\"16ui\"]; i += 2) {\n                jsonString += String.fromCharCode(ByteDataGet[\"16ui\"](dv, i));\n            }\n            const result = JSON.parse(jsonString);\n            if (BufferToDBO._mode != \"DBO\") {\n                BufferToDBO._assign(result);\n            }\n            else {\n                BufferToDBO._assign(BufferToDBO._newDBONode(\"string\", result));\n            }\n            return index + length * BC[\"16ui\"];\n        },\n        DBO: (dv, index) => { },\n    },\n    toObject(buffer, byteOffSet = 0) {\n        this._mode = \"object\";\n        let legnth = buffer.byteLength;\n        const dv = new DataView(buffer);\n        this._objCount = 0;\n        let index = byteOffSet;\n        let mark = \"16i\";\n        let markType = 0;\n        while (index < legnth) {\n            markType = ByteDataGet[\"8ui\"](dv, index);\n            mark = MetaMapValues[markType];\n            index = this.markFunctions[mark](dv, index);\n        }\n        return this._cobj;\n    },\n    toJSON(buffer, byteOffSet = 0) {\n        this._mode = \"json\";\n        let legnth = buffer.byteLength;\n        const dv = new DataView(buffer);\n        this._objCount = 0;\n        let index = byteOffSet;\n        let mark = \"16i\";\n        let markType = 0;\n        while (index < legnth) {\n            markType = ByteDataGet[\"8ui\"](dv, index);\n            mark = MetaMapValues[markType];\n            index = this.markFunctions[mark](dv, index);\n        }\n        return this._cobj;\n    },\n    toDBO(buffer, byteOffSet = 0, byteOffSetEnd = 0) {\n        this._mode = \"DBO\";\n        let legnth;\n        if (byteOffSetEnd == 0) {\n            legnth = buffer.byteLength;\n        }\n        else {\n            legnth = byteOffSetEnd;\n        }\n        const dv = new DataView(buffer);\n        this._objCount = 0;\n        let index = byteOffSet;\n        let mark = \"16i\";\n        let markType = 0;\n        while (index < legnth) {\n            markType = ByteDataGet[\"8ui\"](dv, index);\n            mark = MetaMapValues[markType];\n            index = this.markFunctions[mark](dv, index);\n        }\n        this._parents = [];\n        return this._cobj;\n    },\n};\n","import { MetaValues } from \"../Constants/MetaValues.js\";\nimport { ByteParser } from \"../Constants/ByteData.js\";\nexport const DBOToBuffer = {\n    _proto: [],\n    _tokenizeString(string) {\n        for (let i = 0; i < string.length; i++) {\n            this._addToken(\"16ui\", string.charCodeAt(i));\n        }\n    },\n    _traverseObj(data) {\n        this._addMarker(\"object-start\");\n        //for the object start and end marks\n        for (const key of Object.keys(data.value)) {\n            let length = key.length;\n            if (length > 255) {\n                throw new Error(\"An object key cannot be longer then 255 chars.\");\n            }\n            this._addMarker(\"name\");\n            this._addToken(\"8ui\", key.length);\n            this._tokenizeString(key);\n            const node = data.value[key];\n            if (node.typeName == \"object\" && !ArrayBuffer.isView(node.value)) {\n                this._traverseObj(node);\n                continue;\n            }\n            if (node.typeName == \"array\" && !ArrayBuffer.isView(node.value)) {\n                this._traverseArray(node);\n                continue;\n            }\n            this._tokenizePrimiives(node);\n        }\n        this._addMarker(\"object-end\");\n    },\n    _traverseArray(data) {\n        this._addMarker(\"array-start\");\n        //for object array start and end marks\n        const array = data.value;\n        for (const node of array) {\n            if (typeof node.value == \"object\" &&\n                !Array.isArray(node.value) &&\n                !ArrayBuffer.isView(node.value)) {\n                this._traverseObj(node);\n                continue;\n            }\n            if (typeof node.value == \"object\" &&\n                Array.isArray(node.value) &&\n                !ArrayBuffer.isView(node.value)) {\n                this._traverseArray(node);\n                continue;\n            }\n            this._tokenizePrimiives(node);\n        }\n        this._addMarker(\"array-end\");\n    },\n    _tokenizePrimiives(node) {\n        if (node.typeName == \"string\") {\n            this._addMarker(\"string\");\n            this._addToken(\"32ui\", node.value.length);\n            for (let i = 0; i < node.value.length; i++) {\n                this._addToken(\"16ui\", node.value.charCodeAt(i));\n            }\n            return;\n        }\n        if (typeof node.value == \"number\") {\n            this._addMarker(node.typeName);\n            this._addToken(node.primiteName, node.value);\n            return;\n        }\n        if (typeof node.value == \"boolean\") {\n            this._addMarker(node.typeName);\n            this._addToken(\"8ui\", node.value ? 0 : 1);\n            return;\n        }\n        if (typeof node.value == \"undefined\") {\n            this._addMarker(node.typeName);\n            return;\n        }\n        if (node.typeName == \"typed-array\") {\n            this._addMarker(\"typed-array\");\n            this._addToken(\"8ui\", node.listType);\n            this._addToken(\"32ui\", node.value.length);\n            let array = node.value;\n            for (let i = 0; i < array.length; i++) {\n                this._addToken(node.listTypeName, array[i]);\n            }\n        }\n        if (node.typeName == \"string-array\") {\n            this._addMarker(\"string-array\");\n            this._addToken(\"32ui\", node.value.length);\n            let array = node.value;\n            for (let i = 0; i < array.length; i++) {\n                const value = array[i];\n                this._addToken(\"32ui\", value.length);\n                for (let k = 0; k < value.length; k++) {\n                    this._addToken(\"16ui\", value.charCodeAt(k));\n                }\n            }\n            return;\n        }\n        if (node.typeName == \"json\") {\n            let json = \"\";\n            if (typeof node.value == \"object\") {\n                json = JSON.stringify(node.value);\n            }\n            else {\n                json = node.value;\n            }\n            this._addMarker(\"json\");\n            this._addToken(\"32ui\", json.length);\n            for (let i = 0; i < json.length; i++) {\n                this._addToken(\"16ui\", json.charCodeAt(i));\n            }\n            return;\n        }\n    },\n    _tokenize(node) {\n        //start as two bytes for the stand and end tags\n        if (node.typeName == \"object\" && !Array.isArray(node.value)) {\n            this._traverseObj(node);\n        }\n        if (node.typeName == \"array\" && Array.isArray(node.value)) {\n            this._traverseArray(node);\n        }\n    },\n    toBuffer(data, byteOffSet = 0) {\n        this._addMarker(\"start\");\n        this._tokenize(data);\n        this._addMarker(\"end\");\n        const array = Uint8Array.from(this._proto);\n        this._proto = [];\n        return array.buffer;\n    },\n    _addMarker(marker) {\n        ByteParser.setValue(\"8ui\", MetaValues[marker]).addBytes(this._proto);\n    },\n    _addToken(type, value) {\n        ByteParser.setValue(type, value).addBytes(this._proto);\n    },\n};\n","import { TypedArrayRecord } from \"../Constants/ByteData.js\";\nimport { TypedNode } from \"../Classes/TypedNode.js\";\nimport { TNM } from \"../NodeMaker.js\";\nimport { DBOToBuffer } from \"./DBOToBuffer.js\";\nexport const ObjectToBuffer = {\n    _name: \"\",\n    _traverseObj(obj) {\n        const node = TNM.object({});\n        for (const key of Object.keys(obj)) {\n            const value = obj[key];\n            this._name = key;\n            if (value instanceof TypedNode) {\n                node.value[key] = value;\n                continue;\n            }\n            if (ArrayBuffer.isView(value)) {\n                node.value[key] = this._addPrimitive(value);\n                continue;\n            }\n            if (typeof value == \"object\" && !Array.isArray(value)) {\n                node.value[key] = this._traverseObj(value);\n                continue;\n            }\n            if (typeof value == \"object\" && Array.isArray(value)) {\n                node.value[key] = this._traverseArray(value);\n                continue;\n            }\n            node.value[key] = this._addPrimitive(value);\n        }\n        return node;\n    },\n    _traverseArray(array) {\n        const node = TNM.array([]);\n        for (const value of array) {\n            if (value instanceof TypedNode) {\n                node.value.push(value);\n                continue;\n            }\n            if (ArrayBuffer.isView(value)) {\n                node.value.push(this._addPrimitive(value));\n                continue;\n            }\n            if (typeof value == \"object\" && !Array.isArray(value)) {\n                node.value.push(this._traverseObj(value));\n                continue;\n            }\n            if (typeof value == \"object\" && Array.isArray(value) && !ArrayBuffer.isView(value)) {\n                node.value.push(this._traverseArray(value));\n                continue;\n            }\n            node.value.push(this._addPrimitive(value));\n        }\n        return node;\n    },\n    _addPrimitive(node) {\n        if (typeof node == \"string\") {\n            return TNM.string(node);\n        }\n        if (typeof node == \"number\") {\n            return TNM._64f(node);\n        }\n        if (typeof node == \"boolean\") {\n            return TNM.boolean(node);\n        }\n        if (typeof node == \"undefined\") {\n            return TNM.undefined();\n        }\n        if (ArrayBuffer.isView(node)) {\n            //@ts-ignore\n            if (TypedArrayRecord.has(node.constructor)) {\n                return TNM.typedArray(\n                //@ts-ignore\n                TypedArrayRecord.get(node.constructor), \n                //@ts-ignore\n                node);\n            }\n        }\n        if (node instanceof TypedNode) {\n            return node;\n        }\n        throw new Error(`Unsuppourted type for DBO parser.`);\n    },\n    toDBO(object) {\n        if (typeof object == \"object\" && !Array.isArray(object)) {\n            const parent = TNM.object({});\n            parent.value = this._traverseObj(object).value;\n            return parent;\n        }\n        if (typeof object == \"object\" && Array.isArray(object)) {\n            const parent = TNM.array([]);\n            parent.value = this._traverseArray(object).value;\n            return parent;\n        }\n        return this._addPrimitive(object);\n    },\n    toBuffer(object) {\n        const dbo = this.toDBO(object);\n        return DBOToBuffer.toBuffer(dbo);\n    },\n};\n","import { TNM } from \"./NodeMaker.js\";\nimport { BufferToDBO } from \"./DBO/BufferToDBO.js\";\nimport { ObjectToBuffer } from \"./DBO/ObjectToBuffer.js\";\nimport { DBOToBuffer } from \"./DBO/DBOToBuffer.js\";\nexport const DBO = {\n    nodes: TNM,\n    bufferToObject(buffer, byteOffSet = 0) {\n        return BufferToDBO.toObject(buffer);\n    },\n    objectToBuffer(obj) {\n        return ObjectToBuffer.toBuffer(obj);\n    },\n    objectToDBO(object) {\n        return ObjectToBuffer.toDBO(object);\n    },\n    dboToBuffer(data) {\n        return DBOToBuffer.toBuffer(data);\n    },\n    bufferToDBO(buffer, byteOffSet = 0, byteOffSetEnd = 0) {\n        return BufferToDBO.toDBO(buffer, byteOffSet, byteOffSetEnd);\n    },\n};\n","import { TypedNode } from \"./Classes/TypedNode.js\";\nimport { MetaValues } from \"./Constants/MetaValues.js\";\nimport { TypedArrayMap } from \"./Constants/ByteData.js\";\nexport const TNM = {\n    json(data) {\n        return new TypedNode(MetaValues[\"json\"], data);\n    },\n    DBO(data) {\n        return new TypedNode(MetaValues[\"DBO\"], data);\n    },\n    object(data) {\n        return new TypedNode(MetaValues[\"object\"], data);\n    },\n    array(data) {\n        if (!Array.isArray(data))\n            throw new Error(\"Data for array must be an array.\");\n        return new TypedNode(MetaValues[\"array\"], data);\n    },\n    _8i(value) {\n        return new TypedNode(MetaValues[\"8i\"], value);\n    },\n    _8ui(value) {\n        return new TypedNode(MetaValues[\"8ui\"], value);\n    },\n    _16i(value) {\n        return new TypedNode(MetaValues[\"16i\"], value);\n    },\n    _16ui(value) {\n        return new TypedNode(MetaValues[\"16ui\"], value);\n    },\n    _32ui(value) {\n        return new TypedNode(MetaValues[\"32ui\"], value);\n    },\n    _32i(value) {\n        return new TypedNode(MetaValues[\"32i\"], value);\n    },\n    _32f(value) {\n        return new TypedNode(MetaValues[\"32f\"], value);\n    },\n    _64f(value) {\n        return new TypedNode(MetaValues[\"64f\"], value);\n    },\n    bigi(value) {\n        return new TypedNode(MetaValues[\"bigi\"], value);\n    },\n    bigui(value) {\n        return new TypedNode(MetaValues[\"bigui\"], value);\n    },\n    boolean(value) {\n        return new TypedNode(MetaValues[\"boolean\"], value);\n    },\n    undefined() {\n        return new TypedNode(MetaValues[\"undefined\"], undefined);\n    },\n    typedArray(type, value) {\n        return new TypedNode(MetaValues[\"typed-array\"], \n        //@ts-ignore\n        ArrayBuffer.isView(value) ? value : TypedArrayMap[type].from(value), MetaValues[type]);\n    },\n    stringArray(value) {\n        return new TypedNode(MetaValues[\"string-array\"], value);\n    },\n    string(value) {\n        return new TypedNode(MetaValues[\"string\"], value);\n    },\n    fixedString(value, length) {\n        return new TypedNode(MetaValues[\"fixed-string\"], value, 0, length);\n    },\n    fixedTypedArray(type, value, length) {\n        return new TypedNode(MetaValues[\"fixed-typed-array\"], value, MetaValues[type], length);\n    },\n    toJSONString(json) {\n        if (typeof json === \"string\") {\n            json = JSON.parse(json);\n        }\n        let output = JSON.stringify(json, function (k, v) {\n            if (v instanceof Array)\n                return JSON.stringify(v);\n            return v;\n        }, 2)\n            .replace(/\\\\/g, \"\")\n            .replace(/\\\"\\[/g, \"[\")\n            .replace(/\\]\\\"/g, \"]\")\n            .replace(/\\\"\\{/g, \"{\")\n            .replace(/\\}\\\"/g, \"}\");\n        return output;\n    },\n};\n","export * from \"./NodeMaker.js\";\nexport * from \"./Classes/TypedNode.js\";\nexport * from \"./DivineBinaryObject.js\";\n","import { DBTUtil, TagNodeTypes } from \"../Util/DBTUtil.js\";\nconst TagIndexData = [0, 0, 0, 0];\nconst getIndexData = (data, indexBufferIndex) => {\n    TagIndexData[0] = data.getUint32(indexBufferIndex);\n    indexBufferIndex += DBTUtil.getTypedSize(\"32ui\");\n    TagIndexData[1] = data.getUint8(indexBufferIndex);\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\n    TagIndexData[2] = data.getUint8(indexBufferIndex);\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\n    TagIndexData[3] = data.getUint8(indexBufferIndex);\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\n    return TagIndexData;\n};\nexport class TagManagerBase {\n    id;\n    byteOffSet = 0;\n    tagSize = 0;\n    tagIndexes = 0;\n    data = new DataView(new ArrayBuffer(0));\n    indexMap = new Map();\n    index = new DataView(new ArrayBuffer(0));\n    constructor(id) {\n        this.id = id;\n    }\n    setBuffer(data) {\n        if (data instanceof DataView) {\n            this.data = data;\n            return;\n        }\n        this.data = new DataView(data);\n    }\n    getBuffer() {\n        if (this.data instanceof DataView) {\n            return this.data.buffer;\n        }\n        return this.data;\n    }\n    setTagIndex(index) {\n        this.byteOffSet = index * this.tagSize;\n    }\n    getTag(id) {\n        const byteIndex = this.indexMap.get(id);\n        if (byteIndex === undefined) {\n            throw new Error(`Tag with id: ${id} does not exist.`);\n        }\n        const indexData = getIndexData(this.index, byteIndex);\n        if (indexData[3] == TagNodeTypes.boolean ||\n            indexData[3] == TagNodeTypes.number) {\n            return DBTUtil.getBitValue(this.data.getUint8(indexData[0] + this.byteOffSet), indexData[1], indexData[2]);\n        }\n        if (indexData[3] == TagNodeTypes.typedNumber) {\n            return DBTUtil.getTypedNumber(this.data, indexData[0] + this.byteOffSet, indexData[2]);\n        }\n        return -Infinity;\n    }\n    setTag(id, value) {\n        const byteIndex = this.indexMap.get(id);\n        if (byteIndex === undefined) {\n            throw new Error(`Tag with id: ${id} does not exist.`);\n        }\n        const indexData = getIndexData(this.index, byteIndex);\n        if (indexData[3] == TagNodeTypes.boolean ||\n            indexData[3] == TagNodeTypes.number) {\n            this.data.setUint8(indexData[0] + this.byteOffSet, DBTUtil.setBitValue(this.data.getUint8(indexData[0] + this.byteOffSet), indexData[1], value, indexData[2]));\n            return true;\n        }\n        if (indexData[3] == TagNodeTypes.typedNumber) {\n            DBTUtil.setTypedNumber(this.data, indexData[0] + this.byteOffSet, indexData[2], value);\n            return true;\n        }\n        return false;\n    }\n    getArrayTagValue(id, index) {\n        const byteIndex = this.indexMap.get(id);\n        if (byteIndex === undefined) {\n            throw new Error(`Tag with id: ${id} does not exist.`);\n        }\n        const indexData = getIndexData(this.index, byteIndex);\n        if (indexData[3] == TagNodeTypes.typedNumberArray) {\n            return DBTUtil.getTypedNumber(this.data, indexData[0] +\n                this.byteOffSet +\n                index * DBTUtil.getTypedSizeFromNumber(indexData[2]), indexData[2]);\n        }\n        if (indexData[3] == TagNodeTypes.bitArray) {\n            return DBTUtil.getBitArrayIndex(this.data, indexData[0] + this.byteOffSet, index);\n        }\n        throw new Error(`Tag with id: ${id} is not an array.`);\n    }\n    /**## getArrayTagByteIndex\n     *  Get the actual byte index for the provided index of the array.\n     * @param id\n     * @param index\n     * @returns\n     */\n    getArrayTagByteIndex(id, index) {\n        const byteIndex = this.indexMap.get(id);\n        if (byteIndex === undefined) {\n            throw new Error(`Tag with id: ${id} does not exist.`);\n        }\n        const indexData = getIndexData(this.index, byteIndex);\n        if (indexData[3] == TagNodeTypes.typedNumberArray) {\n            return (indexData[0] +\n                this.byteOffSet +\n                index * DBTUtil.getTypedSizeFromNumber(indexData[2]));\n        }\n        return -Infinity;\n    }\n    setArrayTagValue(id, index, value) {\n        const byteIndex = this.indexMap.get(id);\n        if (byteIndex === undefined) {\n            throw new Error(`Tag with id: ${id} does not exist.`);\n        }\n        const indexData = getIndexData(this.index, byteIndex);\n        if (indexData[3] == TagNodeTypes.typedNumberArray) {\n            return DBTUtil.setTypedNumber(this.data, indexData[0] +\n                this.byteOffSet +\n                index * DBTUtil.getTypedSizeFromNumber(indexData[2]), indexData[2], value);\n        }\n        if (indexData[3] == TagNodeTypes.bitArray) {\n            return DBTUtil.setBitArrayIndex(this.data, indexData[0] + this.byteOffSet, index, value);\n        }\n        return -Infinity;\n    }\n    loopThroughTags(run) {\n        this.indexMap.forEach((i, id) => {\n            run(id, this.getTag(id));\n        });\n    }\n    loopThroughIndex(run) {\n        this.indexMap.forEach((index, id) => {\n            const indexData = getIndexData(this.index, index);\n            run(indexData);\n        });\n    }\n    loopThroughAllIndexTags(run) {\n        for (let index = 0; index < this.tagIndexes; index++) {\n            this.setTagIndex(index);\n            this.indexMap.forEach((i, id) => {\n                run(id, this.getTag(id), index);\n            });\n        }\n    }\n}\n","import { RemoteTagManager } from \"./RemoteTagManager.js\";\nimport { TagManager } from \"./TagManager.js\";\nexport const DivineBinaryTags = {\n    createTagManager(id) {\n        return new TagManager(id);\n    },\n    createRemoteTagManager(id) {\n        return new RemoteTagManager(id);\n    },\n};\n","import { TagManagerBase } from \"./Classes/TagManagerBase.js\";\nexport class RemoteTagManager extends TagManagerBase {\n    id;\n    initData;\n    constructor(id) {\n        super(id);\n        this.id = id;\n    }\n    $INIT(data) {\n        this.data = new DataView(data.buffer);\n        this.index = new DataView(data.indexBuffer);\n        this.indexMap = data.indexMap;\n        this.tagIndexes = data.totalIndexes;\n        this.tagSize = data.tagSize;\n        this.initData = data;\n    }\n}\n","import { DBTUtil, TagNodeTypes, NumberTypeRecord } from \"./Util/DBTUtil.js\";\nimport { TagManagerBase } from \"./Classes/TagManagerBase.js\";\nconst TagIndexSize = DBTUtil.getTypedSize(\"32ui\") + DBTUtil.getTypedSize(\"8ui\") * 3;\nconst setIndexData = (data, indexBufferIndex, byteIndex, bitOffSet, bitSize, type) => {\n    data.setUint32(indexBufferIndex, byteIndex);\n    indexBufferIndex += DBTUtil.getTypedSize(\"32ui\");\n    data.setUint8(indexBufferIndex, bitOffSet);\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\n    data.setUint8(indexBufferIndex, bitSize);\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\n    data.setUint8(indexBufferIndex, type);\n    indexBufferIndex += DBTUtil.getTypedSize(\"8ui\");\n    return indexBufferIndex;\n};\nexport class TagManager extends TagManagerBase {\n    id;\n    schema = new Map();\n    initData = {};\n    constructor(id) {\n        super(id);\n        this.id = id;\n    }\n    registerTag(tagData) {\n        this.schema.set(tagData.id, tagData);\n    }\n    $INIT(initData) {\n        /*\n    [Process Tags]\n    */\n        const headers = new Map();\n        const booleans = [];\n        const numbers = [];\n        const typedNumbers = new Map();\n        const typedNumbersArrays = new Map();\n        const bitArrays = [];\n        this.schema.forEach((tag) => {\n            if (tag.type == \"header\") {\n                let tags = headers.get(tag.numberType);\n                if (!tags) {\n                    tags = [];\n                    headers.set(tag.numberType, tags);\n                }\n                tags.push(tag);\n            }\n            if (tag.type == \"boolean\") {\n                booleans.push(tag);\n            }\n            if (tag.type == \"number\") {\n                const range = tag.range;\n                const bitSize = DBTUtil.calculateBitsNeeded(range[0], range[1]);\n                numbers[bitSize] ??= [];\n                numbers[bitSize].push(tag);\n            }\n            if (tag.type == \"typed-number\") {\n                let tags = typedNumbers.get(tag.numberType);\n                if (!tags) {\n                    tags = [];\n                    typedNumbers.set(tag.numberType, tags);\n                }\n                tags.push(tag);\n            }\n            if (tag.type == \"typed-number-array\") {\n                let arrayTags = typedNumbersArrays.get(tag.numberType);\n                if (!arrayTags) {\n                    arrayTags = [];\n                    typedNumbersArrays.set(tag.numberType, arrayTags);\n                }\n                arrayTags.push(tag);\n            }\n            if (tag.type == \"bit-array\") {\n                bitArrays.push(tag);\n            }\n        });\n        /*\n    [Build Index]\n    */\n        const indexSize = this.schema.size * TagIndexSize;\n        let indexBuffer = new ArrayBuffer(indexSize);\n        if (initData?.indexBufferMode == \"shared\") {\n            indexBuffer = new SharedArrayBuffer(indexSize);\n        }\n        const index = new DataView(indexBuffer);\n        this.index = index;\n        let indexBufferIndex = 0;\n        let byteIndex = 0;\n        let bitIndex = 0;\n        let bitSize = 1;\n        /*\n    [Headers]\n    */\n        headers.forEach((tags, type) => {\n            const byteSise = DBTUtil.getTypedSize(type);\n            for (let i = 0; i < tags.length; i++) {\n                const tag = tags[i];\n                this.indexMap.set(tag.id, indexBufferIndex);\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, 0, NumberTypeRecord[tag.numberType], TagNodeTypes.typedNumber);\n                byteIndex += byteSise;\n            }\n        });\n        /*\n    [Booleans]\n    */\n        bitSize = 1;\n        for (let i = 0; i < booleans.length; i++) {\n            const bool = booleans[i];\n            this.indexMap.set(bool.id, indexBufferIndex);\n            indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, bitIndex, bitSize, TagNodeTypes.boolean);\n            bitIndex++;\n            if (bitIndex >= 8) {\n                byteIndex++;\n                bitIndex = 0;\n            }\n        }\n        /*\n    [Ranged Numbers]\n    */\n        byteIndex++;\n        bitIndex = 0;\n        let cachedBitSize = 0;\n        numbers.forEach((tags, bitS) => {\n            bitSize = bitS;\n            if (cachedBitSize != bitSize) {\n                byteIndex++;\n                bitIndex = 0;\n            }\n            for (let i = 0; i < tags.length; i++) {\n                const tag = tags[i];\n                this.indexMap.set(tag.id, indexBufferIndex);\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, bitIndex, bitSize, TagNodeTypes.number);\n                bitIndex += bitSize;\n                if (bitIndex >= 8) {\n                    byteIndex++;\n                    bitIndex = 0;\n                }\n            }\n        });\n        /*\n    [Typed Numbers]\n    */\n        bitIndex = 0;\n        byteIndex++;\n        typedNumbers.forEach((tags, type) => {\n            const byteSise = DBTUtil.getTypedSize(type);\n            for (let i = 0; i < tags.length; i++) {\n                const tag = tags[i];\n                this.indexMap.set(tag.id, indexBufferIndex);\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, 0, NumberTypeRecord[tag.numberType], TagNodeTypes.typedNumber);\n                byteIndex += byteSise;\n            }\n        });\n        /*\n    [Typed Numbers Arrays]\n    */\n        byteIndex++;\n        typedNumbersArrays.forEach((tags, type) => {\n            const byteSise = DBTUtil.getTypedSize(type);\n            for (let i = 0; i < tags.length; i++) {\n                const tag = tags[i];\n                this.indexMap.set(tag.id, indexBufferIndex);\n                indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, 0, NumberTypeRecord[tag.numberType], TagNodeTypes.typedNumberArray);\n                byteIndex += byteSise * tag.length;\n            }\n        });\n        byteIndex++;\n        bitArrays.forEach((tag) => {\n            const byteSise = Math.ceil(tag.length / 8) + 1;\n            this.indexMap.set(tag.id, indexBufferIndex);\n            indexBufferIndex = setIndexData(index, indexBufferIndex, byteIndex, 0, byteSise, TagNodeTypes.bitArray);\n            byteIndex += byteSise;\n        });\n        /*\n    [Create Remote Tag Manager Data]\n    */\n        let numberOfIndexes = 1;\n        if (initData?.numberOfIndexes) {\n            numberOfIndexes = initData.numberOfIndexes;\n        }\n        this.tagIndexes = numberOfIndexes;\n        this.tagSize = byteIndex;\n        const remoteData = {\n            bufferSize: byteIndex * numberOfIndexes,\n            buffer: new ArrayBuffer(0),\n            indexBuffer: indexBuffer,\n            indexMap: this.indexMap,\n            tagSize: this.tagSize,\n            totalIndexes: numberOfIndexes,\n        };\n        this.initData = remoteData;\n        return remoteData;\n    }\n}\n","export {};\n","export {};\n","export const TagNodeTypes = {\n    boolean: 0,\n    number: 1,\n    typedNumber: 2,\n    typedNumberArray: 3,\n    bitArray: 4,\n};\nconst NumberTypeByteSize = {\n    \"8ui\": 1,\n    \"8i\": 1,\n    \"16ui\": 2,\n    \"16i\": 2,\n    \"32ui\": 4,\n    \"32i\": 4,\n    \"32f\": 4,\n    \"64f\": 8,\n    \"64i\": 8,\n    \"64ui\": 8,\n};\nexport const NumberTypeRecord = {\n    \"8ui\": 0,\n    \"8i\": 1,\n    \"16ui\": 2,\n    \"16i\": 3,\n    \"32ui\": 4,\n    \"32i\": 5,\n    \"32f\": 6,\n    \"64f\": 7,\n    \"64i\": 8,\n    \"64ui\": 9,\n};\nexport const NumberTypeMap = {};\nfor (const key of Object.keys(NumberTypeRecord)) {\n    //@ts-ignore\n    NumberTypeMap[Number(NumberTypeRecord[key])] = key;\n}\nconst TypedNumberSetFunctions = {\n    \"8ui\": (d, i, v) => d.setUint8(i, v),\n    \"8i\": (d, i, v) => d.setInt8(i, v),\n    \"16ui\": (d, i, v) => d.setUint16(i, v),\n    \"16i\": (d, i, v) => d.setInt16(i, v),\n    \"32ui\": (d, i, v) => d.setUint32(i, v),\n    \"32i\": (d, i, v) => d.setInt32(i, v),\n    \"32f\": (d, i, v) => d.setFloat32(i, v),\n    \"64f\": (d, i, v) => d.setFloat64(i, v),\n    \"64i\": (d, i, v) => d.setBigUint64(i, BigInt(v)),\n    \"64ui\": (d, i, v) => d.setBigUint64(i, BigInt(v)),\n};\nconst TypedNumberGetFunctions = {\n    \"8ui\": (d, i) => d.getUint8(i),\n    \"8i\": (d, i) => d.getInt8(i),\n    \"16ui\": (d, i) => d.getUint16(i),\n    \"16i\": (d, i) => d.getInt16(i),\n    \"32ui\": (d, i) => d.getUint32(i),\n    \"32i\": (d, i) => d.getInt32(i),\n    \"32f\": (d, i) => d.getFloat32(i),\n    \"64f\": (d, i) => d.getFloat64(i),\n    \"64i\": (d, i) => Number(d.getBigUint64(i)),\n    \"64ui\": (d, i) => Number(d.getBigUint64(i)),\n};\nexport const DBTUtil = {\n    setTypedNumber(data, index, numberType, value) {\n        TypedNumberSetFunctions[NumberTypeMap[numberType]](data, index, value);\n    },\n    getTypedNumber(data, index, numberType) {\n        return TypedNumberGetFunctions[NumberTypeMap[numberType]](data, index);\n    },\n    calculateBitsNeeded(min, max) {\n        let range = max - min;\n        return Math.ceil(Math.log2(range));\n    },\n    getTypedSize(type) {\n        return NumberTypeByteSize[type];\n    },\n    getTypedSizeFromNumber(t) {\n        return NumberTypeByteSize[NumberTypeMap[t]];\n    },\n    getBitValue(data, index, bitSize) {\n        index *= bitSize;\n        const mask = 2 ** bitSize - 1;\n        return ((mask << index) & data) >>> index;\n    },\n    setBitValue(data, index, value, bitSize) {\n        index *= bitSize;\n        const mask = 2 ** bitSize - 1;\n        return (data & ~(mask << index)) | ((value & mask) << index);\n    },\n    getBitArrayIndex(data, byteIndex, arrayIndex) {\n        const arrayByteIndex = (arrayIndex / 8) >> 0;\n        const arrayBitIndex = arrayIndex - arrayByteIndex * 8;\n        const arrayByte = data.getUint8(arrayByteIndex + byteIndex);\n        return this.getBitValue(arrayByte, arrayBitIndex, 1);\n    },\n    setBitArrayIndex(data, byteIndex, arrayIndex, value) {\n        const arrayByteIndex = (arrayIndex / 8) >> 0;\n        const arrayBitIndex = arrayIndex - arrayByteIndex * 8;\n        const arrayByte = data.getUint8(arrayByteIndex + byteIndex);\n        data.setUint8(arrayByteIndex + byteIndex, this.setBitValue(arrayByte, arrayBitIndex, value, 1));\n    },\n};\n","export * from \"./DivineBinaryTags.js\";\nexport * from \"./RemoteTagManager.js\";\nexport * from \"./TagManager.js\";\nexport * from \"./Classes/TagManagerBase.js\";\nexport * from \"./Types/DBTSchema.types.js\";\nexport * from \"./Types/Util.types.js\";\nexport * from \"./Util/DBTUtil.js\";\n","export class AsyncHook {\n    _onRun = [];\n    async run(data) {\n        let returnData = false;\n        for (const run of this._onRun) {\n            returnData = await run(data);\n        }\n        return returnData;\n    }\n    addToRun(run) {\n        this._onRun.push(run);\n    }\n}\n","export class SyncHook {\n    _onRun = [];\n    run(data) {\n        let returnData = false;\n        for (const run of this._onRun) {\n            returnData = run(data);\n        }\n        return returnData;\n    }\n    addToRun(run) {\n        this._onRun.push(run);\n    }\n}\n","import { AsyncHook } from \"./Classes/AsyncHook.js\";\nimport { SyncHook } from \"./Classes/SyncHook.js\";\nexport const Hooks = {\n    getAsyncHook() {\n        return new AsyncHook();\n    },\n    getSyncHook() {\n        return new SyncHook();\n    },\n};\n","export * from \"./Hooks.js\";\n","export const DataSyncIds = {\n    chunk: 0,\n    column: 1,\n    region: 2,\n    regionHeader: 2,\n    voxelPalette: 3,\n    voxelTags: 4,\n    materials: 4,\n    colliders: 4,\n    dimesnion: 5,\n    chunkTags: 6,\n    columnTags: 7,\n    regionTags: 8,\n    substanceTags: 8,\n    substancePalette: 8,\n    registerStringMap: 0,\n    registerObjectMap: 0,\n};\nlet index = 0;\nfor (const key of Object.keys(DataSyncIds)) {\n    DataSyncIds[key] = index;\n    index++;\n}\n","export const ChunkTagIDs = {\n    minHeight: \"#dve_min_height\",\n    maxHeight: \"#dve_max_height\",\n    heightMap: \"#dve_height_map\",\n    dirtyMap: \"#dve_dirty_map\",\n    voxelIDSegment: \"#dve_voxel_id\",\n    voxelLightSegment: \"#dve_voxel_light\",\n    voxelStateSegment: \"#dve_voxel_state\",\n    voxelSecondaryIDSegment: \"#dve_voxel_secondary_id\",\n};\n","export const SubstanceTagIds = {\n    parent: \"#dve_parent_substance\",\n    rendered: \"#dve_rendered_substance\",\n    isSolid: \"#dve_is_solid\",\n    isLiquid: \"#dve_is_liquid\",\n    flowRate: \"#dve_flow_rate\",\n    culledSubstnaces: \"#dve_culled_substances\",\n};\n","export const VoxelTagIDs = {\n    substance: \"#dve_substance\",\n    shapeID: \"#dve_shape_id\",\n    material: \"#dve_material\",\n    hardness: \"#dve_hardness\",\n    colliderID: \"#dve_collider_id\",\n    checkCollisions: \"#dve_check_collisions\",\n    isLightSource: \"#dve_is_light_source\",\n    lightValue: \"#dve_light_value\",\n    isRich: \"#dve_is_rich\",\n};\n","export const WorldDataTagIDs = {\n    header: \"#dve_header\",\n    dataType: \"#dve_data_type\",\n    dimensionId: \"#dve_dimension_id\",\n    positionX: \"#dve_p_x\",\n    positionY: \"#dve_p_y\",\n    positionZ: \"#dve_p_z\",\n};\n","import { Hooks } from \"divine-hooks\";\nexport const DataHooks = {\n    dimension: {\n        onRegisterDimension: Hooks.getSyncHook(),\n    },\n    chunk: {\n        onGetAsync: Hooks.getAsyncHook(),\n        onGetSync: Hooks.getSyncHook(),\n        onNew: Hooks.getAsyncHook(),\n        onRemove: Hooks.getSyncHook(),\n    },\n    column: {\n        onGetAsync: Hooks.getAsyncHook(),\n        onGetSync: Hooks.getSyncHook(),\n        onNew: Hooks.getAsyncHook(),\n        onRemove: Hooks.getSyncHook(),\n    },\n    region: {\n        onGetAsync: Hooks.getAsyncHook(),\n        onGetSync: Hooks.getSyncHook(),\n        onNew: Hooks.getAsyncHook(),\n        onRemove: Hooks.getSyncHook(),\n    },\n    paint: {\n        onAddToRGBUpdate: Hooks.getSyncHook(),\n        onRichVoxelPaint: Hooks.getSyncHook(),\n    },\n    settingsSynced: Hooks.getSyncHook(),\n};\n","import { DimensionsRegister } from \"./World/Dimensions/DimensionsRegister.js\";\nimport { MappedDataRegister } from \"./Register/MappedDataRegister.js\";\nimport { VoxelTags } from \"./Voxel/VoxelTags.js\";\nimport { WorldBounds } from \"./World/WorldBounds.js\";\nimport { WorldPainter } from \"./World/WorldPainter.js\";\nimport { WorldRegister } from \"./World/WorldRegister.js\";\nimport { ChunkTags } from \"./World/Chunk/ChunkTags.js\";\nimport { ColumnTags } from \"./World/Column/ColumnTags.js\";\nimport { RegionTags } from \"./World/Region/RegionTags.js\";\nimport { WorldSpaces } from \"./World/WorldSpaces.js\";\nimport { RegionHeaderRegister } from \"./World/Region/RegionHeaderRegister.js\";\nimport { SubstanceTags } from \"./Substance/SubstanceTags.js\";\nexport const DataManager = {\n    world: WorldPainter,\n    worldBounds: WorldBounds,\n    spaces: WorldSpaces,\n    registers: {\n        dimensions: DimensionsRegister,\n        world: WorldRegister,\n        mapped: MappedDataRegister,\n        regionHeader: RegionHeaderRegister,\n    },\n    tags: {\n        voxels: VoxelTags,\n        substances: SubstanceTags,\n        chunks: ChunkTags,\n        column: ColumnTags,\n        region: RegionTags,\n    },\n};\n","/**# Light Byte\n * ---\n * Used to decode light color info.\n */\nexport const LightData = {\n    SRS: 2,\n    _lightValues: [0, 0, 0, 0],\n    getS(value) {\n        return value & 0xf;\n    },\n    getR(value) {\n        return (value & (0xf << 4)) >> 4;\n    },\n    getG(value) {\n        return (value & (0xf << 8)) >> 8;\n    },\n    getB(value) {\n        return (value & (0xf << 12)) >> 12;\n    },\n    setS(value, sl) {\n        return (sl & ~0xf) | value;\n    },\n    setR(value, sl) {\n        return (sl & ~(0xf << 4)) | (value << 4);\n    },\n    setG(value, sl) {\n        return (sl & ~(0xf << 8)) | (value << 8);\n    },\n    setB(value, sl) {\n        return (sl & ~(0xf << 12)) | (value << 12);\n    },\n    removeS(sl) {\n        return this.setS(0, sl);\n    },\n    hasRGBLight(sl) {\n        if (sl <= 0)\n            return false;\n        if (this.getR(sl) > 0)\n            return true;\n        if (this.getG(sl) > 0)\n            return true;\n        if (this.getB(sl) > 0)\n            return true;\n        return false;\n    },\n    hasSunLight(sl) {\n        if (sl <= 0)\n            return false;\n        if (this.getS(sl) > 0)\n            return true;\n        return false;\n    },\n    mixLight(l1, l2) {\n        const s1 = this.getS(l1);\n        const s2 = this.getS(l2);\n        const s = s1 < s2 ? s2 : s1;\n        const r1 = this.getR(l1);\n        const r2 = this.getR(l2);\n        const r = r1 < r2 ? r2 : r1;\n        const g1 = this.getG(l1);\n        const g2 = this.getG(l2);\n        const g = g1 < g2 ? g2 : g1;\n        const b1 = this.getB(l1);\n        const b2 = this.getB(l2);\n        const b = b1 < b2 ? b2 : b1;\n        let nl = this.setS(s, 0);\n        nl = this.setR(r, nl);\n        nl = this.setG(g, nl);\n        nl = this.setB(b, nl);\n        return nl;\n    },\n    getRGB(sl) {\n        if (sl < 0)\n            return 0;\n        return (sl & 0xfff0) >> 4;\n    },\n    setRGB(value, sl) {\n        if (sl < 0)\n            return 0;\n        return (sl & ~0xfff0) | (value << 4);\n    },\n    decodeLightFromVoxelData(voxelData) {\n        return (voxelData & (0xffff << 0)) >> 0;\n    },\n    encodeLightIntoVoxelData(voxelData, encodedLight) {\n        return (voxelData & ~(0xffff << 0)) | (encodedLight << 0);\n    },\n    /**# Set Light Values\n     * ---\n     * Give an array of light values it will return an encoded light number.\n     * @param values\n     */\n    setLightValues(values) {\n        let value = this.setS(values[0], 0);\n        value = this.setR(values[1], value);\n        value = this.setG(values[2], value);\n        return this.setB(values[3], value);\n    },\n    /**# Get Light Values\n     * ---\n     * Given an encoded light number it will return an array of its values.\n     * - 0: Sun Light\n     * - 1: Red Light\n     * - 2: Green Light\n     * - 3: Blue Light\n     * @param value\n     */\n    getLightValues(value) {\n        this._lightValues[0] = this.getS(value);\n        this._lightValues[1] = this.getR(value);\n        this._lightValues[2] = this.getG(value);\n        this._lightValues[3] = this.getB(value);\n        return this._lightValues;\n    },\n    /**# Is Less Than For RGB Remove\n     * ---\n     * Compares values for the RGB encoded light values.\n     * Used for RGB light remove.\n     * @param n1\n     * @param n2\n     */\n    isLessThanForRGBRemove(n1, n2) {\n        let r1 = this.getR(n1);\n        let g1 = this.getG(n1);\n        let b1 = this.getB(n1);\n        let r2 = this.getR(n2);\n        let g2 = this.getG(n2);\n        let b2 = this.getB(n2);\n        return r1 < r2 || g1 < g2 || b1 < b2;\n    },\n    /**# Is Less Than For RGB Add\n     * ---\n     * Compares values for the RGB encoded light values.\n     * Used for RGB light add.\n     * @param n1\n     * @param n2\n     */\n    isLessThanForRGBAdd(n1, n2) {\n        let r1 = this.getR(n1) + 2;\n        let g1 = this.getG(n1) + 2;\n        let b1 = this.getB(n1) + 2;\n        let r2 = this.getR(n2);\n        let g2 = this.getG(n2);\n        let b2 = this.getB(n2);\n        return r1 <= r2 || g1 <= g2 || b1 <= b2;\n    },\n    /**# Is Greater Or Equal Than For RGB Remove\n     * ---\n     * Compares values for the RGB encoded light values.\n     * Used for RGB light remove.\n     * @param n1\n     * @param n2\n     */\n    isGreaterOrEqualThanForRGBRemove(n1, n2) {\n        let r1 = this.getR(n1);\n        let g1 = this.getG(n1);\n        let b1 = this.getB(n1);\n        let r2 = this.getR(n2);\n        let g2 = this.getG(n2);\n        let b2 = this.getB(n2);\n        return r1 >= r2 || g1 >= g2 || b1 >= b2;\n    },\n    /**# Get Minus One For RGB\n     * ---\n     * Returns the RGB light values minus one.\n     * @param sl - source light value\n     */\n    getMinusOneForRGB(sl, nl) {\n        let s = this.getS(nl);\n        let r = this.getR(sl) - 1;\n        if (r < 0)\n            r = 0;\n        let rn = this.getR(nl);\n        if (r < rn) {\n            r = rn;\n        }\n        let g = this.getG(sl) - 1;\n        if (g < 0)\n            g = 0;\n        let gn = this.getG(nl);\n        if (g < gn) {\n            g = gn;\n        }\n        let b = this.getB(sl) - 1;\n        if (b < 0)\n            b = 0;\n        let bn = this.getB(nl);\n        if (b < bn) {\n            b = bn;\n        }\n        let bv = 0;\n        bv = this.setS(s, bv);\n        bv = this.setR(r, bv);\n        bv = this.setG(g, bv);\n        bv = this.setB(b, bv);\n        return bv;\n    },\n    /**# Remove RGB Light\n     * ---\n     * Removes all RGB light from an encoded light value.\n     * @param sl - source light value\n     */\n    removeRGBLight(sl) {\n        let s = this.getS(sl);\n        let bv = 0;\n        bv = this.setR(0, bv);\n        bv = this.setG(0, bv);\n        bv = this.setB(0, bv);\n        bv = this.setS(s, bv);\n        return bv;\n    },\n    /**# Get Full Sun Light\n     * --\n     * Alters the encoded light number passed to it to give it full sun light.\n     * @param sl - source light value\n     */\n    getFullSunLight(sl) {\n        return sl | 0b1111;\n    },\n    /**# Is Less Than For Sun Add\n     * ---\n     * Used to calculate sun light addition.\n     * Used to check all neighbors expect down.\n     * @param n1\n     * @param n2\n     */\n    isLessThanForSunAdd(n1, n2) {\n        let sl1 = this.getS(n1);\n        let sl2 = this.getS(n2);\n        return sl1 + this.SRS < sl2;\n    },\n    /**# Is Less Than For Sun Add Down\n     *\n     * Used to calculate sun light addition.\n     * Used to check only the down neighbor.\n     * @param n1\n     * @param n2\n     */\n    isLessThanForSunAddDown(n1, n2) {\n        let sl1 = this.getS(n1);\n        let sl2 = this.getS(n2);\n        if (sl2 == 0xf) {\n            return sl1 < sl2;\n        }\n        return sl1 + this.SRS < sl2;\n    },\n    isLessThanForSunAddUp(n1, n2) {\n        let sl1 = this.getS(n1);\n        let sl2 = this.getS(n2);\n        if (sl1 == sl2)\n            return false;\n        if (sl2 == 0xf || sl1 == 0xf)\n            return false;\n        return sl1 + this.SRS < sl2;\n    },\n    /**# Get Sun Light For Under Voxel\n     * ---\n     * Gets the sun light value for sun light addition when setting the\n     * down neighbor.\n     * @param currentVoxel\n     */\n    getSunLightForUnderVoxel(sl, nl) {\n        let s = this.getS(sl);\n        let sn = this.getS(nl);\n        if (s == 15) {\n            sn = s;\n        }\n        if (s < 15) {\n            sn = s - this.SRS;\n        }\n        let r = this.getR(nl);\n        let g = this.getG(nl);\n        let b = this.getB(nl);\n        let bv = 0;\n        bv = this.setS(sn, bv);\n        bv = this.setR(r, bv);\n        bv = this.setG(g, bv);\n        bv = this.setB(b, bv);\n        return bv;\n    },\n    /**# Get Minus One For Sun\n     * ---\n     * Returns the sun light level passed to it minus one.\n     * Used for sun light addition on all neighbors expect the down one.\n     * @param sl - source light value\n     */\n    getMinusOneForSun(sl, nl) {\n        let s = this.getS(sl) - this.SRS;\n        if (s < 0)\n            s = 0;\n        let sn = this.getS(nl);\n        if (s < sn) {\n            s = sn;\n        }\n        let r = this.getR(nl);\n        let g = this.getG(nl);\n        let b = this.getB(nl);\n        let bv = 0;\n        bv = this.setS(s, bv);\n        bv = this.setR(r, bv);\n        bv = this.setG(g, bv);\n        bv = this.setB(b, bv);\n        return bv;\n    },\n    /**# Is Less Than For Sun Remove\n     * ---\n     * Compares two encoded light values sun light values.\n     * Used for sun light removal.\n     * @param n1\n     * @param sl - source light value\n     */\n    isLessThanForSunRemove(n1, sl) {\n        let s1 = this.getS(n1);\n        let s2 = this.getS(sl);\n        return s1 < s2;\n    },\n    /**# Is Greater Or Equal Than For Sun Remove\n     * ---\n     * Compares two encoded light values sun light values.\n     * Used for sun light removal.\n     * @param n1\n     * @param sl - source light value\n     */\n    isGreaterOrEqualThanForSunRemove(n1, sl) {\n        let s1 = this.getS(n1);\n        let s2 = this.getS(sl);\n        return s1 >= s2;\n    },\n    /**# Sun Light Compare For Down Sun Remove\n     * ---\n     * Compares two encoded light values sun light values.\n     * Used for sun light removal in the downward direction only.\n     * @param n1\n     * @param sl - source light value\n     */\n    sunLightCompareForDownSunRemove(n1, sl) {\n        let s2 = this.getS(sl);\n        if (s2 == 0xf)\n            return true;\n        let s1 = this.getS(n1);\n        return s1 < s2;\n    },\n    /**# Remove Sun Light\n     * ---\n     * Removes the sun light from a light encoded value.\n     * @param sl - source light value\n     */\n    removeSunLight(sl) {\n        return this.removeS(sl);\n    },\n    minusOneForAll(sl) {\n        let s = this.getS(sl) - this.SRS;\n        let r = this.getR(sl) - 1;\n        let g = this.getG(sl) - 1;\n        let b = this.getB(sl) - 1;\n        if (s < 0)\n            s = 0;\n        if (r < 0)\n            r = 0;\n        if (g < 0)\n            g = 0;\n        if (b < 0)\n            b = 0;\n        let nl = this.setS(s, 0);\n        nl = this.setR(r, nl);\n        nl = this.setG(g, nl);\n        nl = this.setB(b, nl);\n        return nl;\n    },\n};\n","export const MappedDataRegister = {\n    stringMaps: {\n        segments: new Map(),\n        sync(data) {\n            const [segment, id, value] = data;\n            let segmentMap = this.segments.get(segment);\n            if (!segmentMap) {\n                segmentMap = new Map();\n                this.segments.set(segment, segmentMap);\n            }\n            segmentMap.set(id, value);\n            return;\n        },\n        get(segment, id, index) {\n            const segmentMap = this.segments.get(segment);\n            if (!segmentMap)\n                return \"\";\n            const stringMap = segmentMap.get(id);\n            if (!stringMap) {\n                return \"\";\n            }\n            return stringMap[index];\n        },\n    },\n    objectMaps: {\n        segments: new Map(),\n        sync(data) {\n            const [segment, id, value] = data;\n            let segmentMap = this.segments.get(segment);\n            if (!segmentMap) {\n                segmentMap = new Map();\n                this.segments.set(segment, segmentMap);\n            }\n            segmentMap.set(id, value);\n            return;\n        },\n        get(segment, id, index) {\n            const segmentMap = this.segments.get(segment);\n            if (!segmentMap)\n                return null;\n            const objectMap = segmentMap.get(id);\n            if (!objectMap) {\n                return null;\n            }\n            return objectMap[index];\n        },\n    },\n};\nMappedDataRegister.stringMaps.segments.set(\"voxel\", new Map());\nMappedDataRegister.stringMaps.segments.set(\"substance\", new Map());\nMappedDataRegister.objectMaps.segments.set(\"substance\", new Map());\n","import { Util } from \"../../Global/Util.helper.js\";\nimport { WorldBounds } from \"../World/WorldBounds.js\";\nimport { WorldSpaces } from \"../World/WorldSpaces.js\";\n/**# Engine Settings\n * ---\n * Handles common settings for all contexts\n */\nexport const EngineSettings = {\n    enviorment: Util.getEnviorment(),\n    //context: <EngineSettingsContext>\"MatrixLoadedThread\",\n    settings: {\n        nexus: {\n            enabled: false,\n            autoSyncChunks: true,\n            autoSyncVoxelPalette: true,\n        },\n        data: {\n            enabled: false,\n            autoSyncChunks: true,\n            mode: \"server\",\n        },\n        fx: {\n            enabled: false,\n            autoSyncChunks: true,\n            autoSyncVoxelPalette: true,\n        },\n        server: {\n            enabled: false,\n        },\n        richWorld: {\n            enabled: false,\n            autoSyncChunks: true,\n            autoSyncVoxelPalette: true,\n        },\n        textures: {\n            animationTime: 20,\n            textureSize: 16,\n            mipMapSizes: [16, 12, 8, 4],\n        },\n        updating: {\n            autoRebuild: true,\n        },\n        world: {\n            maxX: Infinity,\n            minX: -Infinity,\n            maxZ: Infinity,\n            minZ: -Infinity,\n            maxY: 256,\n            minY: 0,\n        },\n        regions: {\n            regionXPow2: 9,\n            regionYPow2: 8,\n            regionZPow2: 9,\n        },\n        chunks: {\n            autoHeightMap: true,\n            chunkXPow2: 4,\n            chunkYPow2: 4,\n            chunkZPow2: 4,\n        },\n        voxels: {\n            doColors: true,\n        },\n        flow: {\n            enable: true,\n            baseFlowLimit: 100\n        },\n        lighting: {\n            doAO: true,\n            doSunLight: true,\n            doRGBLight: true,\n            autoRGBLight: true,\n            autoSunLight: true,\n        },\n        meshes: {\n            clearChachedGeometry: true,\n            checkMagmaCollisions: false,\n            checkLiquidCollisions: false,\n            checkFloraCollisions: false,\n            checkSolidCollisions: false,\n            seralize: false,\n            pickable: false,\n        },\n        materials: {\n            mode: \"classic\",\n            doAO: true,\n            doSunLight: true,\n            doRGBLight: true,\n            disableFloraShaderEffects: false,\n            disableLiquidShaderEffects: false,\n        },\n    },\n    getSettings() {\n        return this.settings;\n    },\n    syncSettings(data) {\n        //safetly set data without prototype pollution\n        for (const settingsKey of Object.keys(data)) {\n            if (settingsKey.includes(\"__\")) {\n                throw new Error(\"Can not include properties with multpile underscores.\");\n            }\n            if (this.settings[settingsKey] !== undefined) {\n                for (const propertyKey of Object.keys(data[settingsKey])) {\n                    if (propertyKey.includes(\"__\")) {\n                        throw new Error(\"Can not include properties with multpile underscores.\");\n                    }\n                    if (this.settings[settingsKey][propertyKey] !== undefined) {\n                        //@ts-ignore\n                        this.settings[settingsKey][propertyKey] = data[settingsKey][propertyKey];\n                    }\n                }\n            }\n        }\n        this.__syncWithObjects();\n    },\n    __syncWithObjects() {\n        WorldSpaces.$INIT(this.settings);\n        if (this.settings.world) {\n            WorldBounds.setWorldBounds(this.settings.world.minX, this.settings.world.maxX, this.settings.world.minZ, this.settings.world.maxZ, this.settings.world.minY, this.settings.world.maxY);\n        }\n    },\n    syncWithWorldBounds(worldBounds) { },\n    getSettingsCopy() {\n        return JSON.parse(JSON.stringify(this.settings));\n    },\n    syncChunkInRichWorldThread() {\n        return (this.settings.richWorld.enabled && this.settings.richWorld.autoSyncChunks);\n    },\n    richDataEnabled() {\n        return this.settings.richWorld.enabled;\n    },\n    syncChunkInFXThread() {\n        return this.settings.fx.enabled && this.settings.fx.autoSyncChunks;\n    },\n    syncChunkInDataThread() {\n        return this.settings.data.enabled && this.settings.data.autoSyncChunks;\n    },\n    syncChunksInNexusThread() {\n        return this.settings.nexus.enabled && this.settings.nexus.autoSyncChunks;\n    },\n    doSunPropagation() {\n        return this.settings.lighting.autoSunLight == true;\n    },\n    doRGBPropagation() {\n        return this.settings.lighting.autoRGBLight == true;\n    },\n    doLight() {\n        return this.doRGBPropagation() || this.doSunPropagation();\n    },\n    doFlow() {\n        return this.settings.flow.enable;\n    },\n    saveWorldData() {\n        return this.settings.data.enabled;\n    },\n    isServer() {\n        return this.settings.server.enabled && this.enviorment == \"node\";\n    },\n    isClient() {\n        return this.enviorment != \"browser\";\n    },\n};\n","export const SubstancePaletteReader = {\n    _palette: [],\n    _map: new Map(),\n    setPalette(palette, map) {\n        this._palette = palette;\n        this._map = new Map(Object.entries(map));\n    },\n    id: {\n        stringFromNumber(id) {\n            return SubstancePaletteReader._palette[id];\n        },\n        numberFromString(id) {\n            return SubstancePaletteReader._map.get(id);\n        },\n    },\n};\n","import { RemoteTagManager } from \"divine-binary-tags\";\nimport { SubstancePaletteReader } from \"./SubstancePalette.js\";\nclass SDTags extends RemoteTagManager {\n    id;\n    constructor(id) {\n        super(id);\n        this.id = id;\n    }\n    setSubstance(id) {\n        this.setTagIndex(typeof id == \"string\" ? SubstancePaletteReader.id.numberFromString(id) : id);\n    }\n}\nexport const SubstanceTags = new SDTags(\"substance-data\");\n","export const VoxelPaletteReader = {\n    _palette: [\"dve_air\", \"dve_barrier\"],\n    _map: new Map(),\n    setVoxelPalette(voxelPalette, voxelPaletteMap) {\n        this._palette = voxelPalette;\n        this._map = new Map(Object.entries(voxelPaletteMap));\n    },\n    id: {\n        stringFromNumber(id) {\n            return VoxelPaletteReader._palette[id];\n        },\n        numberFromString(id) {\n            return VoxelPaletteReader._map.get(id);\n        },\n        getPaletteId(voxelId, voxelState) {\n            const numericID = VoxelPaletteReader._map.get(voxelId);\n            if (numericID == undefined)\n                return -1;\n            const stateId = voxelState + numericID;\n            if (VoxelPaletteReader._palette[stateId] != voxelId) {\n                throw new Error(`${voxelState} is not a valid state for voxel with id : ${voxelId}`);\n            }\n            if (stateId) {\n                return stateId;\n            }\n            return -1;\n        },\n        baseNumeric(id) {\n            if (id < 2)\n                return id;\n            const vid = this.numberFromString(this.stringFromNumber(id));\n            if (!vid)\n                return -1;\n            return vid;\n        },\n    },\n};\n","const voxelStateMasks = {\n    level: 0b00_1111,\n    levelState: 0b11_0000,\n    shapeState: 0b1111_1111_11_00_0000,\n};\n/**# Voxel Byte\n * ---\n * Used to decode voxel data.\n */\nexport const VoxelReader = {\n    getLevel(stateData) {\n        return stateData & voxelStateMasks.level;\n    },\n    setLevel(stateData, level) {\n        return (stateData & ~voxelStateMasks.level) | level;\n    },\n    getLevelState(stateData) {\n        return (stateData & voxelStateMasks.levelState) >> 4;\n    },\n    setLevelState(stateData, levelState) {\n        return (stateData & ~voxelStateMasks.levelState) | (levelState << 4);\n    },\n    getShapeState(voxelData) {\n        return (voxelData & voxelStateMasks.shapeState) >> 6;\n    },\n    setShapeState(voxelData, shapeState) {\n        return (voxelData & ~voxelStateMasks.shapeState) | (shapeState << 6);\n    },\n};\n","import { RemoteTagManager } from \"divine-binary-tags\";\nclass VDTags extends RemoteTagManager {\n    id;\n    voxelIndex = new Uint16Array();\n    constructor(id) {\n        super(id);\n        this.id = id;\n    }\n    sync(voxelMap) {\n        this.voxelIndex = voxelMap;\n    }\n    setVoxel(id) {\n        const index = this.voxelIndex[id];\n        this.setTagIndex(index);\n    }\n}\nexport const VoxelTags = new VDTags(\"voxel-data\");\n","import { RemoteTagManager } from \"divine-binary-tags\";\nexport const ChunkTags = new RemoteTagManager(\"chunk-tags\");\n","import { RemoteTagManager } from \"divine-binary-tags\";\nexport const ColumnTags = new RemoteTagManager(\"column-tags\");\n","import { DataHooks } from \"../../DataHooks.js\";\nimport { WorldRegister } from \"../WorldRegister.js\";\nexport const DimensionsRegister = {\n    _count: 1,\n    dimensionRecord: {\n        main: 0,\n    },\n    dimensionMap: {\n        0: \"main\",\n    },\n    __defaultDimensionOptions: {\n        liquidFlowSpeed: 0.1,\n        magmaFlowSpeed: 0.1,\n        sunLight: true,\n    },\n    _dimensions: {},\n    registerDimension(id, option) {\n        if (!option) {\n            option = this.__defaultDimensionOptions;\n        }\n        const dimensionData = {\n            id: id,\n            options: option,\n        };\n        this._dimensions[id] = dimensionData;\n        this.dimensionRecord[id] = this._count;\n        this.dimensionMap[this._count] = id;\n        DataHooks.dimension.onRegisterDimension.run(dimensionData);\n        WorldRegister.dimensions.add(id);\n    },\n    getDimension(id) {\n        id = this.getDimensionStringId(id);\n        return this._dimensions[id];\n    },\n    getDimensionStringId(id) {\n        if (typeof id == \"number\") {\n            return this.dimensionMap[id];\n        }\n        return id;\n    },\n    getDimensionNumericId(id) {\n        if (typeof id == \"string\") {\n            return this.dimensionRecord[id];\n        }\n        return id;\n    },\n};\n","import { WorldSpaces } from \"../WorldSpaces.js\";\nimport { RegionHeaderTags } from \"./RegionTags.js\";\nexport const RegionHeaderRegister = {\n    _headers: new Map(),\n    remove(location) {\n        const [dimensionId, x, y, z] = location;\n        const dimension = this._headers.get(dimensionId);\n        if (!dimension)\n            return false;\n        const regionKey = WorldSpaces.region.getKeyXYZ(x, y, z);\n        return dimension.delete(regionKey);\n    },\n    add(location, buffer) {\n        const [dimensionId, x, y, z] = location;\n        let dimension = this._headers.get(dimensionId);\n        if (!dimension) {\n            dimension = new Map();\n            this._headers.set(dimensionId, dimension);\n        }\n        const regionKey = WorldSpaces.region.getKeyXYZ(x, y, z);\n        dimension.set(regionKey, {\n            buffer: buffer,\n            data: new DataView(buffer),\n        });\n    },\n    get(location) {\n        const [dimensionId, x, y, z] = location;\n        let dimension = this._headers.get(dimensionId);\n        if (!dimension)\n            return false;\n        return dimension.get(WorldSpaces.region.getKeyXYZ(x, y, z));\n    },\n    /**# isStored\n     * @param location\n     * @returns\n     *\n     * Returns 1 if stored\n     *\n     * Returns 0 if not stored\n     *\n     * Returns -1 if region header is not loaded\n     *\n     */\n    isStored(location) {\n        const header = this.get(location);\n        if (!header)\n            return -1;\n        RegionHeaderTags.setBuffer(header.data);\n        const columnIndex = WorldSpaces.column.getIndexXYZ(location[1], location[2], location[3]);\n        return RegionHeaderTags.getArrayTagValue(\"#dved-column-save-timestamp\", columnIndex) != 0\n            ? 1\n            : 0;\n    },\n};\n","import { RemoteTagManager } from \"divine-binary-tags\";\nexport const RegionTags = new RemoteTagManager(\"region-tags\");\nexport const RegionHeaderTags = new RemoteTagManager(\"region-header-tags\");\n","export const WorldBounds = {\n    bounds: {\n        MinZ: -Infinity,\n        MaxZ: Infinity,\n        MinX: -Infinity,\n        MaxX: Infinity,\n        MinY: 0,\n        MaxY: 256,\n    },\n    setWorldBounds(minX, maxX, minZ, maxZ, minY, maxY) {\n        this.bounds.MinX = minX;\n        this.bounds.MaxX = maxX;\n        this.bounds.MinX = minZ;\n        this.bounds.MaxZ = maxZ;\n        this.bounds.MinY = minY;\n        this.bounds.MaxY = maxY;\n    },\n};\n","import { WorldRegister } from \"./WorldRegister.js\";\nimport { DataHooks } from \"../DataHooks.js\";\nimport { VoxelPaletteReader } from \"../Voxel/VoxelPalette.js\";\nimport { DataTool } from \"../../Tools/Data/DataTool.js\";\nconst WP = {\n    _currentionDimension: \"main\",\n    paint: {\n        _dt: new DataTool(),\n        voxel(location, data, update = true) {\n            if (!location[0]) {\n                location[0] = WP._currentionDimension;\n            }\n            let chunk = WorldRegister.chunk.get(location);\n            if (!chunk) {\n                let buffer = DataHooks.chunk.onGetSync.run(location);\n                if (!buffer)\n                    return;\n                chunk = WorldRegister.chunk.add(location, buffer);\n            }\n            this.__paint(location, data, update);\n        },\n        __paint(location, data, update = true) {\n            this._dt.setLocation(location);\n            if (!this._dt.setLocation(location).loadIn())\n                return;\n            const id = VoxelPaletteReader.id.getPaletteId(data.id, data.state ? data.state : 0);\n            if (id < 0)\n                return false;\n            this._dt.setId(id);\n            this._dt.setShapeState(data.shapeState ? data.shapeState : 0);\n            if (this._dt.getSubstnaceData().isLiquid()) {\n                this._dt.setLevel(15);\n            }\n            if (data.secondaryVoxelId && data.secondaryVoxelId != \"dve_air\") {\n                const vid = VoxelPaletteReader.id.getPaletteId(data.secondaryVoxelId, data.secondaryState ? data.secondaryState : 0);\n                if (vid > 0) {\n                    this._dt.setSecondary(true);\n                    this._dt.setId(vid);\n                    this._dt.setSecondary(false);\n                }\n            }\n            if (this._dt.isLightSource() && this._dt.getLightSourceValue()) {\n                this._dt.setLight(this._dt.getLightSourceValue());\n                if (update) {\n                    DataHooks.paint.onAddToRGBUpdate.run(location);\n                }\n            }\n            if (this._dt.isRich()) {\n                DataHooks.paint.onRichVoxelPaint.run([this._dt.getStringId(), location]);\n            }\n            this._dt.commit(1);\n        },\n        erase(location) {\n            this._dt.setLocation(location);\n            if (!this._dt.loadIn())\n                return;\n            if (!this._dt.isRenderable())\n                return;\n            this._dt\n                .setLight(0)\n                .setLevel(0)\n                .setLevelState(0)\n                .setShapeState(0)\n                .setAir()\n                .commit(2);\n        },\n    },\n};\nexport const WorldPainter = WP;\n","import { DataHooks } from \"../../Data/DataHooks.js\";\nimport { WorldBounds } from \"./WorldBounds.js\";\nimport { DimensionsRegister } from \"./Dimensions/DimensionsRegister.js\";\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\nimport { ColumnDataTool } from \"../../Tools/Data/WorldData/ColumnDataTool.js\";\nimport { RegionDataTool } from \"../../Tools/Data/WorldData/RegionDataTool.js\";\nimport { WorldSpaces } from \"./WorldSpaces.js\";\nconst chunkTool = new ChunkDataTool();\nconst columnTool = new ColumnDataTool();\nconst regionTool = new RegionDataTool();\nexport const WorldRegister = {\n    _dimensions: new Map(),\n    _cacheOn: false,\n    _chunkCache: new Map(),\n    _columnCache: new Map(),\n    cache: {\n        enable() {\n            WorldRegister._cacheOn = true;\n            WorldRegister._chunkCache.clear();\n            WorldRegister._columnCache.clear();\n        },\n        disable() {\n            WorldRegister._cacheOn = false;\n            WorldRegister._chunkCache.clear();\n            WorldRegister._columnCache.clear();\n        },\n        _addChunk(key, data) {\n            WorldRegister._chunkCache.set(key, data);\n        },\n        _addColumn(key, data) {\n            WorldRegister._columnCache.set(key, data);\n        },\n        _getChunk(key) {\n            return WorldRegister._chunkCache.get(key);\n        },\n        _getColumn(key) {\n            return WorldRegister._columnCache.get(key);\n        },\n    },\n    dimensions: {\n        add(id) {\n            const dimesnion = new Map();\n            id = DimensionsRegister.getDimensionStringId(id);\n            WorldRegister._dimensions.set(id, dimesnion);\n            return dimesnion;\n        },\n        get(id) {\n            id = DimensionsRegister.getDimensionStringId(id);\n            return WorldRegister._dimensions.get(id);\n        },\n    },\n    region: {\n        add(location, sab) {\n            let dimension = WorldRegister.dimensions.get(location[0]);\n            if (!dimension) {\n                dimension = WorldRegister.dimensions.add(location[0]);\n            }\n            const region = this._getRegionData(sab);\n            const regionPOS = WorldSpaces.region.getPositionLocation(location);\n            regionTool.setRegion(region);\n            regionTool.setPositionData(regionPOS.x, regionPOS.y, regionPOS.z);\n            regionTool.setDimensionId(location[0]);\n            dimension.set(WorldSpaces.region.getKey(), region);\n            return region;\n        },\n        _getRegionData(sab) {\n            return {\n                columns: new Map(),\n                buffer: sab,\n                data: new DataView(sab),\n            };\n        },\n        get(location) {\n            const dimension = WorldRegister.dimensions.get(location[0]);\n            if (!dimension)\n                return false;\n            const region = dimension.get(WorldSpaces.region.getKeyLocation(location));\n            if (!region)\n                return false;\n            return region;\n        },\n        remove(location) {\n            const dimension = WorldRegister.dimensions.get(location[0]);\n            if (!dimension)\n                return false;\n            const key = WorldSpaces.region.getKeyLocation(location);\n            const region = dimension.get(key);\n            if (!region)\n                return false;\n            dimension.delete(key);\n            return true;\n        },\n    },\n    column: {\n        add(location, sab) {\n            let region = WorldRegister.region.get(location);\n            if (!region) {\n                let buffer = DataHooks.region.onGetSync.run(location);\n                if (!buffer)\n                    return;\n                region = WorldRegister.region.add(location, buffer);\n                DataHooks.region.onNew.run(location);\n            }\n            const column = this._getColumnData(sab);\n            const columnPOS = WorldSpaces.column.getPositionLocation(location);\n            columnTool.setColumn(column);\n            columnTool.setPositionData(columnPOS.x, columnPOS.y, columnPOS.z);\n            columnTool.setDimensionId(location[0]);\n            region.columns.set(WorldSpaces.column.getIndex(), column);\n            return column;\n        },\n        _getColumnData(sab) {\n            return {\n                chunks: new Map(),\n                buffer: sab,\n                data: new DataView(sab),\n            };\n        },\n        get(location) {\n            const columnKey = WorldSpaces.column.getKeyLocation(location);\n            let addColumn = false;\n            if (WorldRegister._cacheOn) {\n                const column = WorldRegister.cache._getColumn(columnKey);\n                if (column)\n                    return column;\n                addColumn = true;\n            }\n            const region = WorldRegister.region.get(location);\n            if (!region)\n                return false;\n            const column = region.columns.get(WorldSpaces.column.getIndexLocation(location));\n            if (!column)\n                return false;\n            if (addColumn) {\n                WorldRegister.cache._addColumn(columnKey, column);\n            }\n            return column;\n        },\n        remove(location) {\n            const region = WorldRegister.region.get(location);\n            if (!region)\n                return false;\n            const index = WorldSpaces.column.getIndexLocation(location);\n            const column = region.columns.get(index);\n            if (!column)\n                return false;\n            region.columns.delete(index);\n            return true;\n        },\n        fill(location) {\n            for (let cy = WorldBounds.bounds.MinY; cy < WorldBounds.bounds.MaxY; cy += WorldSpaces.chunk._bounds.y) {\n                location[2] = cy;\n                if (!WorldRegister.chunk.get(location)) {\n                    const chunk = DataHooks.chunk.onGetSync.run(location);\n                    if (!chunk)\n                        continue;\n                    WorldRegister.chunk.add(location, chunk);\n                }\n            }\n        },\n        /*   height: {\n           getRelative(location: LocationData) {\n            location = [...location];\n            const chunkWidth = WorldSpaces.chunk._bounds.x;\n            const chunkDepth = WorldSpaces.chunk._bounds.z;\n            let maxHeight = -Infinity;\n            const [dimension, x, y, z] = location;\n            for (const check of $2dMooreNeighborhood) {\n             location[1] = check[0] * chunkWidth + x;\n             location[3] = check[1] * chunkDepth + z;\n             const height = this.getAbsolute(location);\n             if (height > maxHeight) {\n              maxHeight = height;\n             }\n            }\n            return maxHeight;\n           },\n           getAbsolute(location: LocationData) {\n            const column = WorldRegister.column.get(location);\n            if (!column) return WorldBounds.bounds.MinY;\n            if (column.chunks.size == 0) return WorldBounds.bounds.MinY;\n            let maxHeight = WorldBounds.bounds.MinY;\n            for (const [key, chunk] of column.chunks) {\n             if (!chunk) continue;\n        \n             chunkTool.setChunk(chunk);\n             const chunkPOS = chunkTool.getPositionData();\n             let chunkMax = chunkTool.getTagValue(\"#dve_max_height\");\n             if (chunkMax == 0) continue;\n             chunkMax += chunkPOS.y;\n             if (maxHeight < chunkMax) {\n              maxHeight = chunkMax;\n             }\n            }\n            return maxHeight + 1;\n           },\n          }, */\n    },\n    chunk: {\n        add(location, sab) {\n            let column = WorldRegister.column.get(location);\n            if (!column) {\n                let buffer = DataHooks.column.onGetSync.run(location);\n                if (!buffer)\n                    return;\n                column = WorldRegister.column.add(location, buffer);\n                DataHooks.column.onNew.run(location);\n            }\n            if (!column)\n                return;\n            const chunk = this._getChunkData(sab);\n            chunkTool.setChunk(chunk);\n            const chunkPOS = WorldSpaces.chunk.getPositionLocation(location);\n            chunkTool.setPositionData(chunkPOS.x, chunkPOS.y, chunkPOS.z);\n            chunkTool.setDimensionId(location[0]);\n            column.chunks.set(WorldSpaces.chunk.getIndex(), chunk);\n            DataHooks.chunk.onNew.run(location);\n            return chunk;\n        },\n        _getChunkData(sab) {\n            return {\n                buffer: sab,\n                data: new DataView(sab),\n            };\n        },\n        addFromServer(location, chunkBuffer) {\n            const sab = new SharedArrayBuffer(chunkBuffer.byteLength);\n            const temp = new Uint8Array(chunkBuffer);\n            const temp2 = new Uint8Array(sab);\n            temp2.set(temp, 0);\n            const chunk = this._getChunkData(sab);\n            chunkTool.setChunk(chunk);\n            let column = WorldRegister.column.get(location);\n            if (!column)\n                return;\n            column.chunks.set(WorldSpaces.chunk.getIndexLocation(location), chunk);\n            DataHooks.chunk.onNew.run(location);\n            return chunk;\n        },\n        get(location) {\n            const chunkKey = WorldSpaces.chunk.getKeyLocation(location);\n            let addChunk = false;\n            if (WorldRegister._cacheOn) {\n                const chunk = WorldRegister.cache._getChunk(chunkKey);\n                if (chunk)\n                    return chunk;\n                addChunk = true;\n            }\n            const column = WorldRegister.column.get(location);\n            if (!column)\n                return false;\n            const chunk = column.chunks.get(WorldSpaces.chunk.getIndex());\n            if (!chunk)\n                return;\n            if (addChunk) {\n                WorldRegister.cache._addChunk(chunkKey, chunk);\n            }\n            return chunk;\n        },\n        remove(location) {\n            const column = WorldRegister.column.get(location);\n            if (!column)\n                return false;\n            const index = WorldSpaces.chunk.getIndexLocation(location);\n            const chunk = column.chunks.get(index);\n            if (!chunk)\n                return false;\n            column.chunks.delete(index);\n            return true;\n        },\n    },\n};\n","//types\nimport { VoxelSpaces } from \"voxelspaces\";\n//Objects\nimport { Util } from \"../../Global/Util.helper.js\";\nexport const WorldSpaces = Util.merge(VoxelSpaces.getVoxelSpaces(), {\n    $INIT(settings) {\n        WorldSpaces.setDimensions({\n            regions: {\n                x: settings.regions.regionXPow2,\n                y: settings.regions.regionYPow2,\n                z: settings.regions.regionZPow2,\n            },\n            columns: {\n                x: settings.chunks.chunkXPow2,\n                y: settings.regions.regionYPow2,\n                z: settings.chunks.chunkZPow2,\n            },\n            chunks: {\n                x: settings.chunks.chunkXPow2,\n                y: settings.chunks.chunkYPow2,\n                z: settings.chunks.chunkZPow2,\n            },\n        });\n    },\n});\n","import { CreatePromiseCheck } from \"./Util/CreatePromiseCheck.js\";\nimport { Queue } from \"./Util/Queue.js\";\nexport const Util = {\n    createPromiseCheck: CreatePromiseCheck,\n    getEnviorment() {\n        let environment = \"browser\";\n        //@ts-ignore\n        if (typeof process !== \"undefined\" && typeof Worker === \"undefined\") {\n            environment = \"node\";\n        }\n        return environment;\n    },\n    getAQueue() {\n        return new Queue();\n    },\n    merge(target, newObject) {\n        return Object.assign(target, newObject);\n    },\n    degtoRad(degrees) {\n        return degrees * (Math.PI / 180);\n    },\n    radToDeg(radians) {\n        return radians * (180 / Math.PI);\n    },\n    convertBufferToSAB(buffer) {\n        const sab = new SharedArrayBuffer(buffer.byteLength);\n        const temp = new Uint8Array(buffer);\n        const temp2 = new Uint8Array(sab);\n        temp2.set(temp, 0);\n        return sab;\n    },\n    converSABToBuffer(buffer) {\n        const newBuffer = new ArrayBuffer(buffer.byteLength);\n        const temp = new Uint8Array(buffer);\n        const temp2 = new Uint8Array(newBuffer);\n        temp2.set(temp, 0);\n        return newBuffer;\n    },\n};\n","import { SafeInterval } from \"./SafeInterval.js\";\nexport const CreatePromiseCheck = (data) => {\n    return new Promise((resolve) => {\n        const times = {\n            inte: -1,\n            fail: -1,\n        };\n        const inte = new SafeInterval()\n            .setInterval(data.checkInterval)\n            .setOnRun(() => {\n            if (data.check()) {\n                if (data.onReady) {\n                    data.onReady();\n                }\n                if (times.fail > -1) {\n                    clearTimeout(times.fail);\n                }\n                inte.stop();\n                resolve(true);\n            }\n        });\n        inte.start();\n        if (data.failTimeOut) {\n            times.fail = setTimeout(() => {\n                inte.stop();\n                if (data.onFail) {\n                    data.onFail();\n                }\n                resolve(false);\n            }, data.failTimeOut);\n        }\n    });\n};\n","class QueueNode {\n    data;\n    next;\n    constructor(data) {\n        this.data = data;\n    }\n}\nexport class Queue {\n    size = 0;\n    first;\n    last;\n    enqueue(data) {\n        const node = new QueueNode(data);\n        if (this.size == 0) {\n            this.first = node;\n            this.last = node;\n        }\n        else {\n            this.last.next = node;\n            this.last = node;\n        }\n        this.size++;\n    }\n    dequeue() {\n        if (this.size == 0)\n            return null;\n        if (!this.first)\n            return null;\n        let prevFirst = this.first;\n        this.first = prevFirst.next;\n        prevFirst.next = null;\n        this.size--;\n        return prevFirst.data;\n    }\n}\n","/** # SafeInterval\n * Creates a predictable sync interval.\n */\nexport class SafeInterval {\n    _active = false;\n    _run = () => { };\n    inteval = 100;\n    lastTime = 0;\n    currentTimeout = 0;\n    setOnRun(run) {\n        this._run = run;\n        return this;\n    }\n    setInterval(interval) {\n        this.inteval = interval;\n        return this;\n    }\n    async run() {\n        if (!this._active)\n            return;\n        await this._run(performance.now() - this.lastTime);\n        this.currentTimeout = setTimeout(() => {\n            this.run();\n        }, this.inteval);\n        return this;\n    }\n    start() {\n        if (!this._active) {\n            this._active = true;\n            this.run();\n        }\n        return this;\n    }\n    stop() {\n        this._active = false;\n        clearTimeout(this.currentTimeout);\n        return this;\n    }\n}\n","export const $3dMooreNeighborhood = [];\nexport const $2dMooreNeighborhood = [\n    [0, 0],\n    [1, 0],\n    [0, 1],\n    [1, 1],\n    [-1, 0],\n    [0, -1],\n    [-1, -1],\n    [1, -1],\n    [-1, 1],\n];\nexport const $3dCardinalNeighbors = [\n    [0, 1, 0],\n    [0, -1, 0],\n    [1, 0, 0],\n    [-1, 0, 0],\n    [0, 0, -1],\n    [0, 0, 1],\n];\nfor (let y = -1; y < 2; y++) {\n    for (const n of $2dMooreNeighborhood) {\n        $3dMooreNeighborhood.push([n[0], y, n[1]]);\n    }\n}\n","import { Util } from \"../../Global/Util.helper.js\";\nimport { DimensionsRegister } from \"../../Data/World/Dimensions/DimensionsRegister.js\";\nimport { LocationBoundTool } from \"./LocationBoundTool.js\";\nimport { WorldDataTagIDs } from \"../../Data/Constants/Tags/WorldDataTagIds.js\";\nexport class DataToolBase extends LocationBoundTool {\n    tags;\n    _c;\n    constructor() {\n        super();\n    }\n    getTagValue(id) {\n        this.tags.setBuffer(this._c);\n        return this.tags.getTag(id);\n    }\n    setTagValue(id, value) {\n        this.tags.setBuffer(this._c);\n        return this.tags.setTag(id, value);\n    }\n    getArrayTagValue(id, index) {\n        this.tags.setBuffer(this._c);\n        return this.tags.getArrayTagValue(id, index);\n    }\n    setArrayTagValue(id, index, value) {\n        this.tags.setBuffer(this._c);\n        return this.tags.setArrayTagValue(id, index, value);\n    }\n    setBuffer(buffer) {\n        this._c = buffer;\n        this.tags.setBuffer(this._c);\n    }\n    getBuffer() {\n        if (this._c instanceof DataView)\n            return this._c.buffer;\n        return this._c;\n    }\n    getAsArrayBuffer() {\n        return Util.converSABToBuffer(this.getBuffer());\n    }\n    getBufferSize() {\n        return this.tags.tagSize;\n    }\n    loadInAt(x, y, z) {\n        this.setXYZ(x, y, z);\n        return this.loadIn();\n    }\n    loadInVec3Array(vec3) {\n        this.setXYZ(vec3[0], vec3[1], vec3[2]);\n        return this.loadIn();\n    }\n    loadInVec3(vec3) {\n        this.setXYZ(vec3.x, vec3.y, vec3.z);\n        return this.loadIn();\n    }\n    loadInAtLocation(location) {\n        this.setLocation(location);\n        return this.loadIn();\n    }\n}\nexport class EncodedPositionDataTool extends DataToolBase {\n    position = { x: 0, y: 0, z: 0 };\n    constructor() {\n        super();\n    }\n    getPositionData() {\n        this.position.x = this.getTagValue(WorldDataTagIDs.positionX);\n        this.position.y = this.getTagValue(WorldDataTagIDs.positionY);\n        this.position.z = this.getTagValue(WorldDataTagIDs.positionZ);\n        return this.position;\n    }\n    setPositionData(x, y, z) {\n        this.setTagValue(WorldDataTagIDs.positionX, x);\n        this.setTagValue(WorldDataTagIDs.positionY, y);\n        this.setTagValue(WorldDataTagIDs.positionZ, z);\n        return this.position;\n    }\n    setDimensionId(dimensionId) {\n        this.setTagValue(WorldDataTagIDs.dimensionId, DimensionsRegister.getDimensionNumericId(dimensionId));\n    }\n    getDimensionId() {\n        return DimensionsRegister.getDimensionStringId(this.getTagValue(WorldDataTagIDs.dimensionId));\n    }\n    getLocationData() {\n        const pos = this.getPositionData();\n        return [this.getDimensionId(), pos.x, pos.y, pos.z];\n    }\n}\n","export class LocationBoundTool {\n    location = [\"main\", 0, 0, 0];\n    get dimension() {\n        return this.location[0];\n    }\n    set dimension(dimension) {\n        this.location[0] = dimension;\n    }\n    get x() {\n        return this.location[1];\n    }\n    set x(value) {\n        this.location[1] = value;\n    }\n    get y() {\n        return this.location[2];\n    }\n    set y(value) {\n        this.location[2] = value;\n    }\n    get z() {\n        return this.location[3];\n    }\n    set z(value) {\n        this.location[3] = value;\n    }\n    setDimension(dimensionId) {\n        this.location[0] = dimensionId;\n        return this;\n    }\n    getLocation() {\n        return this.location;\n    }\n    setXYZ(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n    }\n    setXZ(x, z) {\n        this.setXYZ(x, this.location[2], z);\n        return this;\n    }\n    setLocation(location) {\n        this.dimension = location[0];\n        this.x = location[1];\n        this.y = location[2];\n        this.z = location[3];\n        return this;\n    }\n}\n","import { DimensionsRegister } from \"../../Data/World/Dimensions/DimensionsRegister.js\";\nimport { VoxelReader } from \"../../Data/Voxel/VoxelReader.js\";\nimport { VoxelTags } from \"../../Data/Voxel/VoxelTags.js\";\nimport { VoxelPaletteReader } from \"../../Data/Voxel/VoxelPalette.js\";\nimport { ChunkDataTool } from \"./WorldData/ChunkDataTool.js\";\nimport { HeightMapTool } from \"./WorldData/HeightMapTool.js\";\nimport { DataToolBase } from \"../Classes/DataToolBase.js\";\nimport { WorldSpaces } from \"../../Data/World/WorldSpaces.js\";\nimport { ColumnDataTool } from \"./WorldData/ColumnDataTool.js\";\nimport { LightData } from \"../../Data/Light/LightByte.js\";\nimport { VoxelTagIDs } from \"../../Data/Constants/Tags/VoxelTagIds.js\";\nimport { MappedDataRegister } from \"../../Data/Register/MappedDataRegister.js\";\nimport { SubstanceDataTool } from \"./SubstanceDataTool.js\";\nclass DataTool extends DataToolBase {\n    /**# World Data Mode\n     * ---\n     * Read data directly from the world.\n     */\n    static WORLD_DATA_MODE = 0;\n    /**# Voxel Matrix Mode\n     * ---\n     * Read from a voxel matrix.\n     */\n    static VOXEL_MATRIX_MODE = 1;\n    /**# Voxel Data Mode\n     * ---\n     * Read data from a single voxel passed in via `loadInRaw`\n     */\n    static VOXEL_DATA_MODE = 2;\n    static _dtutil = new DataTool();\n    _chunkTool = new ChunkDataTool();\n    _substanceTool = new SubstanceDataTool();\n    static _heightMapTool = new HeightMapTool();\n    static _columntool = new ColumnDataTool();\n    _locationKey = \"\";\n    _loadedIn = false;\n    _mode = 0;\n    data = {\n        raw: [0, 0, 0, 0],\n        id: 0,\n        baseId: 0,\n        secondaryId: 0,\n        secondaryBaseId: 0,\n    };\n    __secondary = false;\n    tags = VoxelTags;\n    setMode(mode) {\n        this._mode = mode;\n        return this;\n    }\n    clear() {\n        this._loadedIn = false;\n        this._locationKey = \"\";\n        let i = this.data.raw.length;\n        while (i--) {\n            this.data.raw[i] = 0;\n        }\n        this.data.id = 0;\n        this.data.baseId = 0;\n        this.data.secondaryId = 0;\n        this.data.secondaryBaseId = 0;\n        return this;\n    }\n    setDimension(dimensionId) {\n        this.location[0] = DimensionsRegister.getDimensionStringId(dimensionId);\n        return this;\n    }\n    setSecondary(enable) {\n        this.__secondary = enable;\n        if (enable) {\n            VoxelTags.setVoxel(this.data.secondaryBaseId);\n        }\n        else {\n            VoxelTags.setVoxel(this.data.baseId);\n        }\n        return this;\n    }\n    _getBaseId(id) {\n        return VoxelPaletteReader.id.baseNumeric(id);\n    }\n    getSubstnaceData() {\n        this._substanceTool.setSubstance(this.getSubstance());\n        return this._substanceTool;\n    }\n    getRaw() {\n        return this.data.raw;\n    }\n    loadInRaw(rawData) {\n        this.data.raw = rawData;\n        this.__process();\n        return this;\n    }\n    __process() {\n        this.data.id = this.data.raw[0];\n        this.data.secondaryId = this.data.raw[3];\n        this.data.baseId = this._getBaseId(this.data.id);\n        if (this.data.secondaryId > 1) {\n            this.data.secondaryBaseId = this._getBaseId(this.data.secondaryId);\n        }\n        else {\n            this.data.secondaryBaseId = 0;\n        }\n        VoxelTags.setVoxel(this.data.baseId);\n    }\n    loadIn() {\n        this._c = this.tags.data;\n        if (this._mode == DataTool.WORLD_DATA_MODE) {\n            if (!this._chunkTool.setLocation(this.location).loadIn())\n                return false;\n            const index = WorldSpaces.voxel.getIndexLocation(this.location);\n            this.data.raw[0] = this._chunkTool.segments.id.get(index);\n            this.data.raw[1] = this._chunkTool.segments.light.get(index);\n            this.data.raw[2] = this._chunkTool.segments.state.get(index);\n            this.data.raw[3] = this._chunkTool.segments.secondaryId.get(index);\n            this.__process();\n            this._loadedIn = true;\n            return true;\n        }\n        if (this._mode == DataTool.VOXEL_MATRIX_MODE) {\n            return false;\n        }\n        if (this._mode == DataTool.VOXEL_DATA_MODE) {\n            this.data.raw[0] = 0;\n            this.data.raw[1] = LightData.getS(0xff);\n            this.data.raw[2] = 0;\n            return false;\n        }\n        return false;\n    }\n    commit(heightMapUpdate = 0) {\n        if (!this._loadedIn)\n            return false;\n        if (this._mode == DataTool.WORLD_DATA_MODE) {\n            const index = WorldSpaces.voxel.getIndexLocation(this.location);\n            this._chunkTool.segments.id.set(index, this.data.raw[0]);\n            this._chunkTool.segments.light.set(index, this.data.raw[1]);\n            this._chunkTool.segments.state.set(index, this.data.raw[2]);\n            this._chunkTool.segments.secondaryId.set(index, this.data.raw[3]);\n            if (DataTool._columntool.loadInAtLocation(this.location)) {\n                DataTool._columntool.markAsNotStored();\n            }\n            if (heightMapUpdate) {\n                DataTool._heightMapTool.chunk._c = this._chunkTool._c;\n                const substance = this.getTemplateSubstance();\n                //on add\n                if (heightMapUpdate == 1) {\n                    DataTool._heightMapTool.chunk.setY(this.y).setHasVoxels(true);\n                    //  DataTool._heightMapTool.chunk.update(\"add\", substance, this.location);\n                }\n                //on remove\n                if (heightMapUpdate == 2) {\n                    DataTool._heightMapTool.chunk.setY(this.y).setDirty(true);\n                    //   DataTool._heightMapTool.chunk.update(\"remove\", substance, this.location);\n                }\n            }\n            this._loadedIn = false;\n            return true;\n        }\n        if (this._mode == DataTool.VOXEL_MATRIX_MODE) {\n            return false;\n        }\n        if (this._mode == DataTool.VOXEL_DATA_MODE) {\n            return false;\n        }\n        return false;\n    }\n    hasRGBLight() {\n        const light = this.getLight();\n        if (light <= 0)\n            false;\n        return LightData.hasRGBLight(light);\n    }\n    hasSunLight() {\n        const light = this.getLight();\n        if (light <= 0)\n            false;\n        return LightData.hasSunLight(light);\n    }\n    getLight() {\n        if (this._mode == DataTool.VOXEL_DATA_MODE)\n            return 0xf;\n        const vID = this.getId(true);\n        VoxelTags.setVoxel(vID);\n        if (vID == 0)\n            return this.data.raw[1];\n        if (vID < 2)\n            return -1;\n        const lightValue = this.getTagValue(VoxelTagIDs.lightValue);\n        if (this.isOpaque()) {\n            if (this.getTagValue(VoxelTagIDs.isLightSource) && lightValue) {\n                return lightValue;\n            }\n            else {\n                return -1;\n            }\n        }\n        if (this.getTagValue(\"#dve_is_light_source\") && lightValue) {\n            return LightData.mixLight(this.data.raw[1], lightValue);\n        }\n        return this.data.raw[1];\n    }\n    setLight(light) {\n        this.data.raw[1] = light;\n        return this;\n    }\n    isOpaque() {\n        const substance = this.getSubstance();\n        if (substance == \"#dve_solid\")\n            return true;\n    }\n    getLevel() {\n        return VoxelReader.getLevel(this.data.raw[2]);\n    }\n    setLevel(level) {\n        this.data.raw[2] = VoxelReader.setLevel(this.data.raw[2], level);\n        return this;\n    }\n    getLevelState() {\n        return VoxelReader.getLevelState(this.data.raw[2]);\n    }\n    setLevelState(state) {\n        this.data.raw[2] = VoxelReader.setLevelState(this.data.raw[2], state);\n        return this;\n    }\n    getShapeState() {\n        return VoxelReader.getShapeState(this.data.raw[2]);\n    }\n    setShapeState(state) {\n        this.data.raw[2] = VoxelReader.setShapeState(this.data.raw[2], state);\n        return this;\n    }\n    hasSecondaryVoxel() {\n        return this.data.secondaryBaseId > 1;\n    }\n    //voxel data\n    getShapeId() {\n        const vID = this.getId(true);\n        if (vID < 2)\n            return \"\";\n        VoxelTags.setVoxel(vID);\n        return MappedDataRegister.stringMaps.get(\"voxel\", VoxelTagIDs.shapeID, VoxelTags.getTag(VoxelTagIDs.shapeID));\n    }\n    isLightSource() {\n        const vID = this.getId(true);\n        if (vID < 2)\n            return false;\n        VoxelTags.setVoxel(vID);\n        return VoxelTags.getTag(VoxelTagIDs.isLightSource) == 1;\n    }\n    getLightSourceValue() {\n        const vID = this.getId(true);\n        if (vID < 2)\n            return 0;\n        VoxelTags.setVoxel(vID);\n        return VoxelTags.getTag(VoxelTagIDs.lightValue);\n    }\n    getSubstance() {\n        const vID = this.getId(true);\n        if (vID < 2)\n            return \"#dve_transparent\";\n        VoxelTags.setVoxel(vID);\n        const s = (MappedDataRegister.stringMaps.get(\"voxel\", VoxelTagIDs.substance, VoxelTags.getTag(VoxelTagIDs.substance)));\n        return s;\n    }\n    getMaterial() {\n        const vID = this.getId(true);\n        if (vID < 2)\n            return \"none\";\n        VoxelTags.setVoxel(vID);\n        return MappedDataRegister.stringMaps.get(\"voxel\", VoxelTagIDs.material, VoxelTags.getTag(VoxelTagIDs.material));\n    }\n    getHardness() {\n        const vID = this.getId(true);\n        if (vID < 2)\n            return 0;\n        VoxelTags.setVoxel(vID);\n        return VoxelTags.getTag(VoxelTagIDs.hardness);\n    }\n    getCollider() {\n        const vID = this.getId(true);\n        if (vID < 2)\n            return \"none\";\n        VoxelTags.setVoxel(vID);\n        return MappedDataRegister.stringMaps.get(\"voxel\", VoxelTagIDs.colliderID, VoxelTags.getTag(VoxelTagIDs.colliderID));\n    }\n    checkCollisions() {\n        const vID = this.getId(true);\n        if (vID == 0)\n            return false;\n        if (vID == 1)\n            return true;\n        VoxelTags.setVoxel(vID);\n        return this.getTagValue(VoxelTagIDs.checkCollisions) == 1;\n    }\n    getTemplateSubstance() {\n        let substance = this.getSubstance();\n        if (substance == \"#dve_transparent\") {\n            substance = \"#dve_solid\";\n        }\n        return substance;\n    }\n    getState() {\n        if (this.__secondary) {\n            return this.data.secondaryId - this.data.secondaryBaseId;\n        }\n        return this.data.id - this.data.baseId;\n    }\n    isRich() {\n        const vID = this.getId(true);\n        if (vID < 2)\n            return 0;\n        VoxelTags.setVoxel(vID);\n        return VoxelTags.getTag(VoxelTagIDs.isLightSource);\n    }\n    //util\n    setAir() {\n        this.data.raw[0] = 0;\n        this.__process();\n        return this;\n    }\n    isAir() {\n        return 0 == this.data.raw[0];\n    }\n    setBarrier() {\n        this.data.raw[0] = 1;\n        this.__process();\n        return this;\n    }\n    isBarrier() {\n        return 1 == this.data.raw[0];\n    }\n    //voxel id\n    getId(base = false) {\n        if (this.__secondary) {\n            if (!base)\n                return this.data.secondaryId;\n            return this.data.secondaryBaseId;\n        }\n        if (!base)\n            return this.data.id;\n        return this.data.baseId;\n    }\n    setId(id) {\n        if (this.__secondary) {\n            this.data.raw[3] = id;\n            this.data.secondaryId = id;\n            this.data.secondaryBaseId = this._getBaseId(id);\n            return this;\n        }\n        this.data.raw[0] = id;\n        this.data.id = id;\n        this.data.baseId = this._getBaseId(id);\n        return this;\n    }\n    setStringId(id) {\n        return this.setId(VoxelPaletteReader.id.numberFromString(id));\n    }\n    getStringId() {\n        if (this.__secondary) {\n            return VoxelPaletteReader.id.stringFromNumber(this.data.secondaryBaseId);\n        }\n        return VoxelPaletteReader.id.stringFromNumber(this.data.baseId);\n    }\n    //util\n    isRenderable() {\n        if (this.data.id < 2 && this.data.secondaryId < 2)\n            return false;\n        return true;\n    }\n    isSameVoxel(cx, cy, cz) {\n        DataTool._dtutil.loadInAt(cx, cy, cz);\n        if (this.__secondary) {\n            return this.data.secondaryBaseId == DataTool._dtutil.data.secondaryBaseId;\n        }\n        return this.data.baseId == DataTool._dtutil.data.baseId;\n    }\n}\nexport { DataTool };\n","import { SubstanceTagIds } from \"../../Data/Constants/Tags/SubstanceTagIds.js\";\nimport { SubstancePaletteReader } from \"../../Data/Substance/SubstancePalette.js\";\nimport { SubstanceTags } from \"../../Data/Substance/SubstanceTags.js\";\nimport { MappedDataRegister } from \"../../Data/Register/MappedDataRegister.js\";\nclass SubstanceDataTool {\n    static tags = SubstanceTags;\n    static getTagValue(index, tag) {\n        this.tags.setTagIndex(index);\n        return this.tags.getTag(tag);\n    }\n    substance = \"\";\n    substanceTagIndex = 0;\n    setSubstance(substance) {\n        this.substance = substance;\n        this.substanceTagIndex =\n            SubstancePaletteReader.id.numberFromString(substance);\n    }\n    isSolid() {\n        return (SubstanceDataTool.getTagValue(this.substanceTagIndex, SubstanceTagIds.isSolid) == 1);\n    }\n    isLiquid() {\n        return (SubstanceDataTool.getTagValue(this.substanceTagIndex, SubstanceTagIds.isLiquid) == 1);\n    }\n    getParent() {\n        return MappedDataRegister.stringMaps.get(\"substance\", SubstanceTagIds.parent, SubstanceDataTool.getTagValue(this.substanceTagIndex, SubstanceTagIds.parent));\n    }\n    getRendered() {\n        return MappedDataRegister.stringMaps.get(\"substance\", SubstanceTagIds.rendered, SubstanceDataTool.getTagValue(this.substanceTagIndex, SubstanceTagIds.rendered));\n    }\n    getCulled() {\n        return MappedDataRegister.objectMaps.get(\"substance\", SubstanceTagIds.culledSubstnaces, SubstanceDataTool.getTagValue(this.substanceTagIndex, SubstanceTagIds.culledSubstnaces));\n    }\n    getFlowRate() {\n        return SubstanceDataTool.getTagValue(this.substanceTagIndex, SubstanceTagIds.flowRate);\n    }\n}\nexport { SubstanceDataTool };\n","//objects\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\nimport { ChunkTags } from \"../../../Data/World/Chunk/ChunkTags.js\";\nimport { EncodedPositionDataTool } from \"../../Classes/DataToolBase.js\";\nimport { ChunkTagIDs } from \"../../../Data/Constants/Tags/ChunkTagIds.js\";\nimport { WorldSpaces } from \"../../../Data/World/WorldSpaces.js\";\nexport class ChunkDataTool extends EncodedPositionDataTool {\n    tags = ChunkTags;\n    constructor() {\n        super();\n        this.segments.id._s = this;\n        this.segments.light._s = this;\n        this.segments.state._s = this;\n        this.segments.secondaryId._s = this;\n    }\n    loadIn() {\n        WorldSpaces.chunk.updateLoaction(this.location);\n        const chunk = WorldRegister.chunk.get(this.location);\n        if (!chunk)\n            return false;\n        this.tags.setBuffer(chunk.data);\n        this._c = chunk.data;\n        return true;\n    }\n    setChunk(chunk) {\n        this.tags.setBuffer(chunk.data);\n        this._c = chunk.data;\n        return this;\n    }\n    segments = {\n        id: {\n            _s: {},\n            get(index) {\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelIDSegment, index);\n            },\n            set(index, value) {\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelIDSegment, index, value);\n            },\n        },\n        light: {\n            _s: {},\n            get(index) {\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelLightSegment, index);\n            },\n            set(index, value) {\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelLightSegment, index, value);\n            },\n        },\n        state: {\n            _s: {},\n            get(index) {\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelStateSegment, index);\n            },\n            set(index, value) {\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelStateSegment, index, value);\n            },\n        },\n        secondaryId: {\n            _s: {},\n            get(index) {\n                return this._s.getArrayTagValue(ChunkTagIDs.voxelSecondaryIDSegment, index);\n            },\n            set(index, value) {\n                return this._s.setArrayTagValue(ChunkTagIDs.voxelSecondaryIDSegment, index, value);\n            },\n        },\n    };\n}\n","//objects\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\nimport { EncodedPositionDataTool } from \"../../Classes/DataToolBase.js\";\nimport { ColumnTags } from \"../../../Data/World/Column/ColumnTags.js\";\nimport { ChunkTags } from \"../../../Data/World/Chunk/ChunkTags.js\";\nexport class ColumnDataTool extends EncodedPositionDataTool {\n    tags = ColumnTags;\n    _column = {};\n    loadIn() {\n        const column = WorldRegister.column.get(this.location);\n        if (!column)\n            return false;\n        this.tags.setBuffer(column.data);\n        this._c = column.data;\n        this._column = column;\n        return true;\n    }\n    setColumn(column) {\n        this.tags.setBuffer(column.data);\n        this._c = column.data;\n        this._column = column;\n        return this;\n    }\n    getColumn() {\n        return this._column;\n    }\n    getNumChunks() {\n        return this._column.chunks.size;\n    }\n    getBufferSizeForWholeColumn() {\n        return ColumnTags.tagSize + ChunkTags.tagSize * this.getNumChunks();\n    }\n    isStored() {\n        return this.getTagValue(\"#dve_is_stored\") == 1;\n    }\n    markAsNotStored() {\n        this.setTagValue(\"#dve_is_stored\", 0);\n        return this;\n    }\n    markAsStored() {\n        this.setTagValue(\"#dve_is_stored\", 1);\n        return this;\n    }\n    isPersistent() {\n        return this.getTagValue(\"#dve_persistent\") == 1;\n    }\n    setPersistence(value) {\n        this.setTagValue(\"#dve_persistent\", value ? 1 : 0);\n    }\n    isDirty() {\n        return this.getTagValue(\"#dve_is_dirty\") == 1;\n    }\n    setDirty(value) {\n        this.setTagValue(\"#dve_is_dirty\", value ? 1 : 0);\n    }\n    getLastSaveTimestamp() {\n        return this.getTagValue(\"#dve_last_save_timestamp\");\n    }\n    setLastSaveTimestamp() {\n        return this.setTagValue(\"#dve_last_save_timestamp\", Date.now());\n    }\n    getLastAnalyzerUpdateTimestamp() {\n        return this.getTagValue(\"#dve_last_analyzer_update_timestamp\");\n    }\n    setLastAnalyzerUpdateTimestamp() {\n        return this.setTagValue(\"#dve_last_analyzer_update_timestamp\", Date.now());\n    }\n    hasRichData() {\n        return this.getTagValue(\"#dve_has_rich_data\") == 1;\n    }\n    setRichData(value) {\n        this.setTagValue(\"#dve_has_rich_data\", value ? 1 : 0);\n    }\n    hasEntityData() {\n        return this.getTagValue(\"#dve_has_entity_data\") == 1;\n    }\n    setEntityData(value) {\n        this.setTagValue(\"#dve_has_entity_data\", value ? 1 : 0);\n    }\n}\n","//Data\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\nimport { WorldSpaces } from \"../../../Data/World/WorldSpaces.js\";\nimport { WorldBounds } from \"../../../Data/World/WorldBounds.js\";\n//tools\nimport { LocationBoundTool } from \"../../../Tools/Classes/LocationBoundTool.js\";\nimport { ChunkDataTool } from \"./ChunkDataTool.js\";\n//constants\nimport { ChunkTagIDs } from \"../../../Data/Constants/Tags/ChunkTagIds.js\";\nimport { $2dMooreNeighborhood } from \"../../../Math/Constants/CardinalNeighbors.js\";\nclass HeightMapTool extends LocationBoundTool {\n    static _chunkTool = new ChunkDataTool();\n    chunk = {\n        _c: new DataView(new ArrayBuffer(0)),\n        _y: 0,\n        loadInAt: (x, y, z) => {\n            const chunk = WorldRegister.chunk.get([this.dimension, x, y, z]);\n            if (!chunk)\n                return false;\n            HeightMapTool._chunkTool.setChunk(chunk);\n            this.chunk._c = chunk.data;\n        },\n        loadInAtLocation(location) {\n            const chunk = WorldRegister.chunk.get(location);\n            if (!chunk)\n                return false;\n            HeightMapTool._chunkTool.setChunk(chunk);\n            this._c = chunk.data;\n        },\n        setChunk(chunk) {\n            HeightMapTool._chunkTool.setChunk(chunk);\n            this._c = chunk.data;\n        },\n        setY(y) {\n            WorldSpaces.voxel.setXYZ(0, y, 0);\n            this._y = WorldSpaces.voxel.getPosition().y;\n            return this;\n        },\n        getMinMax() {\n            HeightMapTool._chunkTool._c = this._c;\n            let min = Infinity;\n            let max = -Infinity;\n            let i = WorldSpaces.chunk.getHeight();\n            while (i--) {\n                if (this.setY(i).hasVoxels()) {\n                    if (i < min)\n                        min = i;\n                    if (i > max)\n                        max = i;\n                }\n            }\n            return [min, max];\n        },\n        hasVoxels() {\n            HeightMapTool._chunkTool._c = this._c;\n            return (HeightMapTool._chunkTool.getArrayTagValue(ChunkTagIDs.heightMap, this._y) ==\n                1);\n        },\n        isDirty() {\n            HeightMapTool._chunkTool._c = this._c;\n            return (HeightMapTool._chunkTool.getArrayTagValue(ChunkTagIDs.dirtyMap, this._y) ==\n                1);\n        },\n        setHasVoxels(hasVoxels) {\n            HeightMapTool._chunkTool._c = this._c;\n            return HeightMapTool._chunkTool.setArrayTagValue(ChunkTagIDs.heightMap, this._y, hasVoxels ? 1 : 0);\n        },\n        setDirty(isDirty) {\n            HeightMapTool._chunkTool._c = this._c;\n            return HeightMapTool._chunkTool.setArrayTagValue(ChunkTagIDs.dirtyMap, this._y, isDirty ? 1 : 0);\n        },\n    };\n    column = {\n        getRelative(location) {\n            location = [...location];\n            const chunkWidth = WorldSpaces.chunk._bounds.x;\n            const chunkDepth = WorldSpaces.chunk._bounds.z;\n            let maxHeight = -Infinity;\n            const [dimension, x, y, z] = location;\n            for (const check of $2dMooreNeighborhood) {\n                location[1] = check[0] * chunkWidth + x;\n                location[3] = check[1] * chunkDepth + z;\n                const height = this.getAbsolute(location);\n                if (height > maxHeight) {\n                    maxHeight = height;\n                }\n            }\n            return maxHeight;\n        },\n        getAbsolute: (location) => {\n            const column = WorldRegister.column.get(location);\n            if (!column)\n                return WorldBounds.bounds.MinY;\n            if (column.chunks.size == 0)\n                return WorldBounds.bounds.MinY;\n            let maxHeight = WorldBounds.bounds.MinY;\n            for (const [key, chunk] of column.chunks) {\n                if (!chunk)\n                    continue;\n                this.chunk.setChunk(chunk);\n                const chunkPOS = HeightMapTool._chunkTool.getPositionData();\n                let [chunkMin, chunkMax] = this.chunk.getMinMax();\n                if (chunkMax == 0)\n                    continue;\n                chunkMax += chunkPOS.y;\n                if (maxHeight < chunkMax) {\n                    maxHeight = chunkMax;\n                }\n            }\n            return maxHeight + 1;\n        },\n    };\n}\nexport { HeightMapTool };\n","//objects\nimport { WorldRegister } from \"../../../Data/World/WorldRegister.js\";\nimport { EncodedPositionDataTool } from \"../../Classes/DataToolBase.js\";\nimport { RegionTags } from \"../../../Data/World/Region/RegionTags.js\";\nexport class RegionDataTool extends EncodedPositionDataTool {\n    tags = RegionTags;\n    _region = {};\n    loadIn() {\n        const reigon = WorldRegister.region.get(this.location);\n        if (!reigon)\n            return false;\n        this.tags.setBuffer(reigon.data);\n        this._region = reigon;\n        this._c = reigon.data;\n        return true;\n    }\n    setRegion(region) {\n        this.tags.setBuffer(region.data);\n        this._region = region;\n        this._c = region.data;\n        return this;\n    }\n    getRegion() {\n        return this._region;\n    }\n    getRegionDataCount() {\n        const region = this._region;\n        let totalChunks = 0;\n        region.columns.forEach((column) => {\n            totalChunks += column.chunks.size;\n        });\n        return {\n            chunks: totalChunks,\n            columns: region.columns.size,\n        };\n    }\n}\n","import { ThreadComm } from \"../ThreadComm.js\";\nimport { TCMessageHeaders, TCInternalMessages } from \"../Internal/Messages.js\";\nimport { PromiseTasks } from \"../Tasks/PromiseTasks.js\";\nimport { InternalTasks } from \"../Internal/InternalTasks.js\";\nexport class CommBase {\n    name;\n    managerName;\n    environment = \"browser\";\n    __ready = false;\n    port = null;\n    messageFunctions = {};\n    _manager = null;\n    constructor(name, managerName = \"worker\", commManager = null) {\n        this.name = name;\n        this.managerName = managerName;\n        this._manager = commManager;\n    }\n    destroy() {\n        if (!this.port)\n            return;\n        if (\"terminate\" in this.port) {\n            this.port.terminate();\n        }\n    }\n    isReady() {\n        return this.isPortSet();\n    }\n    __sendReadySignal() {\n        this.sendMessage(TCMessageHeaders.internal, [\n            TCInternalMessages.IsReady,\n            ThreadComm.threadName,\n        ]);\n    }\n    __onSetPortRun = (port) => { };\n    isPortSet() {\n        return Boolean(this.port);\n    }\n    onSetPort(set) {\n        this.__onSetPortRun = set;\n    }\n    __handleMessage(data, event) {\n        this.onMessage(data, event);\n        if (InternalTasks.isInternal(data)) {\n            return InternalTasks.runInternal(data, event);\n        }\n        if (this._manager) {\n            if (this._manager.__isManagerMessage(data)) {\n                this._manager.__handleManagerMessage(data, event);\n                return;\n            }\n        }\n        const message = data[0];\n        if (this.messageFunctions[message]) {\n            this.messageFunctions[message].forEach((_) => _(data, event));\n            return;\n        }\n    }\n    setPort(port) {\n        if (!port) {\n            return this.__throwError(\"Port or worker must not be null.\");\n        }\n        this.port = port;\n        this.__onSetPortRun(port);\n        if (this.environment == \"browser\") {\n            port.onmessage = (event) => {\n                this.__handleMessage(event.data, event);\n            };\n            port.onmessageerror = (event) => {\n                console.log(event);\n                this.__throwError(\"Error occured.\");\n            };\n        }\n        if (this.environment == \"node\") {\n            port.on(\"message\", (data) => {\n                this.__handleMessage(data, data);\n            });\n            port.on(\"error\", (data) => {\n                console.log(data);\n                this.__throwError(\"Error occured.\");\n            });\n        }\n        this.__sendReadySignal();\n    }\n    __throwError(message) {\n        throw new Error(`[ThreadComm: ${this.name}] ${message}`);\n    }\n    sendMessage(message, data = [], transfers) {\n        if (!this.port) {\n            return this.__throwError(\"Port is not set.\");\n        }\n        if (this.environment == \"browser\" && transfers) {\n            this.port.postMessage([message, ...data], transfers);\n            return;\n        }\n        this.port.postMessage([message, ...data]);\n    }\n    listenForMessage(message, run) {\n        this.messageFunctions[message] ??= [];\n        this.messageFunctions[message].push(run);\n    }\n    connectToComm(commToConnectTo) {\n        const channel = new MessageChannel();\n        commToConnectTo.__sendInternalMessage(TCInternalMessages.connectPort, [this.name, this.managerName, channel.port1], [channel.port1]);\n        this.__sendInternalMessage(TCInternalMessages.connectPort, [commToConnectTo.name, commToConnectTo.managerName, channel.port2], [channel.port2]);\n    }\n    runTasks(id, data, transfers = [], queueId) {\n        let mode = 0;\n        let tid = \"\";\n        if (queueId) {\n            mode = 2;\n            tid = queueId;\n        }\n        this.__sendInternalMessage(TCInternalMessages.runTasks, [id, ThreadComm.threadName, mode, tid, data], transfers);\n    }\n    waitTillTasksExist(id) {\n        return new Promise((resolve) => {\n            const inte = setInterval(() => {\n                this.tasksExist(id, (exists) => {\n                    if (exists) {\n                        resolve(true);\n                        clearInterval(inte);\n                    }\n                });\n            }, 10);\n        });\n    }\n    tasksExist(id, onDone) {\n        const promiseId = `${this.name}-${id}-${Date.now()}`;\n        this.__sendInternalMessage(TCInternalMessages.checkTasks, [\n            id,\n            ThreadComm.threadName,\n            promiseId,\n        ]);\n        PromiseTasks.addPromiseTakss(\"tasks-check\", promiseId, (data) => {\n            onDone(data);\n        });\n    }\n    runPromiseTasks(id, data, transfers = [], onDone) {\n        const requestsID = ThreadComm.crypto.randomUUID();\n        PromiseTasks.addPromiseTakss(id, requestsID, onDone);\n        this.__sendInternalMessage(TCInternalMessages.runTasks, [id, ThreadComm.threadName, 1, requestsID, data], transfers);\n    }\n    __sendInternalMessage(id, data = [], transfers = []) {\n        this.sendMessage(TCMessageHeaders.internal, [id, ...data], transfers);\n    }\n    __syncQueue(id, sab) {\n        this.sendMessage(TCMessageHeaders.internal, [\n            TCInternalMessages.syncQueue,\n            ThreadComm.threadName,\n            id,\n            sab,\n        ]);\n    }\n    __unSyqncQueue(id) {\n        this.sendMessage(TCMessageHeaders.internal, [\n            TCInternalMessages.unSyncQueue,\n            ThreadComm.threadName,\n            id,\n        ]);\n    }\n    syncData(dataType, data, transfers) {\n        this.__sendInternalMessage(TCInternalMessages.SyncData, [dataType, data], transfers);\n    }\n    unSyncData(dataType, data, transfers) {\n        this.__sendInternalMessage(TCInternalMessages.UnSyncData, [dataType, data], transfers);\n    }\n    waitTillReady() {\n        const self = this;\n        return new Promise((resolve, reject) => {\n            const inte = setInterval(() => {\n                if (this.isReady()) {\n                    clearInterval(inte);\n                    resolve(true);\n                }\n            }, 1);\n        });\n    }\n    //meant to be over-ridden for debugging or custom behavior\n    onMessage(data, event) { }\n}\n","export class DataSync {\n    __onSyncFunctions = [];\n    __onUnSyncFunctions = [];\n    constructor() { }\n    addOnSync(func) {\n        this.__onSyncFunctions.push(func);\n    }\n    addOnUnSync(func) {\n        this.__onUnSyncFunctions.push(func);\n    }\n    sync(data) {\n        for (const func of this.__onSyncFunctions) {\n            func(data);\n        }\n    }\n    unSync(data) {\n        for (const func of this.__onUnSyncFunctions) {\n            func(data);\n        }\n    }\n}\n","import { DataSync } from \"./DataSync.js\";\nexport const DataSyncManager = {\n    _onDataSync: new Map(),\n    registerDataSync(dataType, onSync, onUnSync) {\n        const sync = new DataSync();\n        if (onSync) {\n            sync.addOnSync(onSync);\n        }\n        if (onUnSync) {\n            sync.addOnUnSync(onUnSync);\n        }\n        this._onDataSync.set(dataType, sync);\n        return sync;\n    },\n    getDataSync(id) {\n        const dataSync = this._onDataSync.get(id);\n        if (!dataSync)\n            return false;\n        return dataSync;\n    }\n};\n","import { TCInternalMessages, TCMessageHeaders } from \"./Messages.js\";\nimport { ThreadComm } from \"../ThreadComm.js\";\nimport { PromiseTasks } from \"../Tasks/PromiseTasks.js\";\nimport { SyncedQueue } from \"../Queue/SyncedQueue.js\";\nimport { TasksManager } from \"../Tasks/TaskManager.js\";\nimport { DataSyncManager } from \"../Data/DataSyncManager.js\";\nexport const InternalTasks = {\n    _tasks: new Map(),\n    registerTasks(headID, taskId, run) {\n        let map = this._tasks.get(headID);\n        if (!map) {\n            map = new Map();\n            this._tasks.set(headID, map);\n        }\n        map.set(taskId, run);\n    },\n    isInternal(data) {\n        const headerId = data[0];\n        const tasksId = data[1];\n        if (typeof headerId !== \"number\" || typeof tasksId !== \"number\")\n            return false;\n        const map = this._tasks.get(headerId);\n        if (!map)\n            return false;\n        const tasks = map.get(tasksId);\n        if (!tasks)\n            return false;\n        return true;\n    },\n    runInternal(data, event) {\n        const headerId = data[0];\n        const tasksId = data[1];\n        const map = this._tasks.get(headerId);\n        if (!map)\n            return false;\n        const tasks = map.get(tasksId);\n        if (!tasks)\n            return false;\n        data.shift();\n        data.shift();\n        tasks(data, event);\n    },\n};\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.connectPort, (data, event) => {\n    const threadName = data[0];\n    const threadManager = data[1];\n    let port;\n    if (ThreadComm.environment == \"browser\") {\n        port = event.ports[0];\n    }\n    else {\n        port = data[2];\n    }\n    if (threadManager == \"worker\") {\n        const comm = ThreadComm.getComm(threadName);\n        comm.setPort(port);\n    }\n    if (threadManager != \"worker\") {\n        const comm = ThreadComm.getCommManager(threadManager);\n        comm.addPort(port);\n    }\n});\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.IsReady, (data, event) => {\n    const name = data[0];\n    const comm = ThreadComm.getComm(name);\n    if (!comm)\n        return;\n    comm.__ready = true;\n});\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.nameThread, (data, event) => {\n    const name = data[0];\n    const number = data[1];\n    ThreadComm.threadName = name;\n    ThreadComm.threadNumber = number;\n});\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.syncQueue, (data, event) => {\n    const threadName = data[0];\n    const queueId = data[1];\n    const queueSAB = data[2];\n    if (!ThreadComm._queues.has(threadName)) {\n        ThreadComm._queues.set(threadName, new Map());\n    }\n    //@ts-ignore\n    ThreadComm._queues\n        .get(threadName)\n        .set(queueId, new SyncedQueue(queueId, queueSAB));\n});\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.unSyncQueue, (data, event) => {\n    const threadName = data[0];\n    const queueId = data[1];\n    if (!ThreadComm._queues.has(threadName)) {\n        return;\n    }\n    //@ts-ignore\n    ThreadComm._queues.get(threadName).delete(queueId);\n});\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.completeTasks, (data, event) => {\n    const tasksId = data[0];\n    const requestsId = data[1];\n    const tasksData = data[2];\n    PromiseTasks.completePromiseTasks(tasksId, requestsId, tasksData);\n});\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.checkTasksResult, (data, event) => {\n    const result = data[0];\n    const promiseId = data[1];\n    PromiseTasks.completePromiseTasks(\"tasks-check\", promiseId, result);\n});\nconst __handleTasksDone = (tasksId, mode, threadId, tid, tasksData, transfers) => {\n    if (mode == 1) {\n        const comm = ThreadComm.getComm(threadId);\n        comm.sendMessage(TCMessageHeaders.internal, [TCInternalMessages.completeTasks, tasksId, tid, tasksData], transfers);\n    }\n    if (mode == 2) {\n        //complete queue\n        if (tid && threadId) {\n            const queue = ThreadComm.getSyncedQueue(threadId, tid);\n            if (queue) {\n                queue.subtractFromCount();\n            }\n        }\n    }\n};\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.runTasks, async (data, event) => {\n    //remove tasks id\n    const tasksId = data.shift();\n    //remove thread id\n    const threadId = data.shift();\n    //remove queue id\n    const mode = data.shift();\n    //remove queue id\n    const tid = data.shift();\n    const takss = TasksManager.getTasks(tasksId);\n    if (!takss)\n        return;\n    if (takss.mode == \"async\") {\n        const tasksData = await takss.run(data[0]);\n        __handleTasksDone(tasksId, mode, threadId, tid, tasksData, []);\n    }\n    if (takss.mode == \"deferred\") {\n        await takss.run(data[0], (tasksData, transfers) => {\n            __handleTasksDone(tasksId, mode, threadId, tid, tasksData, transfers);\n        });\n    }\n});\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.checkTasks, async (data, event) => {\n    //remove tasks id\n    const tasksId = data.shift();\n    //remove thread id\n    const threadId = data.shift();\n    //remove promise id\n    const promiseId = data.shift();\n    const thread = ThreadComm.getComm(threadId);\n    const takss = TasksManager.getTasks(tasksId);\n    if (!takss)\n        return;\n    if (takss && thread) {\n        thread.sendMessage(TCMessageHeaders.internal, [\n            TCInternalMessages.checkTasksResult,\n            true,\n            promiseId,\n        ]);\n    }\n    if (!takss && thread) {\n        thread.sendMessage(TCMessageHeaders.internal, [\n            TCInternalMessages.checkTasksResult,\n            false,\n            promiseId,\n        ]);\n    }\n});\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.SyncData, async (data, event) => {\n    //remove tasks id\n    const dataTypeId = data.shift();\n    const dataSync = DataSyncManager.getDataSync(dataTypeId);\n    if (!dataSync)\n        return false;\n    const syncData = data.shift();\n    dataSync.sync(syncData);\n});\nInternalTasks.registerTasks(TCMessageHeaders.internal, TCInternalMessages.UnSyncData, async (data, event) => {\n    //remove tasks id\n    const dataTypeId = data.shift();\n    const dataSync = DataSyncManager.getDataSync(dataTypeId);\n    if (!dataSync)\n        return false;\n    const unSyncData = data.shift();\n    dataSync.unSync(unSyncData);\n});\n","export const TCMessageHeaders = Object.freeze({\n    internal: -99,\n});\nexport const TCInternalMessages = {\n    IsReady: -99,\n    nameThread: -98,\n    connectPort: -97,\n    syncQueue: -96,\n    unSyncQueue: -95,\n    completeTasks: -94,\n    checkTasksResult: -93,\n    runTasks: -98,\n    checkTasks: -97,\n    message: -95,\n    SyncData: -990,\n    UnSyncData: -980,\n};\nlet start = -1_000;\nfor (const key in TCInternalMessages) {\n    TCInternalMessages[key] = start;\n    start += 1;\n}\n","//constants\nimport { TCMessageHeaders, TCInternalMessages } from \"../Internal/Messages.js\";\n//classes\nimport { CommBase } from \"../Comm/Comm.js\";\nimport { QueueManager } from \"../Queue/QueueManager.js\";\nimport { ThreadComm } from \"../ThreadComm.js\";\nexport class CommManager {\n    _totalComms = 0;\n    _currentCom = 0;\n    name = \"\";\n    __comms = [];\n    __data = {\n        name: \"\",\n        onPortSet: (port, commName) => { },\n    };\n    __queues = {};\n    messageFunctions = {};\n    constructor(data) {\n        this.__data = data;\n        this.name = data.name;\n    }\n    __throwError(message) {\n        throw new Error(`[ThreadCommManager : ${this.__data.name}] ${message}`);\n    }\n    connectToCom(commToConnectTo) {\n        for (const comm of this.__comms) {\n            comm.connectToComm(commToConnectTo);\n        }\n    }\n    destroyAll() {\n        for (const comm of this.__comms) {\n            comm.destroy();\n        }\n    }\n    isReady() {\n        let ready = true;\n        for (const comm of this.__comms) {\n            if (!comm.isPortSet())\n                ready = false;\n        }\n        return ready;\n    }\n    waitTillAllAreReady() {\n        const self = this;\n        return new Promise((resolve, reject) => {\n            const inte = setInterval(() => {\n                if (this.isReady()) {\n                    clearInterval(inte);\n                    resolve(true);\n                }\n            }, 1);\n        });\n    }\n    addPort(port) {\n        this._totalComms++;\n        const newCommName = `${this.__data.name}-${this._totalComms}`;\n        const newComm = new CommBase(newCommName, this.__data.name, this);\n        ThreadComm.addComm(newComm);\n        newComm.setPort(port);\n        this.__data.onPortSet(port, newCommName);\n        this.__comms.push(newComm);\n        newComm.sendMessage(TCMessageHeaders.internal, [\n            TCInternalMessages.nameThread,\n            newCommName,\n            this._totalComms,\n        ]);\n    }\n    addPorts(ports) {\n        for (const port of ports) {\n            this.addPort(port);\n        }\n    }\n    addComms(comms) {\n        this._totalComms += comms.length;\n        this.__comms.push(...comms);\n    }\n    __isManagerMessage(data) {\n        return this.messageFunctions[data[0]] !== undefined;\n    }\n    __handleManagerMessage(data, event) {\n        if (!this.messageFunctions[data[0]])\n            return;\n        this.messageFunctions[data[0]].forEach((_) => _(data, event));\n    }\n    listenForMessage(message, run) {\n        this.messageFunctions[message] ??= [];\n        this.messageFunctions[message].push(run);\n    }\n    sendMessageToAll(message, data = [], transfers) {\n        for (const comm of this.__comms) {\n            comm.sendMessage(message, data, transfers);\n        }\n    }\n    runTasksForAll(id, data, transfers = [], queueId) {\n        for (const comm of this.__comms) {\n            comm.runTasks(id, data, transfers, queueId);\n        }\n    }\n    runTask(id, data, transfers = [], threadNumber = -1, queueId) {\n        if (threadNumber < 0) {\n            const comm = this.__comms[this._currentCom];\n            comm.runTasks(id, data, transfers, queueId);\n            return this.__handleCount();\n        }\n        else {\n            const comm = this.__comms[threadNumber];\n            comm.runTasks(id, data, transfers, queueId);\n            return threadNumber;\n        }\n    }\n    runPromiseTasks(id, data, transfers = [], onDone, threadNumber, excludeThread = -1) {\n        if (typeof threadNumber === \"undefined\") {\n            if (this._currentCom == excludeThread) {\n                this.__handleCount();\n            }\n            const comm = this.__comms[this._currentCom];\n            comm.runPromiseTasks(id, data, transfers, onDone);\n            return this.__handleCount();\n        }\n        else {\n            const comm = this.__comms[threadNumber];\n            comm.runPromiseTasks(id, data, transfers, onDone);\n            return threadNumber;\n        }\n    }\n    __handleCount() {\n        let countReturn = this._currentCom;\n        this._currentCom++;\n        if (this._currentCom >= this._totalComms) {\n            this._currentCom = 0;\n        }\n        return countReturn;\n    }\n    addQueue(id, associatedTasksId, getQueueKey = null, beforeRun = (data) => data, afterRun = (data, thread) => { }, getThread = (data) => -1, getTransfers = (data) => []) {\n        if (this.__queues[id]) {\n            this.__throwError(`Queue with ${id} already exists.`);\n        }\n        const newQueue = new QueueManager(id, (data, queueId) => {\n            data = beforeRun(data);\n            const thread = this.runTask(associatedTasksId, data, getTransfers(data), getThread(data), queueId);\n            afterRun(data, thread);\n        }, this, getQueueKey);\n        this.__queues[id] = newQueue;\n        return newQueue;\n    }\n    getQueue(id) {\n        const queue = this.__queues[id];\n        if (!queue) {\n            this.__throwError(`Queue with ${id} does not exists.`);\n        }\n        return queue;\n    }\n    __syncQueue(id, sab) {\n        for (const comm of this.__comms) {\n            comm.__syncQueue(id, sab);\n        }\n    }\n    __unSyncQueue(id) {\n        for (const comm of this.__comms) {\n            comm.__unSyqncQueue(id);\n        }\n    }\n    syncData(dataType, data) {\n        for (const comm of this.__comms) {\n            comm.syncData(dataType, data);\n        }\n    }\n    unSyncData(dataType, data) {\n        for (const comm of this.__comms) {\n            comm.unSyncData(dataType, data);\n        }\n    }\n}\n","export {};\n","import { Queue } from \"../tools/Queue.js\";\nexport class QueueManager {\n    id;\n    onRun;\n    _manager;\n    getQueueKey;\n    __queueData = {};\n    constructor(id, onRun, _manager, getQueueKey = null) {\n        this.id = id;\n        this.onRun = onRun;\n        this._manager = _manager;\n        this.getQueueKey = getQueueKey;\n    }\n    __getQueueKey(data) {\n        if (this.getQueueKey !== null) {\n            return this.getQueueKey(data);\n        }\n        if (Array.isArray(data)) {\n            return data.toString();\n        }\n        if (typeof data == \"object\") {\n            return JSON.stringify(data);\n        }\n        return String(data);\n    }\n    __getQueueData(id) {\n        const queue = this.__queueData[id];\n        if (!queue) {\n            throw new Error(`Queue with id: ${id} does not exists.`);\n        }\n        return this.__queueData[id];\n    }\n    addQueue(queueId) {\n        const sab = new SharedArrayBuffer(4);\n        if (this.__queueData[queueId])\n            return false;\n        this.__queueData[queueId] = {\n            queue: new Queue(),\n            map: {},\n            stateSAB: sab,\n            state: new Uint32Array(sab),\n        };\n        const syncId = this._getSyncId(queueId);\n        this._manager.__syncQueue(syncId, sab);\n        return true;\n    }\n    _getSyncId(queueId) {\n        return `${this.id}-${queueId}`;\n    }\n    removeQueue(queueId) {\n        if (!this.__queueData[queueId])\n            return false;\n        delete this.__queueData[queueId];\n        const syncId = this._getSyncId(queueId);\n        this._manager.__unSyncQueue(syncId);\n        return true;\n    }\n    add(data, queueId = \"main\") {\n        const queueData = this.__getQueueData(queueId);\n        const queueKey = this.__getQueueKey(data);\n        if (queueData.map[queueKey])\n            return;\n        queueData.map[queueKey] = true;\n        queueData.queue.enqueue(data);\n    }\n    run(queueId = \"main\", filter) {\n        const reQueue = new Queue();\n        const newMap = {};\n        const queueData = this.__getQueueData(queueId);\n        const queue = queueData.queue;\n        const state = queueData.state;\n        const syncId = this._getSyncId(queueId);\n        while (true) {\n            const data = queue.dequeue();\n            if (!data)\n                break;\n            if (filter) {\n                const filterReturn = filter(data);\n                if (filterReturn == 0)\n                    continue;\n                if (filterReturn == 1) {\n                    newMap[this.__getQueueKey(data)] = true;\n                    reQueue.enqueue(data);\n                    continue;\n                }\n            }\n            Atomics.add(state, 0, 1);\n            this.onRun(data, syncId);\n        }\n        this.__queueData[queueId].map = {};\n        if (filter) {\n            this.__queueData[queueId].queue = queue;\n            this.__queueData[queueId].map = newMap;\n        }\n    }\n    runAndAwait(queueId = \"main\", filter) {\n        this.run(queueId, filter);\n        return this.awaitAll(queueId);\n    }\n    awaitAll(queueId = \"main\") {\n        const queueData = this.__getQueueData(queueId);\n        return new Promise((resolve, reject) => {\n            const inte = setInterval(() => {\n                if (Atomics.load(queueData.state, 0) == 0) {\n                    clearInterval(inte);\n                    resolve(true);\n                }\n            }, 1);\n        });\n    }\n    onDone(queueId = \"main\", run) {\n        const queueData = this.__getQueueData(queueId);\n        const inte = setInterval(() => {\n            if (Atomics.load(queueData.state, 0) == 0) {\n                clearInterval(inte);\n                run();\n            }\n        }, 1);\n    }\n    isDone(queueId = \"main\") {\n        const queueData = this.__getQueueData(queueId);\n        return Atomics.load(queueData.state, 0) == 0;\n    }\n}\n","export class SyncedQueue {\n    id;\n    sab;\n    states = new Uint32Array();\n    constructor(id, sab) {\n        this.id = id;\n        this.sab = sab;\n        this.states = new Uint32Array(sab);\n    }\n    addToCount(total = 1) {\n        Atomics.add(this.states, 0, total);\n    }\n    subtractFromCount(total = 1) {\n        Atomics.sub(this.states, 0, total);\n    }\n    getCount() {\n        return Atomics.load(this.states, 0);\n    }\n    isDone() {\n        return this.getCount() == 0;\n    }\n    onDone(onDone) {\n        const inte = setInterval(() => {\n            if (this.getCount() == 0) {\n                clearInterval(inte);\n                onDone();\n            }\n        }, 1);\n    }\n    wait() {\n        return new Promise((resolve, reject) => {\n            this.onDone(() => {\n                resolve(true);\n            });\n        });\n    }\n}\n","export const PromiseTasks = {\n    _waiting: (new Map()),\n    addPromiseTakss(tasksId, tasksRequestsId, onDone) {\n        let requestsMap = this._waiting.get(tasksId);\n        if (!requestsMap) {\n            requestsMap = new Map();\n            this._waiting.set(tasksId, requestsMap);\n        }\n        requestsMap.set(tasksRequestsId, onDone);\n    },\n    completePromiseTasks(tasksId, tasksRequestsId, data) {\n        let requestsMap = this._waiting.get(tasksId);\n        if (!requestsMap)\n            return;\n        const run = requestsMap.get(tasksRequestsId);\n        requestsMap.delete(tasksRequestsId);\n        if (!run)\n            return;\n        run(data);\n    },\n};\n","import { Task } from \"./Tasks.js\";\nexport const TasksManager = {\n    _tasks: new Map(),\n    registerTasks(id, run, mode = \"async\") {\n        const tasks = new Task(id, run, mode);\n        this._tasks.set(id, tasks);\n        return tasks;\n    },\n    getTasks(id) {\n        const tasks = this._tasks.get(id);\n        if (!tasks)\n            return false;\n        return tasks;\n    },\n};\n","export class Task {\n    name;\n    run;\n    mode;\n    constructor(name, run, mode) {\n        this.name = name;\n        this.run = run;\n        this.mode = mode;\n    }\n}\n","//classes\nimport { CommManager } from \"./Manager/CommManager.js\";\nimport { CommBase } from \"./Comm/Comm.js\";\nimport { TasksManager } from \"./Tasks/TaskManager.js\";\nimport { DataSyncManager } from \"./Data/DataSyncManager.js\";\nimport { InternalTasks } from \"./Internal/InternalTasks.js\";\nexport const ThreadComm = {\n    threadNumber: 0,\n    threadName: \"unamed-threadcomm-thread\",\n    environment: \"browser\",\n    _comms: {},\n    _commManageras: {},\n    _queues: new Map(),\n    parent: new CommBase(\"\"),\n    internal: InternalTasks,\n    __initalized: false,\n    __expectedPorts: {},\n    crypto: {},\n    async $INIT(threadName, threadParentName) {\n        this.threadName = threadName;\n        this.parent.name = threadParentName;\n        const port = await this.getWorkerPort();\n        this.parent.setPort(port);\n        this.__initalized = true;\n        this.addComm(this.parent);\n        if (this.environment == \"browser\") {\n            this.crypto = crypto;\n        }\n        if (this.environment == \"node\") {\n            //@ts-ignore\n            this.crypto = require(\"crypto\");\n        }\n    },\n    getSyncedQueue(threadId, queueId) {\n        if (!this._queues.has(threadId))\n            return;\n        return this._queues.get(threadId)?.get(queueId);\n    },\n    addComm(comm) {\n        this._comms[comm.name] = comm;\n    },\n    createComm(name, mergeObject = {}) {\n        const newCom = Object.assign(new CommBase(name), mergeObject);\n        this._comms[name] = newCom;\n        return newCom;\n    },\n    createCommManager(data) {\n        const newCommManager = new CommManager(data);\n        this._commManageras[data.name] = newCommManager;\n        return newCommManager;\n    },\n    getComm(id) {\n        return this._comms[id];\n    },\n    getCommManager(id) {\n        return this._commManageras[id];\n    },\n    async getWorkerPort() {\n        if (this.environment == \"browser\") {\n            return self;\n        }\n        if (this.environment == \"node\") {\n            //@ts-ignore\n            const { parentPort } = require(\"worker_threads\");\n            return parentPort;\n        }\n    },\n    registerTasks(id, run, mode = \"async\") {\n        TasksManager.registerTasks(id, run, mode);\n    },\n    onDataSync(dataType, onSync, onUnSync) {\n        return DataSyncManager.registerDataSync(dataType, onSync, onUnSync);\n    },\n};\nif (\n//@ts-ignore\ntypeof process !== \"undefined\" &&\n    typeof Worker === \"undefined\" &&\n    typeof window === \"undefined\") {\n    ThreadComm.environment = \"node\";\n}\n","export * from \"./ThreadComm.js\";\nexport * from \"./Comm/Comm.js\";\nexport * from \"./Data/DataSync.js\";\nexport * from \"./Manager/CommManager.js\";\nexport * from \"./Tasks/Tasks.js\";\nexport * from \"./Meta/Comm/Comm.types.js\";\n","class QueueNode {\n    data;\n    next;\n    constructor(data) {\n        this.data = data;\n    }\n}\n//test\nexport class Queue {\n    size = 0;\n    first;\n    last;\n    enqueue(data) {\n        const node = new QueueNode(data);\n        if (this.size == 0) {\n            this.first = node;\n            this.last = node;\n        }\n        else {\n            this.last.next = node;\n            this.last = node;\n        }\n        this.size++;\n    }\n    dequeue() {\n        if (this.size == 0)\n            return null;\n        if (!this.first)\n            return null;\n        let prevFirst = this.first;\n        this.first = prevFirst.next;\n        prevFirst.next = null;\n        this.size--;\n        return prevFirst.data;\n    }\n}\n","class VSVec3 {\n    x;\n    y;\n    z;\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    copy() {\n        return new VSVec3(this.x, this.y, this.z);\n    }\n    copyTo(vec3) {\n        vec3.x = this.x;\n        vec3.y = this.y;\n        vec3.z = this.z;\n    }\n    toString() {\n        return `${this.x}_${this.y}_${this.z}`;\n    }\n    multiply(vec3) {\n        this.x *= vec3.x;\n        this.y *= vec3.y;\n        this.z *= vec3.z;\n        return this;\n    }\n}\n//Objects\nclass VoxelSpace {\n    data;\n    static simpleCubeHash(space) {\n        space._position.x =\n            (space._position.x >> space._boundsPower2.x) << space._boundsPower2.x;\n        space._position.y =\n            (space._position.y >> space._boundsPower2.y) << space._boundsPower2.y;\n        space._position.z =\n            (space._position.z >> space._boundsPower2.z) << space._boundsPower2.z;\n        return space._position;\n    }\n    static getPositionFromIndex(position, bounds, index) {\n        position.y = index % bounds.y >> 0;\n        position.x = (index / bounds.y) % bounds.x >> 0;\n        position.z = (index / (bounds.x * bounds.z)) >> 0;\n        return position;\n    }\n    static getIndex(position, bounds) {\n        return (position.y + position.x * bounds.y + position.z * bounds.z * bounds.x);\n    }\n    static WholeVec3 = new VSVec3(1, 1, 1);\n    static spatialHash(space, parentSpace, divisor = VoxelSpace.WholeVec3) {\n        const parentPosition = parentSpace.getPositionXYZ(space._position.x, space._position.y, space._position.z);\n        space._hashedPosition.x =\n            Math.abs(space._position.x - parentPosition.x) / divisor.x;\n        space._hashedPosition.y =\n            Math.abs(space._position.y - parentPosition.y) / divisor.y;\n        space._hashedPosition.z =\n            Math.abs(space._position.z - parentPosition.z) / divisor.z;\n        return space._hashedPosition;\n    }\n    static mapLocationToVec3(location, vector) {\n        location[1] = vector.x;\n        location[2] = vector.y;\n        location[3] = vector.z;\n    }\n    _location = [\"main\", 0, 0, 0];\n    _position = new VSVec3(0, 0, 0);\n    _hashedPosition = new VSVec3(0, 0, 0);\n    _bounds = new VSVec3(0, 0, 0);\n    _boundsPower2 = new VSVec3(0, 0, 0);\n    _boundsSet = false;\n    constructor(data) {\n        this.data = data;\n    }\n    getVolume() {\n        return this._bounds.x * this._bounds.y * this._bounds.z;\n    }\n    getArea() {\n        return this._bounds.x * this._bounds.z;\n    }\n    getHeight() {\n        return this._bounds.y;\n    }\n    getWidth() {\n        return this._bounds.x;\n    }\n    getDepth() {\n        return this._bounds.z;\n    }\n    setXYZ(x, y, z) {\n        this._position.x = x;\n        this._position.y = y;\n        this._position.z = z;\n        this.getPosition();\n        VoxelSpace.mapLocationToVec3(this._location, this._position);\n        return this;\n    }\n    setXZ(x, z) {\n        this._position.x = x;\n        this._position.z = z;\n        this.getPosition();\n        VoxelSpace.mapLocationToVec3(this._location, this._position);\n        return this;\n    }\n    getLocation() {\n        this.data.getPosition(this);\n        VoxelSpace.mapLocationToVec3(this._location, this._position);\n        return this._location;\n    }\n    getLocationXYZ(x, y, z) {\n        this.setXYZ(x, y, z);\n        VoxelSpace.mapLocationToVec3(this._location, this._position);\n        return this._location;\n    }\n    setLocation(location) {\n        this.setXYZ(location[1], location[2], location[3]);\n        return this;\n    }\n    updateLoaction(location) {\n        this.setXYZ(location[1], location[2], location[3]);\n        location[1] = this._location[1];\n        location[2] = this._location[2];\n        location[3] = this._location[3];\n        return this;\n    }\n    setCubeBounds(bounds) {\n        if (this._boundsSet)\n            return;\n        this._boundsPower2.x = bounds.x;\n        this._boundsPower2.y = bounds.y;\n        this._boundsPower2.z = bounds.z;\n        this._bounds.x = 2 ** this._boundsPower2.x;\n        this._bounds.y = 2 ** this._boundsPower2.y;\n        this._bounds.z = 2 ** this._boundsPower2.z;\n        this._boundsSet = true;\n        return this;\n    }\n    setBounds(bounds) {\n        if (this._boundsSet)\n            return;\n        this._bounds.x = bounds.x;\n        this._bounds.y = bounds.y;\n        this._bounds.z = bounds.z;\n        this._boundsSet = true;\n        return this;\n    }\n    getPosition() {\n        return this.data.getPosition(this);\n    }\n    getPositionXYZ(x, y, z) {\n        return this.setXYZ(x, y, z).data.getPosition(this);\n    }\n    getPositionLocation(location) {\n        return this.setLocation(location).data.getPosition(this);\n    }\n    getIndex() {\n        return this.data.getIndex(this);\n    }\n    getIndexXYZ(x, y, z) {\n        return this.setXYZ(x, y, z).data.getIndex(this);\n    }\n    getIndexToXYZ(index) {\n        return this.data.getPostionFromIndex(this, index);\n    }\n    getIndexLocation(location) {\n        return this.setLocation(location).data.getIndex(this);\n    }\n    getPositionFromIndex(index) {\n        return this.data.getPostionFromIndex(this, index);\n    }\n    getKey() {\n        return `${this._position.x}_${this._position.y}_${this._position.z}`;\n    }\n    getKeyXYZ(x, y, z) {\n        return this.setXYZ(x, y, z).getKey();\n    }\n    getKeyLocation(location) {\n        return this.setLocation(location).getKey();\n    }\n}\nexport { VoxelSpace };\n","export {};\n","import { VoxelSpace } from \"./Classes/VoxelSpace.js\";\nconst merge = (target, newObject) => {\n    return Object.assign(target, newObject);\n};\nexport const VoxelSpaces = {\n    zeroPointSpace: new VoxelSpace({\n        getPosition(space) {\n            return space._position;\n        },\n        getIndex() {\n            return 0;\n        },\n        getPostionFromIndex(space, index) {\n            return space._position;\n        },\n    }),\n    getVoxelSpaces() {\n        const regionSpace = merge(new VoxelSpace({\n            getPosition(space) {\n                return VoxelSpace.simpleCubeHash(space);\n            },\n            getIndex(space) {\n                return -Infinity;\n            },\n            getPostionFromIndex(space, index) {\n                return space._position;\n            },\n        }), {\n            chunkBounds: { x: 0, y: 0, z: 0 },\n            columnBounds: { x: 0, y: 0, z: 0 },\n            getChunkVolume() {\n                return this.chunkBounds.x * this.chunkBounds.y * this.chunkBounds.z;\n            },\n            getColumnVolume() {\n                return (this.columnBounds.x * this.columnBounds.y * this.columnBounds.z);\n            },\n        });\n        const columnSpace = new VoxelSpace({\n            getPosition(space) {\n                return VoxelSpace.simpleCubeHash(space);\n            },\n            getIndex(space) {\n                return VoxelSpace.getIndex(VoxelSpace.spatialHash(space, regionSpace, space._bounds), regionSpace.columnBounds);\n            },\n            getPostionFromIndex(space, index) {\n                return VoxelSpace.getPositionFromIndex(space._position, regionSpace.columnBounds, index).multiply(space._bounds);\n            },\n        });\n        const chunkSpace = merge(new VoxelSpace({\n            getPosition(space) {\n                return VoxelSpace.simpleCubeHash(space);\n            },\n            getIndex(space) {\n                const ry = (space._position.y >> regionSpace._boundsPower2.y) <<\n                    regionSpace._boundsPower2.y;\n                const cy = (space._position.y >> space._boundsPower2.y) <<\n                    space._boundsPower2.y;\n                return (cy - ry) / space._bounds.y;\n            },\n            getPostionFromIndex(space, index) {\n                return VoxelSpace.getPositionFromIndex(space._position, regionSpace.chunkBounds, index).multiply(space._bounds);\n            },\n        }), {\n            _regionPosition: { x: 0, y: 0, z: 0 },\n            getRegionPositonx() {\n                chunkSpace.getPosition();\n                return VoxelSpace.spatialHash(chunkSpace, regionSpace, chunkSpace._bounds);\n            },\n            getRegionPositonxXYZ(x, y, z) {\n                return chunkSpace.setXYZ(x, y, z).getRegionPositonx();\n            },\n            getRegionIndex() {\n                return VoxelSpace.getIndex(chunkSpace._hashedPosition, regionSpace.chunkBounds);\n            },\n            getRegionIndexXYZ(x, y, z) {\n                chunkSpace.getRegionPositonxXYZ(x, y, z);\n                return chunkSpace.getRegionIndex();\n            },\n        });\n        const voxelSpace = new VoxelSpace({\n            getPosition(space) {\n                VoxelSpace.spatialHash(space, chunkSpace);\n                space._position.x = space._hashedPosition.x;\n                space._position.y = space._hashedPosition.y;\n                space._position.z = space._hashedPosition.z;\n                return space._position;\n            },\n            getIndex(space) {\n                return VoxelSpace.getIndex(space._hashedPosition, space._bounds);\n            },\n            getPostionFromIndex(space, index) {\n                return VoxelSpace.getPositionFromIndex(space._position, chunkSpace._bounds, index);\n            },\n        });\n        return {\n            region: regionSpace,\n            column: columnSpace,\n            chunk: chunkSpace,\n            voxel: voxelSpace,\n            setDimensions(data) {\n                regionSpace.setCubeBounds(data.regions);\n                columnSpace.setCubeBounds(data.columns);\n                chunkSpace.setCubeBounds(data.chunks);\n                voxelSpace.setCubeBounds(data.chunks);\n                regionSpace.chunkBounds.x =\n                    regionSpace._bounds.x / chunkSpace._bounds.x;\n                regionSpace.chunkBounds.y =\n                    regionSpace._bounds.y / chunkSpace._bounds.y;\n                regionSpace.chunkBounds.z =\n                    regionSpace._bounds.z / chunkSpace._bounds.z;\n                regionSpace.columnBounds.x =\n                    regionSpace._bounds.x / columnSpace._bounds.x;\n                regionSpace.columnBounds.y =\n                    regionSpace._bounds.y / columnSpace._bounds.y;\n                regionSpace.columnBounds.z =\n                    regionSpace._bounds.z / columnSpace._bounds.z;\n            },\n        };\n    },\n    getZeroPointVoxelSpace(dimensions) {\n        const space = new VoxelSpace({\n            getPosition(space) {\n                VoxelSpace.spatialHash(space, VoxelSpaces.zeroPointSpace);\n                space._position.x = space._hashedPosition.x;\n                space._position.y = space._hashedPosition.y;\n                space._position.z = space._hashedPosition.z;\n                return space._position;\n            },\n            getIndex(space) {\n                return VoxelSpace.getIndex(space._hashedPosition, space._bounds);\n            },\n            getPostionFromIndex(space, index) {\n                return space._position;\n            },\n        });\n        space.setBounds(dimensions);\n        return space;\n    },\n};\n","export * from \"./VoxelSpaces.js\";\nexport * from \"./Types/VoxelSpaces.types.js\";\n"],"names":[],"sourceRoot":""}